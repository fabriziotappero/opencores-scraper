<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0" />
        <meta name="description" content="{{ site.description }}">
        <meta rel="author" href="{{ site.rel-author }}">
        <meta rel="publisher" href="{{ site.rel-publisher }}">
        <title>{{ site.title }}</title>
        <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
        <link rel="stylesheet" href="main.css">
        <link rel="stylesheet" href="style.css">
      
        <link href='//fonts.googleapis.com/css?family=Questrial' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Sanchez:400italic,400' rel='stylesheet' type='text/css'>
      
        <!--[if lt IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
      </head>
    <body>
      <!-- Google Tag Manager -->
      <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVTJLR"
      height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
      <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-MVTJLR');</script>
      <!-- End Google Tag Manager -->

      <div class="global_page_wrap">

<div class="ip_cores">
    <form action="#">
        <fieldset>
            <input type="text" name="search" value="" id="id_search" placeholder=" 859 free VHDL/Verilog IP cores at your fingertips..." autofocus />
        </fieldset>
    </form>
    <table id="table_example">
        <thead>
            <tr>
                <th width="30%">Project Name</th>
                <th width="5%">Repository</th>
                <th width="8%">Last Update</th>
                <th width="8%">Language</th>
                <th width="5%">Dev. Status</th>
                <th width="5%">License</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <b>ARITHMETIC CORE</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ant: NoLicense: LGPLDescriptionAudio Codec(ADPCM 1-Bit)The code is ready for Altera Cyclone-II DE1 Starter board and it is tested, you can modify codes and use them in any project.Core Description:Sampling Frequency: 44100HzChannels: StereoBit-rate: 1 Bit Per Sample(So it is: 44.1 * 2 = 88.2kbps)Compression Ratio: 16:1VHDL code consists:1-bit ADPCM Decoder(x2), I2S Driver(x1), I2C Driver(x1), Flash Memory Driver(x1), Keyboard Driver(x1), LED Bar(x1), Volume and Config Engine(x1).Codec(Encoder/Decoder) is available in Win32 application that you can use it to encode PCM RAW wave files, then burn</div>
                    <a href='cores/arithmetic_core/1_bit_adpcm_codec/index.html'>1 bit adpcm codec</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_1_bit_adpcm_codec'>code</a>
                </td>
                <td>May 22, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core lphaAdditional info:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionRTL Verilog code to perform Two Dimensional Fast Hartley Transform (2D-FHT) for 8x8 points.Presented algorithm is FHT with decimation in frequency domain.Main FeaturesHigh Clock SpeedLow Latency(97 clock cycles)Low Slice CountSingle Clock Cycle per sample operationFully synchronous core with positive edge triggeringFlexible core control with regard to input data widthDiscrete Hartley Transform is used in a wide variety of signal processing applications such as filtering, convolution, correlation, compression and so on</div>
                    <a href='cores/arithmetic_core/2d_fht/index.html'>2d fht</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_2d_fht'>code</a>
                </td>
                <td>Jul 25, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Design done,Specification doneWishBone Compliant: NoLicense: GPLDescriptionA 32-bit parallel and highly pipelined Cyclic Redundancy Code (CRC) generator is presented. The design can handle 5 different channels at an input rate of 2Gbps each (the total output throughput is 5x4Gbps.)The generated CRCs are compatible with the 32-bit Ethernet standards. The circuit has been implemented with standard cells in a 0.35Micron standard CMOS process using the properties of Galois Fields and has been conceived as a "free" IP.Features- 5 independent channels @ 4Gbps each- Works (simulations) with a standar</div>
                    <a href='cores/arithmetic_core/5x4gbps_crc_generator_designed_with_standard_cells/index.html'>5x4gbps crc generator designed with standard cells</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_5x4gbps_crc_generator_designed_with_standard_cells'>code</a>
                </td>
                <td>Aug 8, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ment status:PlanningAdditional info:WishBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/arithmetic_core/8-bit_piepelined_processor/index.html'>8-bit piepelined processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_8-bit_piepelined_processor'>code</a>
                </td>
                <td>Mar 30, 2015</td>
                <td>C/C++</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core n done,FPGA provenWishBone Compliant: NoLicense: GPLDescriptionThis is 8-bit microprocessor with 5 instructions. It is based on 8080 architecture. This architecture called SAP for Simple-As-Possible computer. It very useful design which introduces most of the basic and fundamental ideas behind computer operation.This design could be used for instruction classes for undergraduate classes or specific VHDL classes. This processor is based on the 8080 architecture, therefore, it could be upgraded step by step to integrate further facilities. It is very exciting challenge for the students to do so.</div>
                    <a href='cores/arithmetic_core/8-bit_up/index.html'>8-bit up</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_8-bit_up'>code</a>
                </td>
                <td>Apr 11, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core  done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThis is crypto core with AMBA support APB based on datasheet fomAES_SPECIf you liked our work is want to help contribute to the future progress of others who have seen help us by donating.GITHUB : git clone  https://github.com/red0bear/AES128GLADIC is a group of people working with integrated circuits in Latin America that have done some work with integrated circuits or participated in training in the part of the digital flow. We hope that our IPs are also vital in any way the proposal for those who want to use i</div>
                    <a href='cores/arithmetic_core/aes128/index.html'>aes128</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_aes128'>code</a>
                </td>
                <td>Mar 9, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core n doneWishBone Compliant: NoLicense: LGPLDescriptionA fast (single-cycle) base-2 antilog function.Need an electronic design solution? Visithttp://www.cantares.on.ca/Doesn't run quite as fast as my Log code: 166MHz, vs. 250MHz for the log. Registering the input would bring that up. Takes about the same resources as the log.To do a single-cycle square-root, first take the log. Then, divide that result by 2 (shift), and take the antilog. Tada...If you use this, please write and tell me about it!</div>
                    <a href='cores/arithmetic_core/anti-logarithm_square-root_base-2_single-cycle/index.html'>anti-logarithm square-root base-2 single-cycle</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_anti-logarithm_square-root_base-2_single-cycle'>code</a>
                </td>
                <td>Jan 28, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core mpliant: NoLicense:DescriptionThese cores provide a simple means of converting between binary and BCD in hardware.  Written in Verilog, with parameters for the input and output widths, these simple cores illustrate the use of functions in Verilog for performing operations that are not easy to do any other way in a fully parameterized (scalable) block of logic.There are two conversions:  binary_to_bcd and bcd_to_binary.  These operate serially, requiring one clock per binary bit used in the conversion.The method used for the conversion from base 2 to base 10 is what I call a "binary coded decim</div>
                    <a href='cores/arithmetic_core/binary_to_bcd_conversions_with_led_display_driver/index.html'>binary to bcd conversions with led display driver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_binary_to_bcd_conversions_with_led_display_driver'>code</a>
                </td>
                <td>Dec 23, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core  info:WishBone Compliant: NoLicense: LGPLDescriptionThis project implements a parameterized Reed Solomon decoder for use in OFDM wireless systems.FeaturesDecodes full length (n = 255, t = 16) and shortened Reed Solomon encoded data blocks.Status- Complete version submitted</div>
                    <a href='cores/arithmetic_core/bluespec_systemverilog_reed_solomon_decoder/index.html'>bluespec systemverilog reed solomon decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_bluespec_systemverilog_reed_solomon_decoder'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Bluespe</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Compliant: NoLicense: LGPL</div>
                    <a href='cores/arithmetic_core/btc-fpga-miner-open_source_fpga_bitcoin_miner/index.html'>btc-fpga-miner-open source fpga bitcoin miner</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_btc-fpga-miner-open_source_fpga_bitcoin_miner'>code</a>
                </td>
                <td>May 15, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core hBone Compliant: NoLicense: LGPLDescriptionThis IP implements the CAVLC parsing process in ITU-T H.264 (05/2003)Features- Compatible with ITU-T H.264 (05/2003), but it do not calculate nC and store TotalCoeff,you need to add a nC_decoder outside this core.- New structure for run_before decoder, the core doesn't save Runs in flip-flops anddoesn't need the run_combine process, this feature reduces both cycle and resource.- this core has a simple interface- 9 cycles per cavlc block on average(including P frames)- Fully synchronous design, Fully synthesisableStatusDocumentationSynthesis resultsPus</div>
                    <a href='cores/arithmetic_core/cavlc_decoder/index.html'>cavlc decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_cavlc_decoder'>code</a>
                </td>
                <td>Nov 20, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core e,FPGA proven,Specification doneWishBone Compliant: NoLicense: BSDIntroductionA cellular automata (CA) is a discrete model that consists of a grid (1D, 2D, 3D ) with objects called cells. Each cell can be in one of a given set of states (on and off, different colours etc). Each cell has a set of cells in close proximity (neighbours). Given the current internal state of a cell, the states of the neighbour cells and a given set of update rules the next state of a cell can be determined.The ca_prng IP-core implements a 1D binary cellular automata with wrap around at the edges (i.e. a ring). The d</div>
                    <a href='cores/arithmetic_core/cellular_automata_prng/index.html'>cellular automata prng</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_cellular_automata_prng'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ant: NoLicense:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  Seewww.confluent.orgfor more info.Cordics (COordinate Rotation DIgital Computers) perform arbitrary phase rotations of complex vectors and are often used to calculate trigonometric functions and vector magnitudes.FeaturesEach file is stand-alone and represents a specific configuration.The 4 parameters are:- Rotation or Vector Mode- Vector Precision- Angle Precision- Number of Cordic StagesAll designs </div>
                    <a href='cores/arithmetic_core/cf_cordic/index.html'>cf cordic</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_cf_cordic'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core : NoLicense:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  SeeConfluentfor more info.The Fast Fourier Transform converts time or spacial information into the frequency domain and is one of the most popular DSP algorithms.FeaturesThe FFT architecture is pipelined on a rank basis; each rank hasits own butterfly and ranks are isolated from each other usingmemory interleavers.  This FFT can perform calculations oncontinuous streaming data (one data set right after a</div>
                    <a href='cores/arithmetic_core/cf_fft/index.html'>cf fft</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_cf_fft'>code</a>
                </td>
                <td>May 18, 2012</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ant: NoLicense:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  SeeConfluentfor more info.FeaturesThe floating point representation follows the IEEE-754 bit format:{SignBit, Exponent, Mantissa}Each file is stand-alone and represents a specific configuration.The 3 configuration parameters are:- Combinatorial or Pipelined ('c' or 'p')- Exponent Precision- Mantissa PrecisionNote the total width = 1 + Exponent Precision + Mantissa Precision.For pipeline configurations, pi</div>
                    <a href='cores/arithmetic_core/cf_floating_point_multiplier/index.html'>cf floating point multiplier</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_cf_floating_point_multiplier'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core pecification doneWishBone Compliant: NoLicense: LGPLDefinitionA Complex arithmetic library for arithmetic operations is needed in many signal processing applications. This project will present a complex operations library for SystemC based designs. Some of the operations like multiplication, division and square root are based on Cordic algorithms in order to reduce the resources needed for implementation. Eventhough the library is based on the complex library of the Agility Compiler Software but nearly all of the operations were modified and improved. The operations included within this projec</div>
                    <a href='cores/arithmetic_core/complex_arithmetic_operations/index.html'>complex arithmetic operations</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_complex_arithmetic_operations'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>SystemC</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core atus:PlanningAdditional info:WishBone Compliant: NoLicense: LGPLDescriptionGaussian Pseudo-random Number Generator is a fix-point entity implemented with VHDL, used for generating complex Gaussian pseudo-random numbers. The generator can be further divided into two stages. The first stage is a uniform pseudo-random number generator called Mersenne Twister, and the second is a conversion stage. Mersenne Twister provides uniform pseudo-random number sequence with an astronomical period of 2^19937-1 up to 32-bit accuracy, using only 624 words working area [1]. A conversion model was built upon Me</div>
                    <a href='cores/arithmetic_core/complex_gaussian_pseudo-random_number_generator/index.html'>complex gaussian pseudo-random number generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_complex_gaussian_pseudo-random_number_generator'>code</a>
                </td>
                <td>Dec 21, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core mpliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/complex_operations_ise_for_nios_ii/index.html'>complex operations ise for nios ii</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_complex_operations_ise_for_nios_ii'>code</a>
                </td>
                <td>Sep 14, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core gn done,FPGA provenWishBone Compliant: NoLicense:DescriptionA 100% behavioral implementation of a cordic core.  The core is highly configurable through `defines.  A testbench is included.  See the included manual for details. Source and user manual availablehereStatus- Tested in hardware</div>
                    <a href='cores/arithmetic_core/configurable_cordic_core_in_verilog/index.html'>configurable cordic core in verilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_configurable_cordic_core_in_verilog'>code</a>
                </td>
                <td>Aug 12, 2011</td>
                <td>Verilog</td>
                <td>Unknow</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core fo:WishBone Compliant: NoLicense: LGPLdownload</div>
                    <a href='cores/arithmetic_core/configurable_crc_core/index.html'>configurable crc core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_configurable_crc_core'>code</a>
                </td>
                <td>Sep 9, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ign done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis is a behavioral module for parallel scrambler/descrambler.There are RTL scrambler modules available, the purpose of this project is to built a code that is easier to understand and more flexible for reconfiguration. The code is synthesize-able, and should not cost more than RTL modules.</div>
                    <a href='cores/arithmetic_core/configurable_parallel_scrambler/index.html'>configurable parallel scrambler</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_configurable_parallel_scrambler'>code</a>
                </td>
                <td>Jul 31, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core GA provenWishBone Compliant: NoLicense: GPLDescriptionThe CORDIC algorithm is an iterative algorithm to evaluate many mathematical functions, such as trigonometrically functions, hyperbolic functions and planar rotations.Core DescriptionAs the name suggests the CORDIC algorithm was developed for rotating coordinates, a piece of hardware for doing real-time navigational computations in the 1950's. The CORDIC uses a sequence like successive approximation to reach its results. The nice part is it does this by adding/subtracting and shifting only.Suppose we want to rotate a point(X,Y) by an an</div>
                    <a href='cores/arithmetic_core/cordic_core/index.html'>cordic core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_cordic_core'>code</a>
                </td>
                <td>Jan 8, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core pliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/crcahb/index.html'>crcahb</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_crcahb'>code</a>
                </td>
                <td>Mar 6, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core pliant: NoLicense: LGPLDescriptionThis core is a low latency divider that works by caching reciprocal values, then using a multiply to perform the divide rather than the usual divide operation. On first encountering a divide operation the reciprocal of the divisor is calculated, this takes the same amount of time as a normal divide. The next time the same divide is encountered the pre-calculated reciprocal is used. Reciprocals are stored in a small cache similar to a processor data cache.a/b is the same as a * 1/bIn many cases the divisor 'b' remains the same within a loop. 1/b can be calculat</div>
                    <a href='cores/arithmetic_core/cr_div-cached_reciprocal_divider/index.html'>cr_div-cached reciprocal divider</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_cr_div-cached_reciprocal_divider'>code</a>
                </td>
                <td>Feb 12, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core icense:DescriptionRecent advances in communications and networking technologies have made it possible that many applications use digital videos such as teleconferencing and multimedia communications. These applications require a very large bit-rate if being handled without compression. Most video compression standards such as HDTV, H.261, JPEG and MPEG use Discrete Cosine Transform (DCT) as a standard transform-coding scheme.Discrete Cosine Transform is decomposing the signal into weighted sums of cosine harmonics; unlike DCT, Discrete Fourier Transform decomposes the signal into weighted sums</div>
                    <a href='cores/arithmetic_core/dct-discrete_cosine_transformer/index.html'>dct-discrete cosine transformer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_dct-discrete_cosine_transformer'>code</a>
                </td>
                <td>Jul 26, 2013</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core  proven,Specification doneWishBone Compliant: NoLicense:DescriptionNEW: 12 bit input MDCT version created by Emrah Yuce has been added to project downloads.Parallel synthesizable implementation of 2D DCT in VHDL. Currently works on 8 bit input data using 12 bit DCT coefficients (12-bit DCT output). Multiplier-less design, parallel distributed arithmetic with butterfly computation used instead. Implementation done as row-column decomposition, two 1D DCT units and transpose matrix between them (double buffered as ping-pong buffer for performance). Latency (time between first 8 bit input data is </div>
                    <a href='cores/arithmetic_core/discrete_cosine_transform_core/index.html'>discrete cosine transform core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_discrete_cosine_transform_core'>code</a>
                </td>
                <td>Mar 7, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core oneWishBone Compliant: NoLicense:Features- The unit is designed to be synchronous to one global clock.  All registers are updated on the rising edge of the clock.- All registers can be reset with one global reset.- The multiply operation is broken up to take advantage of the 25 x 18 multiply blocks in the Virtex5 DSP48E slices.  The 25 x 18 multiply twos complement block will perform a 24 x 17 unsigned multiply, so it takes 9 DSP48E slices to perform the 53 x 53 bit multiply required to multiply two double-precision floating point numbers.- fpu_double.v is the top-level module.  The input sign</div>
                    <a href='cores/arithmetic_core/double_fpu_verilog/index.html'>double_fpu_verilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_double_fpu_verilog'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core nfo:WishBone Compliant: NoLicense: LGPLDescriptionIntroduction:From my thesis: Low-Density Parity Check (LDPC) coding is a form of error coding introduced by Gallager that can achieve performance close to the Shannon limit, exceeding the performance of Turbo codes.  The coding scheme was introduced in the early 1960&euro;&trade;s, but has gained favor recently due to excellent performance and lack of patent rights.  Several recent standards include optional or mandatory LDPC coding methods; among these is the second generation Digital Video Broadcasting standard for satellite applications (DVB</div>
                    <a href='cores/arithmetic_core/dvb-s2_ldpc_decoder/index.html'>dvb-s2 ldpc decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_dvb-s2_ldpc_decoder'>code</a>
                </td>
                <td>Dec 3, 2010</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core WishBone Compliant: NoLicense: GPLComments# ECPU 0.1.alpha# ==============## Background# ========# Resurrected university project originally written in VHDL.# Converted to Verilog by hand and fixed bugs.## Modifications made in verilog post-conversion:# - New barrel shifter# - Reviewed opcode list# - Enhanced testbench to allow for random stimulus (verilog only tb)# - Tested using Icarus## Currently checking for synthesis:# - Passes synthesis checks using "veriwell ... +synopsys"## Features# ========# * 15 working opcodes/functions :#     cADD_AB#     cINC_A#     cINC_B#     cSUB_AB#     cCMP_</div>
                    <a href='cores/arithmetic_core/ecpu_alu/index.html'>ecpu_alu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_ecpu_alu'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core GA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe Elliptic Curve Group core is for computing the addition of two elements in the elliptic curve group, and the addition of $c$ identical elements in the elliptic curve group.The elliptic curve is super-singular $E:y^2=x^3-x+1$ in affine coordinates defined over a Galois field $GF(3^m)$, $m=97$, whose irreducible polynomial is $x^97+x^12+2$.The elliptic curve group is the set of solutions $(x,y)$ over $GF(3^m)$ to the equation of $E$, together with an additional point at infinity, denoted $O$. An element in the elliptic</div>
                    <a href='cores/arithmetic_core/elliptic_curve_group/index.html'>elliptic curve group</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_elliptic_curve_group'>code</a>
                </td>
                <td>Apr 18, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core bleAdditional info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThis project was started in order to create fixed point (Q format) arithmetic modules in verilog.What was created was a parameterized (specify size (N) and number of fractional bits (Q)) implementation to make configuring for different projects simple.This implementation uses the following data structure:| sign (0+/1-) | whole number | fractional bits || ____1 bit___ | _N-Q-1 bits_ | _____Q bits____ |The following modules were created:-Twos Complement-Addition (Combinational)-Multiplicati</div>
                    <a href='cores/arithmetic_core/fixed_point_arithmetic_modules/index.html'>fixed point arithmetic modules</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_fixed_point_arithmetic_modules'>code</a>
                </td>
                <td>Oct 31, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core dditional info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLSynopsisVerilog Fixed point math libraryOriginal work by Sam Skalicky, originally foundhereExtended, updated, and heavily commented by Tom BurkeThis library includes the basic math functions for the Verilog Language,for implementation on FPGAs.All units have been simulated and synthesized for Xilinx Spartan 3E devicesusing the Xilinx ISE WebPack tools v14.7These math routines use a signed magnitude Q,N format, where N is the totalnumber of bits used, and Q is the number of fractional bits used.  For ins</div>
                    <a href='cores/arithmetic_core/fixed_point_math_library_for_verilog/index.html'>fixed point math library for verilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_fixed_point_math_library_for_verilog'>code</a>
                </td>
                <td>Oct 30, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core one Compliant: NoLicense: LGPLDescriptionVHDL project for a Square Root Unit (SRU) for 32-bit fixed point data. The unit implements the Goldschmidt recursion algorithm. It is pipelined with Initiation Interval of 1 clock cycle, and it perform the computation of a single square root with a latency of 3 clock cycles.The design has been tested on 45nm ASIC library.</div>
                    <a href='cores/arithmetic_core/fixed_point_square_root_recursive_algorithm/index.html'>fixed point square root recursive algorithm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_fixed_point_square_root_recursive_algorithm'>code</a>
                </td>
                <td>Mar 16, 2015</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core rovenWishBone Compliant: NoLicense: GPLDescriptionQuadratic_func is a fully pipelined quadratic polynomial that computes the relation y = ax^2 + bx + c.  On each rising-edge of the clock (when en is high), the coefficients and input x term are sampled at the function inputs. The result has a latency of 3 clock cycles.  All inputs to the function are 8-bit signed fractions, with the generic parameter 'fw' specifying the number of fraction bits.  The output result is a 24-bit signed fraction.  If integer arithmetic is preferred, then the parameter fw should be set to 0.  For larger bit-widths, t</div>
                    <a href='cores/arithmetic_core/fixed-point_quadratic_polynomial/index.html'>fixed-point quadratic polynomial</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_fixed-point_quadratic_polynomial'>code</a>
                </td>
                <td>Jul 26, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core PGA provenWishBone Compliant: NoLicense:DescriptionThis Floating Point units were developed as part of the HAVOC project. The Design schematics and related files can be browsed at the FPU repository, or downloaded as a separate file from the FP units home page.The FP Adder is a single-precision, IEEE-754 compilant, signed adder/substractor. It includes both single-cycle and 6-stage pipelined designs. The design is fully synthesizable and has been tested in a Xilinx Virtex-II XC2V3000 FPGA, occupying 385 CLBs and with a theoretical maximum operating frecuency of 6MHz for the single-cycle  desig</div>
                    <a href='cores/arithmetic_core/floating_point_adder_and_multiplier/index.html'>floating point adder and multiplier</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_floating_point_adder_and_multiplier'>code</a>
                </td>
                <td>Feb 23, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core iant: NoLicense: LGPLDescriptionVHDL implementation of a fast space- and resource-efficient logarithm approximation unit for FPGAs.The unit is an implementation of the ICSILog algorithm.</div>
                    <a href='cores/arithmetic_core/floating-point_logarithm_unit/index.html'>floating-point logarithm unit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_floating-point_logarithm_unit'>code</a>
                </td>
                <td>Dec 21, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ne Compliant: NoLicense: LGPLDescriptionThis implementation project proposes a practical implementation of a Median Filter architecture focused in low-cost FPGA devices. The architecture is based on the research presented in the following paper:http://islab.soe.uoguelph.ca/sareibi/TEACHING_dr/ENG6530_RCS_html_dr/outline_W2014/docs/PAPER_REVIEW_dr/2013_dr/GRAD_dr/FPGAbasedMedianFilter.pdfSorry, but we do not have time to develop a proper architecture document. However the paper presents a brief and at the same time complete description for this implementation design.</div>
                    <a href='cores/arithmetic_core/fpga-based_median_filter/index.html'>fpga-based median filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_fpga-based_median_filter'>code</a>
                </td>
                <td>Mar 21, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core hBone Compliant: NoLicense:DescriptionThis is a 32-bit floating point unit (FPU), which I developed in a project within the Vienna University of Technology. It can do arithmetic operations on floating point numbers. The FPU complies fully with the IEEE 754 Standard. The FPU was tested and simulated in hardware and software.Features- FPU supports the following arithmetic operations:-	Add-	Subtract-	Multiply-	Divide-	Square Root- For each operation the following rounding modes are supported:-	Round to nearest even-	Round to zero-	Round up-	Round down- Pipelined to achieve high operating frequenc</div>
                    <a href='cores/arithmetic_core/fpu/index.html'>fpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_fpu'>code</a>
                </td>
                <td>Sep 9, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core WishBone Compliant: NoLicense:DescriptionIEEE-754 compliant double-precision floating point unit. 4 operations (addition, subtraction, multiplication, division) are supported, as are the 4 rounding modes (nearest, 0, +inf, -inf). This unit also supports denormalized numbers, which is rare because most floating point units treat denormalized numbers as zero. The unit can run at clock frequencies up to 185 MHz for a Virtex5 target device.Features- The unit is designed to be synchronous to one global clock.  All registers are updated on the rising edge of the clock.- All registers can be reset wi</div>
                    <a href='cores/arithmetic_core/fpu_double_vhdl/index.html'>fpu double vhdl</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_fpu_double_vhdl'>code</a>
                </td>
                <td>Oct 11, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core  Compliant: NoLicense: LGPLDescriptionFT816 floating point accelerator consists of two ninety-six bit floating point accumulators between which floating point or fixed point operations occur. Basic operations include ADD, SUB, MUL, DIV, FIX2FLT, FLT2FIX, SWAP, NEG and ABS. The floating point accumulators operate as a memory mapped device placed by default between $FEA200 and $FEA2FF. The floating point accelerator communicates through a byte wide data port and twenty-four bit address port. It was intended for use primarily with smaller byte oriented cpu&euro;&trade;s like the 65xx, 68xx series</div>
                    <a href='cores/arithmetic_core/ft816float-floating_point_accelerator/index.html'>ft816float-floating point accelerator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_ft816float-floating_point_accelerator'>code</a>
                </td>
                <td>Dec 9, 2014</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core GA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe Gaussian Noise Generator core generates white Gaussian noise of standard normal distribution, which can be used to measure BER to extremely low BER levels (~10-15). The core uses a 64-bit combined Tausworthe generator and an approximation of the inverse normal cumulative distribution function, which obtains a PDF that is Gaussian to up to 9.1&fnof;.The core was designed using synthesizable Verilog code and can be delivered as a soft-IP targeted for any FPGA device and ASIC technology. C/MATLAB models and correspondin</div>
                    <a href='cores/arithmetic_core/gaussian_noise_generator/index.html'>gaussian noise generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_gaussian_noise_generator'>code</a>
                </td>
                <td>Feb 1, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project implements the Galois Linear-feedback Shift Register (LFSR) in VHDL, and can be used for applications such as PRBS generation &amp; synchronisation, CRC computations, scrambling &amp; descrambling, cryptography, etc. This design is very generic / parameterisable, in the sense that it is intelligent enough to be able to "create" (or generate) the LFSR structure based on user input (a VHDL generic). In thelfsrentity (galois-lfsr.vhdl), there is a generic namedtaps, which allows you to input a vector of tap locations for the L</div>
                    <a href='cores/arithmetic_core/generic_galois_lfsr/index.html'>generic galois lfsr</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_generic_galois_lfsr'>code</a>
                </td>
                <td>Mar 4, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core one,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project is developed at Reconfigurable Computer Laboratory - FRM - UTN,and allows simulate and synthesize the Gregory-Newton extrapolation algorithm,using integer numbers.</div>
                    <a href='cores/arithmetic_core/gnextrapolator/index.html'>gnextrapolator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_gnextrapolator'>code</a>
                </td>
                <td>Aug 14, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core t: NoLicense:DescriptionThis is a collection of synthesizeable hardware dividers. Different types of dividers are available. All dividers are fully pipelined and provide a 2N by N division every clock cycle. All designs are fully parameteriseable and synthesizeable.The dividers take two inputs Z(2N-bit divident) and D(N-bit divisor), and return Q(N-bit quotient), S(N-bit remainder), div0(division by zero), and ovf(overflow).A sample implementation of a 32/16 bit divider with a remainder output runs at about 82MHz in a Spartan2e100 -6 device and occupies 1132 LUTs (about 47%) and 1736 registers</div>
                    <a href='cores/arithmetic_core/hardware_division_units/index.html'>hardware division units</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_hardware_division_units'>code</a>
                </td>
                <td>Sep 28, 2011</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core  Compliant: NoLicense: LGPLReferences1.	Yamamoto H., Mori S. Performance of a binary quantized all digital phase-locked loop with a new class of sequential filter//IEEE Trans.  1978.  V. Com-26, 1.  P. 35-45.2.	Cessna J.R., Levy D.M. Phase noise and transient times for a binary quantized digital phase-locked loop in which Gaussian noise//IEEE Trans.  1972.  V. Com-20, 2.  P. 94-104.3.	Yukawa J., Mori S. A binary quantized digital phase-locked loop//IECE.  1973.  Vol. 56-A, 12.  P. 79-85.</div>
                    <a href='cores/arithmetic_core/hardware_implementation_of_binary_fully_digital_ph/index.html'>hardware implementation of binary fully digital ph</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_hardware_implementation_of_binary_fully_digital_ph'>code</a>
                </td>
                <td>Feb 18, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ompliant: NoLicense: LGPL</div>
                    <a href='cores/arithmetic_core/hardware_load_balancer_for_multi-stage_software_ro/index.html'>hardware load balancer for multi-stage software ro</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_hardware_load_balancer_for_multi-stage_software_ro'>code</a>
                </td>
                <td>Sep 27, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core iant: NoLicense:DescriptionHierarchical Carry Save Algorithm (HCSA) is a modification of well known adder algorithm. Comes as VHDL IP core, shows good timing and small area requirements.The Generic HCSA ALU VHDL IP Core presents an example of HCSA methodology.HCSA adder and ALU with HCSA implemented as VHDL soft IP cores. Algorithm implemetation bases on recursion method.Basic Idea: Every Bit of the Result is calculated twice simultaneously :   1. As if there IS NO carry from LSB ( less significant bit )S(i) = A(i) + B(i) + 0;2. As if these IS a carry from LSBS(i) = A(i) + B(i) </div>
                    <a href='cores/arithmetic_core/hcsa_adder_and_generic_alu_based_on_hcsa/index.html'>hcsa adder and generic alu based on hcsa</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_hcsa_adder_and_generic_alu_based_on_hcsa'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core mpliant: NoLicense: BSDDescriptionThis project implements a sorter able to sort a continuous stream of data, consisting of records labeled with "sort keys".Sorter sorts one record every two clock cycles.Sorter is based on the heap sort algorithm. Efficient implementation is assured thanks to the use of internal dual portRAM in FPGA.The required size of heap is equal to the expected maximum distance between unsorted records in the data stream.Detailed descriptionThe sorter implemented in this project is designed for sorting of stream of constant length records.The main supposed application area</div>
                    <a href='cores/arithmetic_core/heap_sorter_for_fpga/index.html'>heap sorter for fpga</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_heap_sorter_for_fpga'>code</a>
                </td>
                <td>Oct 15, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core mpliant: NoLicense:DescriptionBefore You readThis is a brief overview of  the article about the series of multiplication algorithms. For comparison and estimation of proposed algorithms please refer to the full article...OverviewOperation of multiplication is very important in microelectronics. Each modern microprocessor has this operation within its instruction set, and advanced microprocessors have special multiplication units, that perform multiplication during 1 synchronization period(cycle). Especially valuable multiplication is in DSP processors, where it is practically main operation. P</div>
                    <a href='cores/arithmetic_core/hierarchical_integer_multiplier_unit/index.html'>hierarchical integer multiplier unit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_hierarchical_integer_multiplier_unit'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core e Compliant: NoLicense: OthersDescriptionHuffman code is used in the most streaming applications. I have written a Huffman decoder for jpeg pictures. For audio or other data streams the  code have to adapt.The state machine is controlled by the jpeg baseline markers.Jpeg header is parsing for quantization and Huffman tables. It is re-programmable in each picture header. The implementation of dynamic Huffman table is very practical. If no information in the header is found the tables from the last picture  are used again.In the stream  the stuffing bits are removed and recognized the codeword a</div>
                    <a href='cores/arithmetic_core/huffman_decoder/index.html'>huffman decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_huffman_decoder'>code</a>
                </td>
                <td>Nov 14, 2011</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core shBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/lcd162b_behavior_model/index.html'>lcd162b behavior model</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_lcd162b_behavior_model'>code</a>
                </td>
                <td>Sep 18, 2013</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core neWishBone Compliant: NoLicense: LGPLDescriptionThe lfsr core is a random number generator based on linear feedback shift register(LFSR).The sequence generated has the maximum length possible.The period of sequence generated by a n-bit LFSR is equal to 2^n-1.The tap values used are supposed to create maximum length sequence.The size of LFSR is a generic parameter.The core is designed in a way such that the seed of the process can be set from outside.An output enable pin make the output bit to zero's when driven low.A testbench code is provided along with core.You can use that to verify the res</div>
                    <a href='cores/arithmetic_core/lfsr-random_number_generator/index.html'>lfsr-random number generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_lfsr-random_number_generator'>code</a>
                </td>
                <td>Dec 23, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core neWishBone Compliant: NoLicense: LGPLDescriptionA fast (single-cycle) base-2 log function, based on the description athttp://www.cantares.on.ca/extras.htmlNeed an electronic design solution? Visithttp://www.cantares.on.ca/First uploaded version is in Verilog, with pipelining to maximize the clock frequency. An example implementation: It takes less than 2% of the smallest CycloneIII, and runs at 250MHz on the IOs. Probably even higher if internal-only. It even fits in a mid-sized CPLD!Second version strips outs the pipelining registers. Simpler if you don't need the throughput. This one clocks </div>
                    <a href='cores/arithmetic_core/logarithm_function_base-2_single-cycle/index.html'>logarithm function base-2 single-cycle</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_logarithm_function_base-2_single-cycle'>code</a>
                </td>
                <td>Jan 28, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core :Design done,FPGA provenWishBone Compliant: YesLicense: GPLDescriptionThis IP core allows lossless data compression based on the Lempel-Ziv-Ross-Williams-1 algorithm. Its focus is on high throughput (of uncompressed data) at the expense of an somewhat lower compression ratio. One byte of uncompressed data can be processed at every second clockcycle. A software decoder (decompressor) written in java is included.The core is fully pipelined to allow high clock speeds. 66MHz can easily be achieved on a Spartan6FPGA. This results in a maximum compression throughput of almost 32MBytes/sec.It uses a </div>
                    <a href='cores/arithmetic_core/lzrw1_compressor_core/index.html'>lzrw1 compressor core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_lzrw1_compressor_core'>code</a>
                </td>
                <td>Dec 19, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core tional info:Design doneWishBone Compliant: NoLicense: LGPLDescriptionthe aim of this design to build combinatorial digital circuit to find in fast parallel the maximum or the minimum of set of given set data where number of entries = N, can be configured at compile time and also the width = M of each entry.the design idea based on  binary tree structure, where there are Log_2(N) levels in the tree, the best values of N whereLog_2(N) = integer numbers like N = ( 4, 8, 16, 32, 64,...) where Log_2(N) = {2, 3, 4, 5, ...}. but to support general values of N like 29 the design will be Log_2(29)+1 wh</div>
                    <a href='cores/arithmetic_core/maximum-minimum_binary_tree_finder/index.html'>maximum/minimum binary tree finder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_maximum-minimum_binary_tree_finder'>code</a>
                </td>
                <td>Oct 5, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ompliant: NoLicense: LGPLDescriptionThe MESI InterSection Controller (ISC) is a coherence system controller. It supports theMESI coherence protocolfor a cache data consistency. It synchronizes the memory requests of the system masters. It enables to keep the consistency of the data in the memory and in the local caches.This project provides the following elements:A synthesizable controller core with a complete environment of verification, synthesis, and documentation.Instructions for integrating MESI_ISC to a system.A definition and requirements of the system masters.For a detailed descripti</div>
                    <a href='cores/arithmetic_core/mesi_coherency_intersection_controller/index.html'>mesi coherency intersection controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_mesi_coherency_intersection_controller'>code</a>
                </td>
                <td>Mar 17, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Bone Compliant: NoLicense:DescriptionDescription of project..</div>
                    <a href='cores/arithmetic_core/microprocessor_za208/index.html'>microprocessor za208</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_microprocessor_za208'>code</a>
                </td>
                <td>Jun 23, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Compliant: NoLicense: LGPLDescriptionA quick &amp; simple mod 3 calculator(only just combinational logic). the input 8-bit data is divided by 3. and the output is only 0, 1, or 2.I use XilinxISE10.1 Synthesis the file, the speed can reach 113MHz.If anyone want make it more faster, you can insert some registers and make it pipeline.</div>
                    <a href='cores/arithmetic_core/mod3_calc/index.html'>mod3_calc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_mod3_calc'>code</a>
                </td>
                <td>Oct 11, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core nt: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/modbus_implementation_in_vhdl/index.html'>modbus implementation in vhdl</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_modbus_implementation_in_vhdl'>code</a>
                </td>
                <td>Feb 24, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Design done,FPGA provenWishBone Compliant: NoLicense: LGPLDescription// number sorting device, sequential, 2*N clocks for N// linear buffer implementation// sequential, stable, can be partly readed, decreasing order// reset is not implemented// see sort_stack_algorithm.png to catch the idea// number sorting, tree-like implementation, sequential,// energy efficient (theoreticaly)// see sort_tree_algorithm.png to catch the ideaArticle(Russian):http://habrahabr.ru/post/222287/</div>
                    <a href='cores/arithmetic_core/numbert_sort_device_on/index.html'>numbert sort device on</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_numbert_sort_device_on'>code</a>
                </td>
                <td>May 10, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core liant: NoLicense: GPLDescriptionFree and open source double precision Floating Point Unit (FPU).TheopenFPU64currently features:- double precision- Addition/Subtraction- Multiplication- rounding (to nearest even)- subnormals/denormals- validated against IEEE754- Compatible with Avalon Bus- Wishbone interface will be provided soonNew algorithms can be added easily, just modify the code markedwith ADD_ALGORITHMS_HEREEverything marked with FUTURE is not yet implemented,but already added for easier transition.Tested on CycloneII and Cyclone III FPGAs.If any questions arise, don't hesitate to contac</div>
                    <a href='cores/arithmetic_core/openfpu64/index.html'>openfpu64</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_openfpu64'>code</a>
                </td>
                <td>May 7, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core l info:Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe ORSoC Graphics Accelerator can:Draw Lines.Draw Filled or Textured Rectangles.Draw Filled, Interpolated or Textured Triangles.Draw Filled Quadratic Bzier Curves.Write Text with Bitmap Fonts or Vector Fonts.Draw Alphablended shapes.Draw Colorkeyed images.Draw 3D meshes with support for depth buffer.Transform points (scaling &amp; rotation of triangles and vector fonts).The ORSoC GFX have support for the following formats:Support for .TTF fonts.Support for .OBJ files for 3D meshes.Support for .bmp,</div>
                    <a href='cores/arithmetic_core/orsoc_graphics_accelerator/index.html'>orsoc graphics accelerator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_orsoc_graphics_accelerator'>code</a>
                </td>
                <td>May 5, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Compliant: NoLicense: BSDDescriptionThis project implements a simple parametrized FFT engine.The user may define length of FFT (fftlen equal to a power of 2), and may also define the format of numbers used.To change the format of numbers, the user must change definition of the icpx_number (internal complex number) type defined in the icpx_pkg.vhd file.It is also necessary to adjust the conversion functions defined in this file.The user must also modify the butterfly.vhd file, so that the entity "butterfly" performs calculations on the user defined type.There are two implementations available.I</div>
                    <a href='cores/arithmetic_core/parametrized_fft_engine/index.html'>parametrized fft engine</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_parametrized_fft_engine'>code</a>
                </td>
                <td>Mar 24, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core e Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/pid_controler/index.html'>pid controler</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_pid_controler'>code</a>
                </td>
                <td>Sep 20, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core shBone Compliant: NoLicense: GPLDescriptionVHDL Implementation of a basic Pipeline MIPS processor. It has a translator of MIPS assembler code and implement the division algorithm restoring.</div>
                    <a href='cores/arithmetic_core/pipeline_mips_in_vhdl/index.html'>pipeline mips in vhdl</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_pipeline_mips_in_vhdl'>code</a>
                </td>
                <td>May 29, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core e Compliant: NoLicense: LGPLDescriptionC code for generating a stand-alone population counter with user-defined size (number of input bits) and latency (number of clock cycles) in VHDL.</div>
                    <a href='cores/arithmetic_core/population_counter_generator/index.html'>population counter generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_population_counter_generator'>code</a>
                </td>
                <td>Jul 12, 2011</td>
                <td>C/C++</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core pliant: NoLicense:DescriptionBefore You readThis is a brief overview of  the article about the series of multiplication algorithms. For comparison and estimation of proposed algorithms please refer to the full article...OverviewOperation of multiplication is very important in microelectronics. Each modern microprocessor has this operation within its instruction set, and advanced microprocessors have special multiplication units, that perform multiplication during 1 synchronization period(cycle). Especially valuable multiplication is in DSP processors, where it is practically main operation. Pe</div>
                    <a href='cores/arithmetic_core/pyramid_integer_multiplier_unit/index.html'>pyramid integer multiplier unit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_pyramid_integer_multiplier_unit'>code</a>
                </td>
                <td>Jul 17, 2003</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core NoLicense:DescriptionThis is synthesizeable radix 4 complex fft processor. Input data width and points are configurable. Output data width = Input data width + 2. Some necessary limited and shift have been done at every butterfly.A sample implementation of a 1024 point 12 bit FFT runs at about 97MHz in a Spartan2e100 -6 device and occupies 1,271 LUTs (about 52%) and 1,144 registers (about 47%) of the device.Features- Data width configurable- Point configurable- Input data during data output- Simulation result has compare with Matlab resultStatus- Design is available in VHDL from OpenCores CVS </div>
                    <a href='cores/arithmetic_core/radix_4_complex_fft/index.html'>radix 4 complex fft</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_radix_4_complex_fft'>code</a>
                </td>
                <td>Sep 30, 2010</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core liant: NoLicense: LGPLDescriptionRay Tracing : A rendering technique that challenges anyone who is interested in Computer Science, Computer Graphics and Digital Systems in General.The Main Goal of this project is to create an engine to Render 3D models. This engine is made over HW/SW. What Im planning to do is to make a RTL generic enough to plug it along with a processor, by means of a bus or any connector the developer wishes.So the RTL's published on this page will describe the HW part of the engine. I don't know, YET, if I'm allowed to upload SW source code.  If I am, for sure I will, but </div>
                    <a href='cores/arithmetic_core/ray_tracing_arithmetic_engine/index.html'>ray tracing arithmetic engine</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_ray_tracing_arithmetic_engine'>code</a>
                </td>
                <td>Jul 25, 2011</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core iant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/reconfigurable_hardware_platform/index.html'>reconfigurable hardware platform</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_reconfigurable_hardware_platform'>code</a>
                </td>
                <td>Mar 29, 2012</td>
                <td>Other</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core one,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project implements a parameterized Reed Solomon decoder for use in OFDM wireless systems.Source code provided in C++ (trunk/cpp-source) and Bluespec(trunk/bluespec-source).</div>
                    <a href='cores/arithmetic_core/reed-solomon_decoder/index.html'>reed-solomon decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_reed-solomon_decoder'>code</a>
                </td>
                <td>Jun 16, 2010</td>
                <td>C/C++</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core nfo:Design done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionA divider that calculates the quotient and remainder of a division operation in multiple clock cycles. The dividend, divisor, quotient and remainder are all 32-bit signed integers. By taking the advantage of a shifter that can shift more than one bit (up to 9 bits) during each cycle of computation, it takes less cycles to finish than a radix-2 nonrestoring divider.</div>
                    <a href='cores/arithmetic_core/signed_integer_divider/index.html'>signed integer divider</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_signed_integer_divider'>code</a>
                </td>
                <td>Mar 8, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ification doneWishBone Compliant: NoLicense: BSDDescriptionSine and cosine table that can be synthesized. Pure VHDL, no other tools orsilicon vendor macros. Pipeline delay can be selected from combinatorialto 10 stages at compile time via a generic.Phase input and sin/cos output widths are automatically determined by theconnected bus. 16 bit phase/18 bit amplitude runs at 230 MHz in Spartan6-3without any optimization efforts. (Just setting 250 MHz as the goal)Also features a programmable pipeline register entity for most basic VHDL types.Pipeline delay can be set from 0 to MAXINT clocksAlso a </div>
                    <a href='cores/arithmetic_core/sineandcosinetable/index.html'>sineandcosinetable</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_sineandcosinetable'>code</a>
                </td>
                <td>Feb 26, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Design done,Specification doneWishBone Compliant: NoLicense:Before You ReadThis is a brief overview of the article aboutsingle-clockunsigned integer division algorithm. For comparison and estimation of proposed algorithms please refer to the full article...OverviewNow two division algorithms are wide spread in computing: restoring and non-restoring algorithms. They consider that both algorithms may be used in sequential calculation scheme, when one digit of the result is achieved during one clock. However there are no principle objections against getting all digits of the quotient and the rema</div>
                    <a href='cores/arithmetic_core/single_clock_unsigned_division_algorithm/index.html'>single clock unsigned division algorithm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_single_clock_unsigned_division_algorithm'>code</a>
                </td>
                <td>Sep 28, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core hBone Compliant: NoLicense: LGPLDescriptionThe DLX processor is an academic processor described in in John L. Hennessy and David A. Patterson's Computer Architecture: A Quantitative Approach. Our project aims to offer a decent structural VHDL description of the processor. Moreover, advanced computer architecture features, power management, debug unit, memory management unit and OCP will be added to the project. The final goal of the project is to provide a multi-processor system-on-chip which can support VLSI research or simple embedded application.</div>
                    <a href='cores/arithmetic_core/superscalar_version_of_dlx/index.html'>superscalar version of dlx</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_superscalar_version_of_dlx'>code</a>
                </td>
                <td>Oct 31, 2012</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core mpliant: NoLicense: LGPLDescriptionA custom instruction for approximation of the hyperbolic tangent function tanh(x) with a max. error of 0.1</div>
                    <a href='cores/arithmetic_core/tanh_approximation_custom_instruction_for_nios_ii/index.html'>tanh approximation custom instruction for nios ii</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_tanh_approximation_custom_instruction_for_nios_ii'>code</a>
                </td>
                <td>Mar 21, 2011</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core e,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe Tate Bilinear Pairing core is specially designed for running Tate bilinear pairing algorithm for hyperelliptic curve $y^2=x^3-x+1$ defined over $GF(3^m)$, where $m=97$ and $GF(3^m)$ is defined by $x^97+x^12+2$.Generally speaking, The Tate bilinear pairing algorithm is a transformation that takes two points on an elliptic curve and outputs a nonzero element in the extension field $GF(3^{6m})$. Details of the algorithm is in the document.The core is written in Verilog 2001, and it is carefully optimized for FPGA. F</div>
                    <a href='cores/arithmetic_core/tate_bilinear_pairing/index.html'>tate bilinear pairing</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_tate_bilinear_pairing'>code</a>
                </td>
                <td>Apr 18, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ovenWishBone Compliant: NoLicense: OthersDescriptionThis IP core provides resource efficient ternary adders, i.e., adders with three inputs performing s = x + y + z, for the Altera and Xilinx platforms.Resource efficient means that they need exactly the same resources on modern FPGAs as two-input adders, but are slightly slower.A complete description can be found in the ternary adder documentation:http://opencores.org/usercontent,doc,1365162582Note that the used method for the Xilinx ternary is patented (US patent no 7,274,211). Hence, only private, research or non-commercial use is allowed wi</div>
                    <a href='cores/arithmetic_core/ternary_3-input_adder/index.html'>ternary 3-input adder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_ternary_3-input_adder'>code</a>
                </td>
                <td>Jan 14, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core nal info:Design done,Specification doneWishBone Compliant: NoLicense: OthersDescriptionTiny Tate Bilinear Pairing core is for calculating Tate bilinear pairing.In fact it is a special type of Tate bilinear pairing called reduced $\eta_T$ pairing.Its features are:* super-singular elliptic curve E:y^2=x^3-x+1* the field is the Galois field GF(3^m),m=97 or 593* the irreducible polynomial is x^97+x^12+2 or x^593+x^112+2* the group size is 151 bits or 911 bits* vendor independent code* very low hardware cost (&permil;0.2 US dollar) if m=97* released under Apache License v2.0Document &amp; Specifica</div>
                    <a href='cores/arithmetic_core/tiny_tate_bilinear_pairing/index.html'>tiny tate bilinear pairing</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_tiny_tate_bilinear_pairing'>code</a>
                </td>
                <td>Oct 13, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core phaAdditional info:ASIC proven,Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThis core takes unsigned value as degrees(input) and gives the corresponding value in IEEE-754 double (output).This core can be easily configured degrees(inputs) bit width can be changed to any number of bits.It only takes 10 clock cycles to complete one operation.</div>
                    <a href='cores/arithmetic_core/trigonometric_functions_degrees_in_double_fpu/index.html'>trigonometric functions degrees in double fpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_trigonometric_functions_degrees_in_double_fpu'>code</a>
                </td>
                <td>Jul 3, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core WishBone Compliant: NoLicense: GPL</div>
                    <a href='cores/arithmetic_core/true_matrix_3x3_multiplier/index.html'>true matrix 3x3 multiplier</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_true_matrix_3x3_multiplier'>code</a>
                </td>
                <td>Feb 26, 2007</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core iant: NoLicense: OthersDescriptionkvcordic is a collection of files comprising an implementation of a universal CORDIC algorithm (rotation/vectoring direction, circular/linear/hyperbolic mode) high-level synthesis benchmark by Nikolaos Kavvadias.The design is a universal CORDIC IP core supporting all directions (ROTATION, VECTORING) and modes (CIRCULAR, LINEAR, HYPERBOLIC). The I/O interface is similar to e.g. the CORDIC IP generated by Xilinx Core Generator). It provides three data inputs (xin,yin, zin) and three data outputs (xout,yout, zout) as well as the direction and mode control inputs.</div>
                    <a href='cores/arithmetic_core/universal_multi-function_cordic/index.html'>universal multi-function cordic</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_universal_multi-function_cordic'>code</a>
                </td>
                <td>Mar 8, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core mpliant: NoLicense:DescriptionThe serial_divide_uu is a Verilog coded module that performs binary division.  It is fully parameterized, and works in a serial fashion.  The number of clock cycles required to complete a divide operation is equal to the number of bits in the quotient plus one.This module has been tested and debugged in actual hardware on a Xilinx XC2S200E FPGA.  It was used to divide pulse width by period in a pulse-width-modulation measurement application (ADXL202E 2-axis MEMS accelerometers.)The widths of the signals are configurable by parameters, as follows:M_PP = Bit width o</div>
                    <a href='cores/arithmetic_core/unsigned_serial_divider/index.html'>unsigned serial divider</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_unsigned_serial_divider'>code</a>
                </td>
                <td>Mar 10, 2013</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionA versatile counter that can be defined as a binary, gray or LFSR counter. Usage include baudrate generator, address generator for FIFO and much more.As a user you edit a define file to make the counter fit your project demands. You the generate a tailored counter. The performance and area can hereby be optimezed for the given applicationPros and cons with different types of counterLFSRextremely low area usagehigh performanceone cycle shorter count cycle compared to binary versionstypically used for interva</div>
                    <a href='cores/arithmetic_core/versatile_counter/index.html'>versatile counter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_versatile_counter'>code</a>
                </td>
                <td>Jul 14, 2010</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ne Compliant: NoLicense: GPLFeatures- direct traceback option.- self test automation- support any popular convolution code.- throughput and area of decoder are scalable.- in place state metric storage.- parameterized modules.- something else.Status- Place a VHDL/Verilog version for K=7 rate=1/2 Poly=(91,121 in decimal) TracebackDepth=64 decoder for DownloadIt's a zip file, rename to .zipor look up the http://viterbi-gen.sourceforge.net example section.- Version 1.3- Place a TD-SCDMA version of K=9 rate=1/2 decoder fordownload.- Place a VHDL version of K=9 rate=1/2 decoder fordownload, in the r</div>
                    <a href='cores/arithmetic_core/viterbi_hdl_code_generator/index.html'>viterbi hdl code generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_viterbi_hdl_code_generator'>code</a>
                </td>
                <td>Mar 25, 2015</td>
                <td>Other</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core nal info:Design done,Specification doneWishBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/arithmetic_core/viterbi_tx_rx/index.html'>viterbi_tx_rx</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_viterbi_tx_rx'>code</a>
                </td>
                <td>Feb 23, 2012</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core on doneWishBone Compliant: YesLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/wishbone_protocol_to_axi4_protocol/index.html'>wishbone protocol to axi4 protocol</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_wishbone_protocol_to_axi4_protocol'>code</a>
                </td>
                <td>Mar 31, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core fo:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/arithmetic_core/xilinx_virtex_floating_point/index.html'>xilinx virtex floating point</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_xilinx_virtex_floating_point'>code</a>
                </td>
                <td>Sep 19, 2013</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>arithmetic core ication doneWishBone Compliant: NoLicense: LGPLDescriptionCORDIC is the acronym for COordinate Rotation DIgital Computer and allows a hardware efficient calculation of various functions like - atan, sin, cos - atanh, sinh, cosh, - division, multiplication.Hardware efficient means, that only shifting, additions and substractions in combination with table-lookup is required. This makes it suitable for a realization in digital hardware. Good introductions can be found in [1][2][3][4].The following six CORDIC modes are supported:- trigonometric rotation- trigonometric vectoring- linear rotat</div>
                    <a href='cores/arithmetic_core/yac-yet_another_cordic_core/index.html'>yac-yet another cordic core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/arithmetic_core_yac-yet_another_cordic_core'>code</a>
                </td>
                <td>Mar 30, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>PROTOTYPE BOARD</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board e Compliant: NoLicense: GPLDescriptionThis is a small board with the low-cost ACEX FPGA with some SRAM and Flash. It is designed as a module for soft-core CPU development. I've used this board as basis for JOP - the Java processor. JOP still fits into the ACEX 1K50.See some pictures of the board at:http://www.jopdesign.com/board.jspThe schematic and the PCB layout is provided under GPL.Features- Altera ACEX 1K50TC144-3 FPGA- Voltage regulators (3V3, 2V5)- Crystal clock (20 MHz)- 512KB Flash (for FPGA configuration and program)- 128KB Ram- Byteblaster port- Watchdog with LED- EPM7032 PLD to loa</div>
                    <a href='cores/prototype_board/acex_1k50_board/index.html'>acex 1k50 board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_acex_1k50_board'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board iant: NoLicense: LGPLDescriptionTarget of this project is development FPGA and/or FPGA powered real time audio DSP applications. This is Free (like freedom) Hardware project, a PCI card with stand-alone possibility, with high-end digital and analog audio interfaces and MIDI.Possible target development areas will be:- Audio effects and delays- Equalizers (or digital audio filters of any type)- Acoustics correction- Digital crossovers (for loudspeaker systems)- Voice recognition- Synthesizers/samplers- Sample rate converters- Jitter attenuation- Mixing- Studio mastering</div>
                    <a href='cores/prototype_board/audio_dsp_pci_card/index.html'>audio dsp pci card</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_audio_dsp_pci_card'>code</a>
                </td>
                <td>May 8, 2006</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board one Compliant: NoLicense: OthersDescriptionTheButterfly Lightis an open source, modular FPGA development board. It is comprised of theUSB Cocoonand theSpartan 3E Cocoonwhich paired together create the Butterfly Light FPGA development board. The Butterfly Light is best suited for developers who prefer to create their own daughterboards instead of utilizing the "Wing" peripheral system. The Butterfly Light exposes the maximum amount of I/O of all available Butterflies. It is also well suited for use with theLogic Analyzersoftware which implements a 100Mhz, 32 channelLogic Analyzer.EAGLE design f</div>
                    <a href='cores/prototype_board/butterfly_light/index.html'>butterfly light</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_butterfly_light'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board o:WishBone Compliant: YesLicense: LGPLDescriptionThis project uses two off the shelf boards and interfaces them. The processor board used is a Olimex LPC-L2294 and the FPGA board is a Terasic DE1. A Olimex ARM-USB-OCD was used to load and debug the code. The boards were cabled together with floppy and hard drive cables. The entire setup cost less than $350.The bridge from the wb_async_mem_bridge project is used to interface the External Memory Controller to the Wishbone bus on the FPGA. Currently the SRAM, GPIOs &amp; HEX LED display is connected and there are plans to add the other interfaces</div>
                    <a href='cores/prototype_board/de1_olpcl2294_system/index.html'>de1_olpcl2294_system</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_de1_olpcl2294_system'>code</a>
                </td>
                <td>Apr 6, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board Compliant: NoLicense: LGPLDescriptionA FPGA development board based on EP2C35F672, with SDRAM and flash .</div>
                    <a href='cores/prototype_board/ep2c35_board/index.html'>ep2c35 board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_ep2c35_board'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board  Compliant: NoLicense:DescriptionEUS FS is an "open" system board designed for industrial control and data acquisition applications. It is equipped with a 32-bit CPU working @ 200MHz (Etrax FS), Xilinx's gate array (Spartan 3E) and support electronics. A BSP package contains Linux operating system version 2.6, driver for communication with FPGA and peripheral devices. Example FPGA cores are available in source form, along with full board documentation and schematics.Features List- Board dimensions 85 x 55 mm (3.35 x 2.175" )- 200MHz, 32bit Etrax FS processor- Up to 256MB SDRAM- 8 - 64 MB Flash</div>
                    <a href='cores/prototype_board/eus_fs-alice_ii-embeddable_single_board_computer/index.html'>eus fs-alice ii-embeddable single board computer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_eus_fs-alice_ii-embeddable_single_board_computer'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board doneWishBone Compliant: NoLicense: GPLShort DescriptionMinMax game tree search with alpha-beta pruning implemented in FPGA.Rules and heuristics implemented for Reversi/Othello game. The system is capable of analyzing ~5M game states/second @50MHz. (no selective search).RTL design Verilog 2001 compliant.VGA output, pushbuttons input (for playing), using Spartan3E Starter Kit board.General FeaturesTransition from a current game state to another is done in 1cc.Determining all possible transitions from a game state to another is also done in 1cc.Evaluation of one game state is done in 1cc.The heur</div>
                    <a href='cores/prototype_board/game-trees_fpga_implementation_othello_game/index.html'>game-trees fpga implementation othello game</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_game-trees_fpga_implementation_othello_game'>code</a>
                </td>
                <td>Dec 6, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board iant: NoLicense: LGPLDescriptionHighlights- Power Supply* 3.3 Volt - DC/DC-buck MAX1626* 2.5V LM1117-ADJ* 1.2V LM1117-ADJ- FPGA* Xilinx Spartan3E XS3S250E or XC3S500E -PQG208-Flash* Atmel AT45DB041D - 4Mb SPI Data Flash memory- USB* FT245RL - USB interface - Full Speed- Misc* 4x LED* 2x 7 segment LED* 4x SwDip switch* 2x Button* 2x IDC-2x20 header GPIO* Xilinx JTAG header* Xilinx SPI header* Oscillator - 50MHz</div>
                    <a href='cores/prototype_board/griva_basic_board/index.html'>griva basic board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_griva_basic_board'>code</a>
                </td>
                <td>Feb 26, 2011</td>
                <td>Other</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board : NoLicense: BSDNorwegian University of Science and TechnologyThis project came to be because of the course "TDT4295 - Computer Design, Project", due to theInstitute of Computer and Information ScienceatThe Norwegian University of Science and Technology. The project was supervised by Assoc. Prof.Morten HartmannWhat is this?IGOR is in a complete system including:* A PCB with all the components of the system: FPGA, AVR microcontroller, IO-units, Memory... the works.* An implemented processor running on the FPGA.* Several IO units, connected to the main processor through an AVR mircrocontroller t</div>
                    <a href='cores/prototype_board/igor-a_microprogrammed_lisp_machine/index.html'>igor-a microprogrammed lisp machine</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_igor-a_microprogrammed_lisp_machine'>code</a>
                </td>
                <td>Jan 6, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board liant: NoLicense: GPLDescriptionThe IIE-PCI Development Platform board is a low cost PCI device card with a programmable logic chip (Altera ACEX), dynamic ram, and expansion capabilities.The main purpose of the IIE-PCI board is to test PCI designs in a educational environment. Cost was a primary concern. The fabrication cost for the prototype board was U$S 330, if 10 boards are made, the cost will drop to U$S 230 per unit.More information is available at the project website:-http://www.mondueri.com/iiepci(mondueri.com/iiepci) (original site in spanish)-http://translate.google.com/translate?u=h</div>
                    <a href='cores/prototype_board/iie-pci_board/index.html'>iie-pci board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_iie-pci_board'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board : YesLicense:DescriptionThe internal Logic state Analyser (LA) is a simplified version of a standard logic state analyzer, however it is build-in the prototyped circuit and therefore allows for probing internal signals. The LA at first writes probed signals into its internal memory, and then allows for off-line transfer through WISHBONE bus to a PC where the probed data can be watched. As during design prototyping watched signals are very often changed, the LA is mainly intended for FPGAs and works similarly to Xilinx ChipScope.FeaturesInternal memory for on-line data probing and off-line prob</div>
                    <a href='cores/prototype_board/internal_logic_state_analyzer/index.html'>internal logic state analyzer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_internal_logic_state_analyzer'>code</a>
                </td>
                <td>Dec 11, 2002</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board done,FPGA proven,Specification doneWishBone Compliant: YesLicense:Description[Keep It Simple,Stupid] Board.The board was evaluated like [or1k/orp project].BOARD consists of two pieces. One is FPGA board. Another is MOTHER board.The device on the FPGA board is ANY(xilinx or altera ...).Only connected specification of the board is important.Board snapshotsMOTHER boardFPGA boardStatusAssemblyIt's planning(more cheap!)EvaluationIt's finished(commit code,RTL8019AS Evaluation is done)SimulationIt's finished(commit code,checkout-test is done)DesignIt's finished(commit code,checkout-test is</div>
                    <a href='cores/prototype_board/kiss-board/index.html'>kiss-board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_kiss-board'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board nt: NoLicense:DescriptionEUS 100LX is an "open" system board conforming to the PC104 format (90,2mm x 95,9mm) designed for industrial control and data acquisition applications. It is equipped with CPU, gate array and support electronics and comes with Linux operating system version 2.4 or 2.6, driver for communication with FPGA and peripheral devices, Allegro graphics library. Example FPGA cores are available in source form, as well as full board documentation - schematics, layout (available athttp://www.dspfpga.com/?page=eus_100lx).Features- ETRAX 100LX / MCM4+16 CPU- 32 MB SDRAM, 8 - 64 MB F</div>
                    <a href='cores/prototype_board/linux_and_xilinx_fpga_dev_board/index.html'>linux and xilinx fpga dev board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_linux_and_xilinx_fpga_dev_board'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board :WishBone Compliant: NoLicense: LGPLPlanned Features- LPC ROM(RAM?)- Flash regions Memory read, Firmware hub read, (IO read and write)- PSRAM regions Memory read and write, Firmware hub read, (IO read and write)- SPI ROM- Flash regions read- PSRAM regions read- 8 bit ROM- read (with standard CS, OE, WE, DATA, ADDR interface on the 32 extension pins)- Post code trace- Boot trace (list all memory cycles possible at least on LPC)- Simple Logic Analyzer with 32 pins and 32 pin GPIO python module support- VHDL Firmware update trough USB data cableIMAGE: Dongle_II_board_small.JPGFILE: Dongle_II_boar</div>
                    <a href='cores/prototype_board/lpc_rom_spi_rom_8bit_rom_emulator_on_artec_dongle_/index.html'>lpc rom spi rom 8bit rom emulator on artec dongle </a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_lpc_rom_spi_rom_8bit_rom_emulator_on_artec_dongle_'>code</a>
                </td>
                <td>Mar 5, 2012</td>
                <td>Other</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board n doneWishBone Compliant: NoLicense:DescriptionThe MAXII-Evalboard is a small and simple board for learning VHDL und testing the own VHDL-codes on a real CPLD-hardware.For the first steps the beginner has 4 switches and a 2 digit LED-display to create and test simple functions.Later the advancer can realize a small graphical display with 10x7 LED-pixel with a time multiplex control and a communication link via a USB-UART-Connection to a PC.To expand the MAXII-Evalboard with a additionally hardware all pins of the CPLD are routed to pin contact strip.The MAXII-Evalboard based on the Altera EPM5</div>
                    <a href='cores/prototype_board/maxii-evalboard/index.html'>maxii-evalboard</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_maxii-evalboard'>code</a>
                </td>
                <td>Jun 26, 2005</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board  NoLicense:DescriptionMicro FPGA board is a stand alone, low cost, do-it-yourself board. All components are possible to get from a local electronics shop (with possible exception of Virtex part). Board includes one Xilinx Virtex XCV100 chip.FPGA is loaded from PC via Xilinx XChecker cable and external power supply must be provided. It is designed for debugging and verification process of small units or cores. See a block diagram for details.Status- board is finished and it is fully functionalShematic sourcesSchematic as Adobe PDF documentSchematic in Protel Binary formatLibrary in Protel Binar</div>
                    <a href='cores/prototype_board/micro_fpga_board/index.html'>micro fpga board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_micro_fpga_board'>code</a>
                </td>
                <td>Mar 10, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board : NoLicense:Specifications- small form factor (1dm2)- inexpensive surface mount technology (no Ball Grid Array (BGA) chips)- fast 50k gates or bigger FPGA- basic I/O capabilities like RS232 and IRDA- FLASH memory for FPGA configuration and microprocessor code- fast SDRAM for main memory- direct access to important signals through Logic Analyzer connectorsDescriptionOpenCores Reference Platform 1 (OCRP-1) standalone board was designed as a common prototype platform for testing our IP cores. It has a central FPGA for evaluating and testing IP cores, I/O capabilities, DRAM and FLASH memory. It al</div>
                    <a href='cores/prototype_board/ocrp-1_board/index.html'>ocrp-1 board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_ocrp-1_board'>code</a>
                </td>
                <td>Jan 22, 2004</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board t: NoLicense:DescriptionOpenCores Reference Platform 2 (OCRP-2) is full-size length add-in PCI board. It includes two FPGA chips, video D/A and A/D converters, SDRAM memory, FLASH memory, PLD chip, USB, EIA232 and Ethernet PHY chips. It is designed for a debugging and verification process for several of our cores. See a block diagram for details.One special function of this board is to provide a method for a remote test of cores. The board will be used via web based interface. It will be possible to download design to the board and use a JAVA based logic analyzer and signal generator to debug </div>
                    <a href='cores/prototype_board/ocrp-2_board/index.html'>ocrp-2 board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_ocrp-2_board'>code</a>
                </td>
                <td>Oct 15, 2001</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board iant: NoLicense: OthersDescriptionOMRP (Openpattern Modular Routing Platform) is the first product-oriented project of the OpenPattern company. The target is to create a new open hardware FPGA-based network router that can be used for mesh wifi networks, as an alternative of ISPs home-gateway, and as a development platform for future open-hardware SoC projects.Features- Open hardware - schematics and HDL sources will be/are released.- Flexible - implement whatever hardware acceleration or protocol you want in the FPGA.- Modular - many standard extension ports are implemented.- Unbrickable - ev</div>
                    <a href='cores/prototype_board/omrp_prototype_board_v2/index.html'>omrp prototype board v2</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_omrp_prototype_board_v2'>code</a>
                </td>
                <td>Jul 1, 2010</td>
                <td>Other</td>
                <td>Alpha</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board t: NoLicense:IntroductionAll electronics designers, students and researchers are always trying to test their ideas and check its performance before punishing it. Several kinds of test prototype boards are used for this purpose. Usually these boards are either very expensive and has either more or less features than what the designer need. For this reason the idea of designing a simple and open design board is going to be available for anyone for almost nothing and he/she can customize it for his/her specific needs. The design of this board is intended to be an open design and to use free and o</div>
                    <a href='cores/prototype_board/open_design_prototype_board/index.html'>open design prototype board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_open_design_prototype_board'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board : NoLicense:IntroductionAs you know, we have lots of free IP cores here, and we&euro;&trade;ll have more coming soon. We have to use these cores otherwise they are invaluable. For this reason the idea of designing serials and open design boards are going to be available for any designers around the world.ObjectiveThis project is intended to:- To design schematic can deal with analog signal and transport through Ethernet.- To implementation CPU core and Ethernet core to one FPGA chip- To program the necessary operation system and application software to achieve the goal.- To build the prototype</div>
                    <a href='cores/prototype_board/opencores_application_board_1_oab1/index.html'>opencores application board 1 oab1</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_opencores_application_board_1_oab1'>code</a>
                </td>
                <td>Oct 15, 2001</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board  Compliant: NoLicense:DescriptionOpensource OpenRisc Development Board. All CADsoft Eagle design files available to recreate the board using EagleLite, a freeware PCB design tool. Uses the largest Cyclone 2 device available in a QFP package, thus allowing larger RTL designs to be ported, and at the same time allowing easier PCB design and board assembly. Board design is double sided, and can be manufactured using low cost batch PCB services. But despite only being double layer, it has an almost continuous bottom side ground plane.A complete system consists of two separate boards;- Main FPG</div>
                    <a href='cores/prototype_board/openrisc_development_board/index.html'>openrisc development board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_openrisc_development_board'>code</a>
                </td>
                <td>Dec 29, 2008</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board Bone Compliant: NoLicense: GPLA small versatile pci  board, using Spartan-II at 200k gates.The v1.0 of board is builded, tested with opencores pci core, its state is functional.Featuresv 1.0 feautures:- PCI interface fully working with opencore pci project.- I/O pins routed externaly to an external connector- JTAG header, and small xilinx eeprom for holding the configuration.- Jumper select local eeprom or external download or debug.- Project aviable in gerber for manufacturing.- .ucf aviable specificaly for use with ISE.- Schematic aviable in pdf for description of the board.v 2.0b feautures </div>
                    <a href='cores/prototype_board/pci_board/index.html'>pci board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_pci_board'>code</a>
                </td>
                <td>Dec 20, 2005</td>
                <td>Unknow</td>
                <td>Mature</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board nal info:Design done,Specification doneWishBone Compliant: NoLicense: LGPLinside pcjavascript:alert('');top viewjavascript:alert('');bottom viewjavascript:alert('');control_paneljavascript:alert('');interruptsjavascript:alert('');testingjavascript:alert('');pcb samplesjavascript:alert('');part listVarious:5V input	SMT jack 3.5mm (Ebay)PROG	10pin 2.54mm JTAG header (2.5V)D1,D2,D3	0805 led (marking cathode side)IO 20pins 	20pins 2.54 double row male headerTX/RX		PLT133_T6A/PLR135_T10 everlightOSC50Mhz	ABRACON_3V3_ASV_SERIE 50Mhz (mouser ASV-50.000MHZ-EJ-T)L1,L2,L3	3.3uH 1.1A inductors 0806 size </div>
                    <a href='cores/prototype_board/pci_card_with_xilinx_x3cs500e/index.html'>pci card with xilinx x3cs500e</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_pci_card_with_xilinx_x3cs500e'>code</a>
                </td>
                <td>Jan 10, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board venWishBone Compliant: YesLicense: GPLAn inexpensive PCI FPGA development boardThis is a port of the Opencores PCI core ported to the Enterpoint Raggedstone1 PCI card.This is a very inexpensive card: (~$100 USB). You can order one from Enterpoint:http://enterpoint.co.uk/moelbryn/raggedstone1.htmlA PCI based FPGA card-Inexpensive-PCI core works-All the code is in CVS-Uses the OC PCI coreVersion is in cvsTo check this project out of cvs:cvs -d:pserver:anonymous@cvs.opencores.org:/cvsroot/anonymous checkout raggedstone</div>
                    <a href='cores/prototype_board/raggedstone_pci_spartan-3_board/index.html'>raggedstone pci spartan-3 board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_raggedstone_pci_spartan-3_board'>code</a>
                </td>
                <td>Feb 8, 2007</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board mpliant: NoLicense: LGPLDescriptionHere i present a board with PCB and schematic included .the board include :-Spartan 6 FPGA (XC6SLX9)-PIC32MZ2048 processor (High range processor from Microchip , 200Mhz MIPS core)-high speed USB (device)-Ethernet 100Mb/s with LAN8720 transceiver chip-I/O header to FPGA pins :  18x 5.0V output (buffered with 74HCT04) and 20x 3.3V Input/output (no buffered)the connection between CPU and FPGA include complete EBI (Enhanced bus interface) bus , which permit CPU to read/write FPGA registers (just like a coprocessor arrangment).The board have been completely tested</div>
                    <a href='cores/prototype_board/spartan_6_+_pic32_+_usb_+_ethernet/index.html'>spartan 6 + pic32 + usb + ethernet</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_spartan_6_+_pic32_+_usb_+_ethernet'>code</a>
                </td>
                <td>Apr 14, 2015</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>prototype board GA provenWishBone Compliant: YesLicense: GPLDescriptionBoilerplate Verilog for use in Technologic Systems TS-7300 FPGA computer athttp://www.embeddedARM.com/epc/ts7300-spec-h.htmImplements bus cycle demultiplexing to an internal 16 and 32 bit WISHBONE bus and 10/100 ethernet interface.   Provided as a ready-to-compile Altera Quartus II project complete with pinlocks, compiler assignments, PLL setting, and timing constraints.  A simple stub module implements a 32 bit register in the address space of the 200Mhz ARM9 CPU that toggles onboard LEDs as an easily extendable example of creating a WISH</div>
                    <a href='cores/prototype_board/technologic_systems_ts-7300_fpga_computer/index.html'>technologic systems ts-7300 fpga computer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/prototype_board_technologic_systems_ts-7300_fpga_computer'>code</a>
                </td>
                <td>Aug 16, 2008</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <td>
                    <b>COMMUNICATION CONTROLLER</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller al info:WishBone Compliant: NoLicense: LGPLDescriptionEthernet MAC Layer Switch.The switch receive 100 MB/s data rate from 6channels and direct each frame received to its destination port.The switch is designed with :1. Simultaneously Read / Write frames memory - to improve latency2. Digital serialize / De - Serialize and digital routing coreThe Simulation include testbench of 6 Network Adapters (NIC Hosts)transmitting 100 MB/s data to the switch.NiC hosts are teken from the eth ip core projects as benchmarks( may be modified).</div>
                    <a href='cores/communication_controller/100_mb-s_ethernet_mac_layer_switch/index.html'>100 mb/s ethernet mac layer switch</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_100_mb-s_ethernet_mac_layer_switch'>code</a>
                </td>
                <td>May 25, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: NoLicense:DescriptionThe 10G ethernet mac core. It is compliant with ieee 802.3ae. Our plan is:1. reading specification2. observation of different companies 10g ethernet mac core specifcation /data sheets3. identify the difference between 10/100/1000/1g ethernet mac cores.4. make the specification5. make the architecure document6. make the design document7. RTL coding and verication8. validating it on fpgaMain datapath logic is being tested on fpga now. Latest codes will be check in soon.Features- It is compliant with ieee 802.3ae- 10GBASE-RStatus- Planning- Reading specifi</div>
                    <a href='cores/communication_controller/10g_ethernet_mac/index.html'>10g ethernet mac</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_10g_ethernet_mac'>code</a>
                </td>
                <td>Sep 23, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nal info:Design done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionmail group is added to track all the Q&amp;A from the author.If you have any question about the design, please send your question to mail group. The answer will be recorded as reference for other people.Homepage:http://groups.google.com/group/opencores-tri-mode-eth-macGroup email:   opencores-tri-mode-eth-mac@googlegroups.com10_100_1000 Mbps tri-mode ethernet MAC implements a MAC controller conforming to IEEE 802.3 specification. It is designed using less than 2000 LCs/LEs to implement full function. It will use infe</div>
                    <a href='cores/communication_controller/10_100_1000_mbps_tri-mode_ethernet_mac/index.html'>10_100_1000 mbps tri-mode ethernet mac</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_10_100_1000_mbps_tri-mode_ethernet_mac'>code</a>
                </td>
                <td>Jan 19, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :Design done,FPGA provenWishBone Compliant: NoLicense: BSDDescriptionImplements UDP, IPv4, ARP protocolsZero latency between UDP and MAC layer (combinatorial transfer during user data phase)Allows full control of UDP src &amp; dst ports on TX.Provides access to UDP src &amp; dst ports on RX (user filtering)Couples directly to Xilinx Tri-Mode eth Mac via AXI interfacechoice of ARPV2 layer with multislot cache, or smaller single slot ARP for point to point implementationsSeparate building blocks to create custom stacksEasy to tap into the IP layer directlySeparate clock domains for tx &amp; rx p</div>
                    <a href='cores/communication_controller/1g_eth_udp-ip_stack/index.html'>1g eth udp/ip stack</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_1g_eth_udp-ip_stack'>code</a>
                </td>
                <td>Jun 14, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller fo:WishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/1g_ethernet_arp/index.html'>1g ethernet arp</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_1g_ethernet_arp'>code</a>
                </td>
                <td>Oct 9, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :Design doneWishBone Compliant: NoLicense: GPLDescriptionThis project, written in generic synthesizable VHDL, provides two separate cores for encoding and decoding byte data according to the 8b/10b protocol. 8b/10b is widely used in high speed serial communication standards that need a run-length limited, DC balanced data stream for reliable data transmission and clock recovery. The encoder accepts a parallel 8-bit raw input and generates a parallel 10-bit encoded value based on the data along with a running disparity value. The decoder does the reverse, providing a decoded 8-bit value from th</div>
                    <a href='cores/communication_controller/8b10b_encoder-decoder/index.html'>8b10b encoder/decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_8b10b_encoder-decoder'>code</a>
                </td>
                <td>May 9, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller info:Design doneWishBone Compliant: NoLicense:DescriptionA UART that is compatible with the industry standard 16550DIncludes wrappers for the Wishbone and AMBA APB bussesFeaturesUses parts from the project (3.17 or later)Sticky parity is not supportedFIFO's are always enabledStatusDesign is finished18 Jun 2007P. Azkarate's addition of range for integers in Rx, Tx modulesthis helps when using the Altera tools12 July 2007fix a couple problems found by Matthias Klemm with 5, 6, and 7 bit transfers14 July 2007Correct FCR bit 3 information (DMA Mode control)4 Aug 2007fix some TOI problems18 Aug 200</div>
                    <a href='cores/communication_controller/vhdl_16550_uart_core/index.html'>vhdl 16550 uart core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_vhdl_16550_uart_core'>code</a>
                </td>
                <td>Dec 8, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller onal info:Design doneWishBone Compliant: NoLicense:DescriptionA (as far as I know) untested VHDL translation of the Verilog Can protocol ControllerTo Download, click at the "Downloads" button upper right part of this pageThis project is a translation Igor Mohor's Veriloghttp://opencores.org/project,can,overview(CAN Protocol Controller)FeaturesThe modules have "_vhdl_" added to their names, to ease compare simulation with Verilog version (for those with mixed a language simulator)Statususe at own risk - have no had time to test/simulatecheck the Philips SJA1000 data sheet and thehttp://opencore</div>
                    <a href='cores/communication_controller/vhdl_can_protocol_controller/index.html'>vhdl can protocol controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_vhdl_can_protocol_controller'>code</a>
                </td>
                <td>Oct 31, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :StableAdditional info:FPGA provenWishBone Compliant: NoLicense:DescriptionThis is a feed forward receiver for an ADAT lightpipe optical datastream. This type of multichannel audio connection is widely used in professional digital recording studios. It consists of eight 24 bit wide audio words, at a sample rate (wordclock) of 32kHz, 44,1kHz or 48kHz. It can double the sample rate at the cost of half the number of channels, this is called S-MUX (not supported yet). There are 4 user bits to carry extra data (MIDI, S-MUX indicator, timecode and spare). ADAT streams are encoded with NRZI coding, m</div>
                    <a href='cores/communication_controller/adat_receiver/index.html'>adat receiver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_adat_receiver'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ishBone Compliant: NoLicense:Status- Everything was tested and is believed to be bug-free, but no warranties.DescriptionVHDL implementation of the AMI --- Alternate Mark Inversion --- and HDB1 --- High Density Bipolar of order 1 line codes.For other line code refer to:http://www.opencores.org/projects/hdbnFeatures- AMI- encoder- decoder- simulation files for both encoder and decoder- HDB1- encoder- decoder- simulation files for both encoder and decoder</div>
                    <a href='cores/communication_controller/ami-hdb1_line_codes/index.html'>ami/hdb1 line codes</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ami-hdb1_line_codes'>code</a>
                </td>
                <td>Nov 25, 2007</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller hBone Compliant: NoLicense: LGPLDescriptionThe aim of this IP is to provide those who use it the possibility and reading and writing in an external interface for analog devices. Porting APB ARM, offering the possibility of integration with ARM processor in general.</div>
                    <a href='cores/communication_controller/apb_to_i2c/index.html'>apb to i2c</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_apb_to_i2c'>code</a>
                </td>
                <td>Dec 15, 2014</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ngAdditional info:WishBone Compliant: NoLicense: LGPLDescriptionUsually, 8b/10b codec is required with using a fibre-optic SERDES interface.A SERDES converts fast serial optic-stream into less fast 10bit parallel electric-signals.Even though less fast electric-signals, that has almost or more 100Mhz speed.so the FPGA logic processing 8b/10b must have capable to terminate processing encode and decode with minimal delay.This project provide you the VHDL code, processing 8b/10b enc/dec asynchronously.It is implemented by a large lookup-table for better performance.a lookup-table implementation ca</div>
                    <a href='cores/communication_controller/async_8b-10b_enc-dec/index.html'>async 8b/10b enc/dec</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_async_8b-10b_enc-dec'>code</a>
                </td>
                <td>Dec 1, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ne Compliant: NoLicense:DescriptionThis module scans an incoming stream of rs232 serial characters.  It constantly looks for a new character, which it detects by seeing the "start" bit.  When a condition resembling a start bit is detected, the module then begins a measurement window, to try and determine the BAUD rate of the incoming character.  Since many different characters have different bit transitions because of their different data content, this module actually only "targets" a single character -- in this case the "carriage return" character (0x0d).  How can it tell if the character is </div>
                    <a href='cores/communication_controller/automatic_baud_rate_generator/index.html'>automatic baud rate generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_automatic_baud_rate_generator'>code</a>
                </td>
                <td>Mar 11, 2013</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller  provenWishBone Compliant: NoLicense: GPLDescriptionEver needed a pulse at a given frequency ( period ).Well that is what BaudGen gives you.By the use of parameters, you specify the frequency of the clock you wish to divide, the period ( baud rate ) you wish out, and optionally, how fast you want an over sample output.BaudGen works out the required count values, and outputs one clock wide pulses at the required rate.</div>
                    <a href='cores/communication_controller/baud_generator/index.html'>baud generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_baud_generator'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller shBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/bitwise_addressable_gpio/index.html'>bitwise addressable gpio</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_bitwise_addressable_gpio'>code</a>
                </td>
                <td>Jan 23, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller e Compliant: YesLicense:DescriptionThe Bluetooth is a standard protocol for wireless connection between devices such as cell phones, PDAs, PCs and any other device. The main objective for this standard is to provide a royalty free standard for such wireless protocol.The objective of this project is to build an opensource free bluetooth baseband controller, LMP, HCI and higher layers software stacks.My bluetooth documentation siteStatus- Working on functional and design specifications. Check preliminary Baseband spec and architecture spec in Download section- Defining core architecture- De</div>
                    <a href='cores/communication_controller/bluetooth_baseband_controller/index.html'>bluetooth baseband controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_bluetooth_baseband_controller'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller pliant: YesLicense:DescriptionController Area Network or CAN is a control network protocol fromBosch that has found wide use in Industrial Automation and theAutomotive Industry.Most of the patents of CAN are owned by Bosch and although thereare no restictions on developing an opensource CAN IP but for anycommercial use the protocol license from Bosch is an indispensable prerequisite.Size is approximately 12k gates (930 flip-flops).Block DiagramIMAGE: CAN.gifFILE: CAN.gifDESCRIPTION:Features- Non-Destructive bit-wise arbitration (CSMA/CA)- Message Based Addressing/Filtering- Broadcast Communica</div>
                    <a href='cores/communication_controller/can_protocol_controller/index.html'>can protocol controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_can_protocol_controller'>code</a>
                </td>
                <td>Feb 17, 2015</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nfo:WishBone Compliant: NoLicense: LGPLDescriptionCheap Ethernet interfaceRealization of Ethernet interface and protocols optimized for minimal external components and FPGA resources.FPGA may connecting through transformer or directly to twisted pairs (on your own risk).Features- 10BASE-TX interface (10 MBit/sec) full-duplex (thanks to fpga4fun.com).- Base functional of ARP (reqest, reply), ICMP (reply), UDP protocols (server, client).- Maximum packet size is 1 kb (fragmentation not supported).Required 50MHz/48Mhz and 20MHz clocks, 8kbit block memory, ~800 slices.Tested on Spartan 3E 500 with </div>
                    <a href='cores/communication_controller/cheap_ethernet_interface/index.html'>cheap ethernet interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_cheap_ethernet_interface'>code</a>
                </td>
                <td>Aug 31, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller shBone Compliant: NoLicense: GPLDescriptionDiscrete Multi Tone (DMT) is the modulation scheme used for Asymmetric Digital Subscriber Line (ADSL) systems and one of the modulation schemes used for Very high-speed Digital Subscriber Line (VDSL) systems.Goal of the project is to implement the individual building blocks of a DMT transceiver, following ITU-T recommendation G.992.1 for ADSL systems.Features- Following ITU-T recommendation G.992.1 ADSL- No trellis support- No echo cancellationPhase 1, DMT Modem:- Constellation encoder- Gain- IDFT- Cyclic prefix- TDQ- Cyclic prefix- DFT- Constellation</div>
                    <a href='cores/communication_controller/dmt_transceiver/index.html'>dmt transceiver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_dmt_transceiver'>code</a>
                </td>
                <td>Nov 7, 2011</td>
                <td>Other</td>
                <td>Planning</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller gn done,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionThis core is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.DMX protocol fully implemented in hardwareDMX channels simply mapped in CSR address spaceThru mode enables operation as a traditional DMX receiving deviceMore informationCSR bus specificationsCore documentationDMX512 at Wikipedia</div>
                    <a href='cores/communication_controller/dmx512_transceiver/index.html'>dmx512 transceiver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_dmx512_transceiver'>code</a>
                </td>
                <td>Aug 13, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller provenWishBone Compliant: NoLicense: OthersDescriptionOpen Source Documented Verilog UARTPurposeThis module was created as a result of my own need for a UART (serial line I/O) component and frustration at the difficulty of integrating the existing available components in to my own project. All the open source UART modules I found were difficult to interface with, usually due to being more clever than I wanted them to be, and had poor documentation for their interfaces. They were also generally written in VHDL, which since I've never written VHDL made it a little difficult to read to work out t</div>
                    <a href='cores/communication_controller/documented_verilog_uart/index.html'>documented verilog uart</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_documented_verilog_uart'>code</a>
                </td>
                <td>Dec 16, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller hBone Compliant: NoLicense: GPLDescriptionDQPSK symbol mapper suitable for TETRA/APCO-25 physical layer.</div>
                    <a href='cores/communication_controller/dqpsk_mapper/index.html'>dqpsk mapper</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_dqpsk_mapper'>code</a>
                </td>
                <td>Sep 29, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Bone Compliant: NoLicense: GPLDescription</div>
                    <a href='cores/communication_controller/dqpsk_symbol_mapper/index.html'>dqpsk symbol mapper</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_dqpsk_symbol_mapper'>code</a>
                </td>
                <td>Apr 19, 2013</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller l info:WishBone Compliant: NoLicense:E1 Framer &amp; DeframerE1 framer Deframer core implements CCITT (ITU) recommedations G.704,G.706 and G.732 for 30 channel multiplexed E1 stream at 2.048Mbps rate.Note:This project is part of the OpenStacks initiative at the Telecom Software Laboratory, Electrical Engineering Department / Bharti School of Telecommunication Technology &amp; Management. The initiative is founded and led by Dr.Subrat Kar (subrat@ee.iitd.ac.in) at the Department of Electrical Engineering, IIT Delhi. Please seehttp://www.iitd.ac.in/eeandhttp://www.iitd.ac.in/bsttmfor detailsFeat</div>
                    <a href='cores/communication_controller/e1_framer-deframer/index.html'>e1 framer/deframer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_e1_framer-deframer'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller hBone Compliant: NoLicense:</div>
                    <a href='cores/communication_controller/ebu-spdif_to_i2s_project/index.html'>ebu/spdif to i2s project</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ebu-spdif_to_i2s_project'>code</a>
                </td>
                <td>Jan 10, 2014</td>
                <td>VHDL</td>
                <td>Unknow</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller rovenWishBone Compliant: YesLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/ethernet_100-1000_mbps/index.html'>ethernet 100/1000 mbps</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ethernet_100-1000_mbps'>code</a>
                </td>
                <td>Aug 22, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:WishBone Compliant: NoLicense: LGPLDescriptionThis is a fork of the xge_mac and was released by the Computer Architecture Group (http://cag.uni-hd.de)of the University of Heidelberg.Main changes in this fork:-Unwanted FIFOs removed-Latency reduced due to the removal of the FIFOs and a new CRC implementation-Interface very similar to the one of the Xilinx MACThis core is in production use.</div>
                    <a href='cores/communication_controller/ethernet_10ge_low_latency_mac/index.html'>ethernet 10ge low latency mac</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ethernet_10ge_low_latency_mac'>code</a>
                </td>
                <td>Dec 1, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller esign done,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe 10GE MAC Core implements the Media Access Control functions for 10Gbps operation as defined in IEEE Std 802.3ae.Features1. Interfaces- XGMII Interface (64-bit single clock edge)- POS-L3 like Interface for core logic side- Wishbone Interface for control2. Inter-Frame GAP- Deficit Idle Count per Clause 463. Pause Frames- Received Pause Frames filtering- Receive Indication4. LAN mode operation5. Link Status- Local Fault Detection- Remote Fault Detection/Indication6. Latency- Low-latency flow-through mode (</div>
                    <a href='cores/communication_controller/ethernet_10ge_mac/index.html'>ethernet 10ge mac</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ethernet_10ge_mac'>code</a>
                </td>
                <td>Apr 20, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller IC proven,Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe Ethernet MAC (Media Access Control), sublevel within the Data Link Layer of the OSI reference model. This core is designed for implementation of CSMA/CD LAN in accordance with the IEEE 802.3 standards.The MAC is the portion of ethernet core that handles the CSMA/CD protocol for transmission and reception of frames. It peforms Frame Data Encapsulation and Decapsulation, Frame Transmission, and Frame Reception.Size is approximately 28k gates (2400 flip-flops).SpecificationEthernet Design Docume</div>
                    <a href='cores/communication_controller/ethernet_mac_10-100_mbps/index.html'>ethernet mac 10/100 mbps</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ethernet_mac_10-100_mbps'>code</a>
                </td>
                <td>Sep 2, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ication doneWishBone Compliant: NoLicense:OverviewThe Serial Media Independent Interface, SMMI, is a low pin count version of the MII normally used between ethernet MAC and PHY.The Serial Media Independent Interface (SMII) is designed to satisfy the following requirements:Convey complete MII information between a 10/100 PHY and MAC with two pins per portallow multi port MAC/PHY  communications with one system clockOperate in both half and full duplexper packet switching between 10 Mbit and 100 Mbit data ratesallow direct MAC to MAC communicationSMII is composed of two signals per port, global </div>
                    <a href='cores/communication_controller/ethernet_smii/index.html'>ethernet smii</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ethernet_smii'>code</a>
                </td>
                <td>Mar 19, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller neWishBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/communication_controller/ethernet_switch_on_configurable_logic/index.html'>ethernet switch on configurable logic</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ethernet_switch_on_configurable_logic'>code</a>
                </td>
                <td>Jul 5, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: NoLicense: GPLDescriptionIt's a general purpose Cypress EZUSB communication core which was developed forZTEX FPGA Boardsand supports the following features:EZ-USB slave FIFO inputEZ-USB slave FIFO outputbuffering and filtering of the interface clock from the EZ-USBScheduler if both directions are activeAutomatic committing 'PKTEND' after timeoutInterfaceThe usage of this core is best described by a commented port definition:module ezusb_io#(parameter CLKBUF_TYPE="",// selects the clock preparation method (buffering, filtering, ...)// "SPARTAN6" for Xilinx Spartan 6,// "SERI</div>
                    <a href='cores/communication_controller/ezusb_communication_core/index.html'>ezusb communication core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ezusb_communication_core'>code</a>
                </td>
                <td>Jul 29, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller  info:FPGA provenWishBone Compliant: NoLicense: OthersDescriptionThis project implements the simple and light protocol for transmissionof data from low resources FPGA connected to the Ethernet PHYand an embedded system running Linux OS.The main goal was to assure the reliable transmission over unreliableEthernet link without need to buffer significant amount of datain the FPGA. This created a need to obtain possibly earlyacknowledgment of received packets from the embedded system,and therefore the protocol had to be implemented in layer 3.The Ethernet type 0xfade was used (unreg</div>
                    <a href='cores/communication_controller/fade-light_l3_ethernet_protocol_for_transmission_o/index.html'>fade-light l3 ethernet protocol for transmission o</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_fade-light_l3_ethernet_protocol_for_transmission_o'>code</a>
                </td>
                <td>Oct 5, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller one Compliant: YesLicense:Description*NOTE* This project is currently unmaintained and uncompleted.  If you would like to take over this project please contact the current maintainer Kris Bahnsen.FireWire, Apple's implementation of IEEE 1394 protocol, is a high performance serial bus protocol to provide easy-to-use, low-cost, high-speed communications.Click herefor a good collection of links to IEEE 1394 documents.The goals of the FireWire project is to provide IEEE 1394 and IEEE 1394a-2000 compliant Link Layer cores:Link coreandHost Controller core. The project will also include firmware</div>
                    <a href='cores/communication_controller/firewire_ieee_1394/index.html'>firewire ieee 1394</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_firewire_ieee_1394'>code</a>
                </td>
                <td>May 3, 2015</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nal info:WishBone Compliant: NoLicense: BSDDescriptionFPGA-CF is an open-source, portable, extensible communications package that consists of a small hardware core (less than 600 slices) and and a host-software library/API (Java and C++). It enables a host PC to transmit data at 120 Mb/s to XIlinx-based FPGA boards via Ethernet using standard internet protocols (UDP/IP).  A custom lightweight connection-oriented protocol guarantees reliability. The hardware core is directly connected to the Xilinx internal configuration port (ICAP) and supports all ICAP functionality. The core also provides an</div>
                    <a href='cores/communication_controller/fpga_communication_framework/index.html'>fpga communication framework</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_fpga_communication_framework'>code</a>
                </td>
                <td>Aug 18, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ional info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLBlock DiagramDescriptionControl the activity and status of your FPGA by targeting a memory mapped space inside it.Based on:-- elements from the GH libraries (GH_library)-- HLeFevre UART project (LeFevre_uart)Simple three steps access procedure:-- Write words of 2 bytes address and 4 bytes data.-- Ask for an update targeting the update register (default 0x8000 0x00000000)-- Read words of 2 bytes address and 4 bytes data.The code comes plug and play:* the whole uart initialization process is automatic* 4 pins</div>
                    <a href='cores/communication_controller/fpga_remote_slow_control_via_uart_16550/index.html'>fpga remote slow control via uart 16550</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_fpga_remote_slow_control_via_uart_16550'>code</a>
                </td>
                <td>Jul 16, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: NoLicense: OthersDescriptionThe FT2232H is a USB2.0 Hi-Speed USB Device to FIFO IC.This core allows the use of this chip with an FGPA design in high speed FT245 style synchronous FIFO mode.Data rates up to 25 mbytes/s can be achieved. The core has internal FIFOs on the receive and transmit for improved throughput.For more information see FTDI's appnote "AN_130_FT2232H_Used_In_FT245 Synchronous FIFO Mode.pdf"Included: VHDL core, NIOS test application, PC test application</div>
                    <a href='cores/communication_controller/ft2232h_usb_avalon_core/index.html'>ft2232h usb avalon core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ft2232h_usb_avalon_core'>code</a>
                </td>
                <td>Mar 8, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe FT245R is a USB to parallel FIFO interface with a very simple protocol (for both FPGA and software).     FT245R interface core is intended to simplify the communication of your design with FT245R external chip. It takes care of delays     and synchronization with the actual device. I tried to keep the core as simple as possible, however, although it is fully     functional, there may be a place for further improvements, hence the status is "stable" rather than "done".FeaturesEasy to use.Fast (th</div>
                    <a href='cores/communication_controller/ft245r_interface/index.html'>ft245r interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ft245r_interface'>code</a>
                </td>
                <td>May 26, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller provenWishBone Compliant: NoLicense: GPLDownloadThe latest release of the Gamepads project is version 0.3 BETA.Get this and all previous versions of the design files from SVN:Download repository.Please keep in mind that trunk/ is work in progress and might contain smaller or bigger problems.You should also check theTrackerfor known bugs and see if they affect your work.ToolsThe following tools are integrated and are required for this project:TheGHDLsimulatorDescriptionThis project contains a collection of cores that interface with various gamepads.Each gamepad type has a dedicated controller c</div>
                    <a href='cores/communication_controller/gamepads/index.html'>gamepads</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_gamepads'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller mpliant: YesLicense:DescriptionThe GPIO IP core is user-programmable general-purpose I/O controller. Its use is to implement functions that are not implemented with the dedicated controllers in a system and require simple input and/or output software controlled signals.FeaturesThe following lists the main features of GPIO IP core:- Number of general-purpose I/O signals is user selectable and can be in range from 1 to 32. For more I/Os several GPIO cores can be used in parallel.- All general-purpose I/O signals can be bi-directional (external bi-directional I/O cells are required in thi</div>
                    <a href='cores/communication_controller/general-purpose_i-o_gpio_core/index.html'>general-purpose i/o gpio core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_general-purpose_i-o_gpio_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller fo:Design doneWishBone Compliant: NoLicense: GPLDescriptionProject content:trunk/vhdl - source of this open coretrunk/prototype_1 - example prototype using the GPIB coretrunk/prototype_1/fpga - xilinx project using trunk/vhdl as SVN externaltrunk/prototype_1/PC_software - PC test softwaretrunk/prototype_1/PCB - schematic diagram and PCB for prototypePrototype board uses minimodule MMfpga12 (http://www.propox.com/products/t_154.html?lang=en).The value added by the board is phisical GPIB interface and USB interface to connect to PC.To run prototype download trunk/prototype_1/fpga, build it and c</div>
                    <a href='cores/communication_controller/gpib_ieee-488_controller/index.html'>gpib ieee-488 controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_gpib_ieee-488_controller'>code</a>
                </td>
                <td>Jan 6, 2013</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller gn done,Specification doneWishBone Compliant: YesLicense: LGPLArchitectureDescriptionHardware Assisted IEEE 1588 IP Core. The necessary FPGA logic to assist SW protocol stack in implementing the Precision Time Protocol (IEEE 1588-2008) on 1000M/100M/10M Ethernet networks. PTP packets transmitting and receiving should be implemented by PTP SW protocol stack (PTPd) with existing MAC function; This IP Core implements the Real-Time Clock (RTC) and Time Stamping (TSU) of PTP event packets.Feature DescriptionRTC: Real Time Clock.* Standard PTP clock output with 2^48s and 2^32ns time format.* 1PPS ou</div>
                    <a href='cores/communication_controller/hardware_assisted_ieee_1588_ip_core/index.html'>hardware assisted ieee 1588 ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_hardware_assisted_ieee_1588_ip_core'>code</a>
                </td>
                <td>Feb 9, 2015</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller e Compliant: NoLicense: BSDDescriptionThis &euro;&oelig;core&euro;? is actually two cores &euro;&ldquo; an HDB3/HDB2/B3ZS Encoder that converts NRZ data into P and N pulses according to ITU-T G.703, and a HDB3/HDB2/B3ZS Decoder that converts P and N pulses into NRZ data according to ITU-T G.703.Note: HDB2 and B3ZS are different names for the same encoding.HDB3 is typically used to encode data at 2.048 (E1), 8.448 (E2) and 34.368Mb/s (E3)B3ZS is typically used to encode data at 44.736Mb/s (T3)Features- HDB3 / HDB2 selected by a generic.- Code Error output on decoder.- P and N outputs (on encode</div>
                    <a href='cores/communication_controller/hdb3-b3zs_encoder+decoder/index.html'>hdb3/b3zs encoder+decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_hdb3-b3zs_encoder+decoder'>code</a>
                </td>
                <td>Oct 29, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller mpliant: YesLicense:Features- 8 bit parallel backend interface- use external RX and TX clocks- Start and end of frame pattern generation- Start and end of frame pattern checking- Idle pattern generation and detection (all ones)- Idle pattern is assumed only after the end of a frame which is signaled by an abort signal- Zero insertion- Abort pattern generation and checking- Address insertion and detection by software- CRC generation and checking (Optional, external, since CRC-16 or CRC-32 can be used)- FIFO buffers and synchronization (External)- Byte aligned data (if data is not aligned to 8-b</div>
                    <a href='cores/communication_controller/hdlc_controller/index.html'>hdlc controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_hdlc_controller'>code</a>
                </td>
                <td>Dec 24, 2013</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ign doneWishBone Compliant: NoLicense:DescriptionA HyperTransport Tunnel controller written in SystemC. HyperTransport (HT) is a high-performance chip-to-chip interconnect architecture.  A tunnel has two HT ports to allow it to be used inside a chain of components.More information about HyperTransport can be found at theHyperTransport Consortium web site.Features- Written in synthesisable SystemC- Designed with the HyperTransport 2.0b specification- Core configurable options include:- Retry mode- DirectRoute- In-vc packet reordering- Extendable configuration register space- Buffer size- Ei</div>
                    <a href='cores/communication_controller/hypertransport_tunnel/index.html'>hypertransport tunnel</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_hypertransport_tunnel'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller proven,Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: BSDDescriptionI2C is a two-wire, bidirectional serial bus that provides a simple, efficient method of data exchange between devices. It is primarily used in the consumer and telecom market sector and as a board level communications protocol.The OpenCores I2C Master Core provides an interface between a Wishbone Master and an I2C bus.It is an easy path to add I2C capabilities to any Wishbone compatible system.You can find the I2C specifications onPhillips webSite.Work was originally started by Frdric Ren</div>
                    <a href='cores/communication_controller/i2c_controller_core/index.html'>i2c controller core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2c_controller_core'>code</a>
                </td>
                <td>Jun 2, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller info:Design done,FPGA provenWishBone Compliant: NoLicense: BSDDescriptionSince lots of people ask me questions about my core, i want to clarify some things:1) the master works, the slave is not entirely thought-through, i used it in simulation only.2) i'm adding a diagram, that explains how to control the core.3) adding a file name i2c_master_v01.vhd, that containes the master only.4) since i have some time now, i will try to work on the slave.have fun!Eli.The file name is V02 because V01 contained only an unwilling to work master.it will not be posted here.Master:*supports burst writes and re</div>
                    <a href='cores/communication_controller/i2c_master_slave_core/index.html'>i2c master slave core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2c_master_slave_core'>code</a>
                </td>
                <td>Jun 10, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller itional info:FPGA provenWishBone Compliant: YesLicense:DescriptionDescription of project..This design is Wishbone compatible I2C core. This core can work as I2C master as well as slave.VMM Test-bench is also available.FeaturesBoth Master and slave operationBoth Interrupt and non interrupt data-transfersStart/Stop/Repeated Start generationFully supports arbitration processSoftware programmable acknowledge bitSoftware programmable time out featureprogrammable address registerProgrammable SCL frequencySoft reset of I2C Master/SalveProgrammable maximum SCL low periodsynthesis coreStatusDesign: Don</div>
                    <a href='cores/communication_controller/i2c_master-slave_core/index.html'>i2c master/slave core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2c_master-slave_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :WishBone Compliant: NoLicense: LGPLDescriptionThis is a quick module I hacked together to connect two I2C buses to work around a hardware bug on a board.It mostly works, and I'm posting it in case others find it useful.  I wouldn't use it in a production system as it stands.It is written in SystemVerilog, so you'll need to change some "logic" declarations to "reg" if your compiler can't handle SystemVerilog.  There are probably some other SystemVerilog features used, also.I suggest toggling the reset signal between I2C transfers, if possible.</div>
                    <a href='cores/communication_controller/i2c_repeater/index.html'>i2c repeater</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2c_repeater'>code</a>
                </td>
                <td>Nov 28, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Design done,FPGA provenWishBone Compliant: NoLicense: GPLDescriptioni2cSlave is a minimalist I2C slave IP core that provides the basic framework for theimplementation of custom I2C slave devices. The core provides a means to read and writeup to 256 8-bit registers. These registers can be connected to the users custom logic,thus implementing a simple control and status interface. A fullIcarusVerilog test bench is available.Test it for yourself, using the free Icarus Verilog simulator and the free GTKWave wave form viewer. Only 6 simple steps!-Downloadand install Icarus Verilog.-Dow</div>
                    <a href='cores/communication_controller/i2c_slave/index.html'>i2c slave</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2c_slave'>code</a>
                </td>
                <td>Dec 18, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Compliant: NoLicense:FEATURES- Captures I2C 2 wire serial bus activities into an external RAM- Applicable to Atmel 2 wire serial bus format:This includes (1) Random byte write(2) Page write(3) Random byte read(4) Multiple start- End of a transition after the stop bit is followed by an 8 bit count for simple time stamp.- Code witten for 32K byte capacity, can be modified to higher capacity.- Requires an external 2MHz to 5MHz clock.I2C Bus Traffic LoggerDESCRIPTIONTwo wire serial I2C bus is designated as the communication standard in physical layer (PHY) transponders for link status monitoring  </div>
                    <a href='cores/communication_controller/i2c_traffic_logger/index.html'>i2c traffic logger</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2c_traffic_logger'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Mature</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller shBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/i2cgpio/index.html'>i2cgpio</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2cgpio'>code</a>
                </td>
                <td>Dec 21, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: YesLicense: LGPLDescriptionI2C slave to  WishBone master interface.</div>
                    <a href='cores/communication_controller/i2c_to_wb/index.html'>i2c_to_wb</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2c_to_wb'>code</a>
                </td>
                <td>Sep 15, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: GPLFeatures- Separate transmitter and receiver.- Operates in either slave or master mode.- Configurable sample buffer size.- Supports 16bit to 32bit resolution.- Supports 16bit and 32bit Wishbone data bus.- Interrupt capability.DescriptionI2S is an industry standard (invented by Philips) 3-wire interface for streaming stereo audio between devices. Typical applications include digital audio transfer between a CPU/DSP and a DAC/ADC. The I2S core allows a Wishbone master to stream stereo audio to and from I2S capable devi</div>
                    <a href='cores/communication_controller/i2s_interface/index.html'>i2s interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2s_interface'>code</a>
                </td>
                <td>Apr 23, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller GA provenWishBone Compliant: NoLicense: GPLI2S to Paralell ADC/DAC controllerThis provides a bridge between a paralell device (such as a microcontroller (uC) and an I2S (!not! I2C) audio bus, generally used for ADC's and DAC's, such as in DVD &amp; MP3 playersNominal target is a CPLD, 128-cell variants will hold the entire project for bidirectional (ADC &amp; DAC) operation simultaneously with 24-bit I/O's.  Removing either side or reducing bus width allows operation in 64-cell devices (the core was actually tested in this configuration).Origonally written in VHDL for Xilinx ISE - project &amp</div>
                    <a href='cores/communication_controller/i2s_to_paralell_adc-dac_controller/index.html'>i2s to paralell adc/dac controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2s_to_paralell_adc-dac_controller'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:Design doneWishBone Compliant: NoLicense: GPLI2S to Parallel InterfaceThis module provides a bridge between an I2S serial device (audio ADC, S/PDIF Decoded data) and a parallel device (microcontroller, IP block).It's coded as a generic VHDL entity, so developer can choose the proper signal width (8/16/24 bit)Input takes:-I2S Bit Clock-I2S LR Clock (Left/Right channel indication)-I2S DataOutput provides:-DATA_L / DATA_R parallel outputs-STROBE and STROBE_LR output ready signals.As soon as data is read from the serial I2S line, it's written on the proper parallel output and a rising edge of th</div>
                    <a href='cores/communication_controller/i2s_to_parallel_interface/index.html'>i2s to parallel interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2s_to_parallel_interface'>code</a>
                </td>
                <td>Mar 17, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller fo:WishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/i2s_to_wishbone/index.html'>i2s to wishbone</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i2s_to_wishbone'>code</a>
                </td>
                <td>Mar 28, 2011</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Bone Compliant: NoLicense: LGPLDescriptionComplete implementationof i8255 PPI in fpga.You may find somedatasheets abouthere.Verilog code has somemodules:PORTS - matches to thea,b,c. External world - inout tri-state bus. Internal circuit -datain and dataout buses.port c divided by twoparts - high and low.GROUPS - representgroup A and group B like in the real device. Group A controls port Aand hight 4 bits of port C.Group B controls port Band low 4 bits of port c.Groups connected toports with input/output data buses and control lines.i8255 core - allexternal inputs and outp</div>
                    <a href='cores/communication_controller/i8255_realisation_in_verilog/index.html'>i8255 realisation in verilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_i8255_realisation_in_verilog'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller tional info:WishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of a component that can be connected to the input port of the Virtex-5 Ethernet MAC Local Link Wrapper and that allows for transmission of IPv4 ethernet packets.The complete UDP/IP core that uses this component is the UDP/IP Core project.</div>
                    <a href='cores/communication_controller/ipv4_ethernet_packet_creator_and_transmitter/index.html'>ipv4 ethernet packet creator and transmitter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ipv4_ethernet_packet_creator_and_transmitter'>code</a>
                </td>
                <td>Mar 7, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller mpliant: YesLicense:DescriptionIrDA core that utilizes uart16550 core for 115.2Kbit/s IrDA communication. Required bit encoding/decoding is performed.The 115.2 (SIR) mode should work alright.There's also a lot of code for MIR and FIR, much faster communication modes. Yet they are not fully tested and are sure to contain a lot of bugs.Features Designed for all standard IR transceivers. Implements WISHBONE bus interface Up to 4Mbit communication speed Programmable clock selection Loopback option for testing Works with WISHBONE bus clock Can request DMA transfersStatusCurrently, only 115.2 (SIR) </div>
                    <a href='cores/communication_controller/irda/index.html'>irda</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_irda'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller l info:FPGA provenWishBone Compliant: NoLicense: BSDDescriptionThis project aims at implementing a basic iso7816:3 master which can be controlled by software or by a state machine.This is a work in progress. Currently, a draft implementation is being crafted just to identify the design challenges.Once it is completed, the plan is to make a precise spec of a final version and then implement it.Currently the IP supports only T=0, in direct and inverse convention. It does not handle T=0 parity error signaling / retry mechanism yet.FPGA test included only the UART, not the master module.</div>
                    <a href='cores/communication_controller/iso7816_3_master/index.html'>iso7816_3_master</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_iso7816_3_master'>code</a>
                </td>
                <td>Apr 18, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ishBone Compliant: NoLicense: LGPLDescriptionThis is a JTAG Master written in VHDL. It's simulated and tested with XC9500 and the jtag slave from opencores (http://opencores.org/project,jtag)</div>
                    <a href='cores/communication_controller/jtag_master/index.html'>jtag master</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_jtag_master'>code</a>
                </td>
                <td>Jun 8, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller A provenWishBone Compliant: NoLicense: LGPLDescriptionproject is closed at the moment.</div>
                    <a href='cores/communication_controller/jtag_slave-boundaryscan_slave/index.html'>jtag slave/boundaryscan slave</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_jtag_slave-boundaryscan_slave'>code</a>
                </td>
                <td>Jul 24, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nfo:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionMain features of latest v5 HW are:-LPC memory read (can be disabled),LPC Firmware Hub memory readand IO write for POST Code capture (and display on LED segments)-POST code peek mode (LPC reads from dongle are disabled)-POST code logger (sends all postcodes to USB serial port as hexadecimal bytes in ASCII)This is hardware project for existing USB dongleboard (costing about 150 EUR you should check from sales(at)artecgroup.com). Using it for LPC dongle.IP cores- LPC slave (supporting IO write, Memory read and LPC Firmware Hub read from</div>
                    <a href='cores/communication_controller/lpc_rom_emulator_on_usb_dongle_fpga_core_set/index.html'>lpc rom emulator on usb dongle fpga core set</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_lpc_rom_emulator_on_usb_dongle_fpga_core_set'>code</a>
                </td>
                <td>Jan 27, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:Design done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis is a receiver for a Multichannel Audio Digital Interface (MADI), also known as AES-10. This type of fibreoptical or electrical connection is used in professional audio where a greater number of digital audio channel has to be transported.The link speed of MADI is 125Mbit/s, while the data transfer rate used is 100Mbit/s. The diffrence between the two is explained by the use of a link encoding scheme. The encoding scheme used is known as 4B5B, which turns a 4 bit nibble into a 5 bit symbol. The data is NRZI encoded for </div>
                    <a href='cores/communication_controller/madi_receiver/index.html'>madi receiver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_madi_receiver'>code</a>
                </td>
                <td>May 5, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller  info:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis core decodes incoming Manchester encoded data. The core is easily modified for your particular project, in that there are just a few constants that you must change.This project is in an alpha stage and is currently too susceptible to other radio noise. In our development environment, there is currently a 25-50% error rate, which comes from the algorithm misidentifying signal for noise and noise for signal.Obtain the most current code with:svn cohttp://opencores.org/ocsvn/manchesterwireless/manchesterwireless/tags/release-1.0ma</div>
                    <a href='cores/communication_controller/manchester_decoder_for_wireless/index.html'>manchester decoder for wireless</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_manchester_decoder_for_wireless'>code</a>
                </td>
                <td>Jun 24, 2009</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller A provenWishBone Compliant: NoLicense:DescriptionBosch control keyboard and Bosch DVR/VCR send bi-phase Manchester signal in their own format to control Bosch speed doom. This converter get the data and change to UART format for the MCU to process it.This is the signal converter on data link layer.About how to convert signal in phyical layer , there have some circuit to do it , if interest please email to me at kenneth@opencores.org to get schematic.Featuresseparate manchester signal- guard_time- preamble- sync_start- data- stop-- example : Pan Left Manchester signal on philips protocol-- 0000</div>
                    <a href='cores/communication_controller/manchester_to_uart_converter/index.html'>manchester to uart converter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_manchester_to_uart_converter'>code</a>
                </td>
                <td>Nov 16, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:WishBone Compliant: NoLicense: LGPLDescriptionThis is a Manchester encoded UART that enables runing small periferals with parasitic power derived from the TXD line, and allowing large clock differences typical of RC oscillators.ManchesterUartWhat it is:The Manchester UART replaces a standard UART. Instead of the NRZ coding of byte, it uses a Manchester protocol and encodes a 16 bit data word. The Manchester protocol transitions in the middle of the bit time. A rising transition is considered a one, and a falling transition is considered a zero. In order to get the correct edge in the middle </div>
                    <a href='cores/communication_controller/manchester_uart/index.html'>manchester uart</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_manchester_uart'>code</a>
                </td>
                <td>Nov 12, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ign done,FPGA proven,Specification doneWishBone Compliant: YesLicense: GPLDescriptionThis core is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.Minimal 10/100 Ethernet MAC.Only full duplex support for now.DMA support (Wishbone master)Packets are streamed to and from system memory to minimize costly on-chip storage.Directly connects to standard MII PHYs.Bit-banged MDIOMore informationCore documentationCSR bus specifications</div>
                    <a href='cores/communication_controller/minimac-the_minimalist_ethernet_mac/index.html'>minimac-the minimalist ethernet mac</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_minimac-the_minimalist_ethernet_mac'>code</a>
                </td>
                <td>Aug 7, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Bone Compliant: NoLicense: LGPLDescriptionThis is another UART project, but is different because that it is very small and will occupy less macrocells on a CPLD.The purpose of this core is only to implement a very basic UART, without handshaking or FIFO's.It was developed to be syntezizable on a large number of syntesis tools, so it can be adapted to your device easily.On the first implementation was used a Xilinx Spartan 3E, with 64 occupied slices.Please read the documentation, it have useful implementation examples.For the testing was used the Modelsim simulator and a Enterpoint Drigmorn bo</div>
                    <a href='cores/communication_controller/minimal_uart_core/index.html'>minimal uart core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_minimal_uart_core'>code</a>
                </td>
                <td>May 7, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller shBone Compliant: NoLicense:DescriptionDescription of project..Features- feature1- feature1.1-feature1.2-feature2Status-Planning</div>
                    <a href='cores/communication_controller/most_network_interface_controller/index.html'>most network interface controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_most_network_interface_controller'>code</a>
                </td>
                <td>Dec 25, 2005</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Compliant: NoLicense:DescriptionThe main file is modem.vhdI don't separate the test part from modulation part.The main modulation part is ofdm.vhd, and you can chose if it will work as TX or RX, the bit size. But, don't change Point and Stage, it has a bug.Another time I write more (and better).Forgive my english.Features- feature1- feature1.1-feature1.2-feature2StatusHave a bug if change the fft size.</div>
                    <a href='cores/communication_controller/ofdm_modem/index.html'>ofdm modem</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ofdm_modem'>code</a>
                </td>
                <td>Dec 30, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ecification doneWishBone Compliant: YesLicense: GPLDescriptionSoftUSB is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.Supports full (12Mbps) and low (1.5Mbps) speed operationTwo downstream ports with shared bandwidthIntegrated PHYDirectly interfaces to common USB transceivers such as the MIC2550AHybrid architecture featuring theNavrAVR compatible processor (8-bit RISC) to implement the complex parts of OHCI in C software.Two asynchronous clock domains: system clock and 48MHz USBAVR program and OHCI descriptors and data are store</div>
                    <a href='cores/communication_controller/ohci_full-low-speed_usb_host_controller/index.html'>ohci full/low-speed usb host controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ohci_full-low-speed_usb_host_controller'>code</a>
                </td>
                <td>Apr 19, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller en,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionOpen Peer to Peer Interface, Wishbone to Aurora Bridge (OP2P).This interface logic has been designed to provide a very high performance multi-lane multi-gigabit fully non-transparent (independent address spaces) peer-to-peer (no master/slave or root-complex/endpoint relationships) communiction link where the rest of the communication stack is implemented in hardware. It can be used for both cable or backplnane links. The aim of the project is to provide a network-like, high-bandwidth, flexible, serial-I/O-based replacement of </div>
                    <a href='cores/communication_controller/op2p_openpeertopeer_interface/index.html'>op2p openpeertopeer interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_op2p_openpeertopeer_interface'>code</a>
                </td>
                <td>Nov 17, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller GA provenWishBone Compliant: NoLicense: LGPLDescriptionThe OPB SPI Core connects a FPGA to a DSP or Microprocessor as Slave-Device. This means all transfers are initiated by the Master an the FPGA-System only responds to read or write request.Features- OPB-Clock and SPI-Clock are complete independent- SPI can run faster than OPB if guaranteed that no TX-FIFO Underrunn or RX- FIFO Overrunn occure.- variable transfer length 2..32- Automatic CRC-Generation for Transmit and Receive Data (only 8,32Bit Shift-Register Width)Status- simulation tests done- Hardware tests on a Virtex-4 ML401 Board (LX25</div>
                    <a href='cores/communication_controller/opb_spi_slave/index.html'>opb spi slave</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_opb_spi_slave'>code</a>
                </td>
                <td>May 15, 2008</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller fo:Design done,FPGA provenWishBone Compliant: NoLicense: GPLOPB OneWire MasterThis is an easy-to-use OneWire master peripheral for the Microblaze OPB bus.The following functions will allow your program to access this peripheral easily:OneWireReset();data = OneWireRead();OneWireWrite(data);To install, simply unzip the file into your projects' pcores directory.  The functions are in a text file in the onewire core directory.Features- Ease of useStatusFully operational and tested in hardware on a Spartan 3E with a DS2432 Secure EEPROM chip.</div>
                    <a href='cores/communication_controller/opb-compatible_onewire_master/index.html'>opb-compatible onewire master</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_opb-compatible_onewire_master'>code</a>
                </td>
                <td>Oct 9, 2007</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller PGA provenWishBone Compliant: NoLicense: LGPLDescriptionopb_usblite - opb_uartlite replacement for Xilinx Microblaze processor written in VHDL and Verilog. The opb_usblite is compatible with the USB CDC profile and works with microsoft usbser virtual comport driver (VCD).ImplementationThe opb_usblite connects directly to the OPB bus. For users that are using the processor local bus (PLB) it is possible to add a PLB2OPB bridge. See the reference design for the Spartan 3E starter board.There are a few generics to configure the behavior of the core.C_SYSRST  :       std_logic := '1';  -- enable e</div>
                    <a href='cores/communication_controller/opb_usblite/index.html'>opb_usblite</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_opb_usblite'>code</a>
                </td>
                <td>Jun 8, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: NoLicense: GPLDescriptionOpen-source implementation of a versatile UDP/IP core for FPGAs.C/C++ Software library for configuring the core and transmitting standard C types like characters, integers, floats and doubles.Hardware interface for transmitting standard C types like characters, integers, floats and doubles.The UDP/IP core can transmit and receive data to and from any PC. The only requirement is the use of the configuration function provided by the software library in order to initialize an internal lookup table.</div>
                    <a href='cores/communication_controller/pc-fpga_communication_platform/index.html'>pc-fpga communication platform</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_pc-fpga_communication_platform'>code</a>
                </td>
                <td>Mar 7, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller fo:FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLBlock DiagramDescriptionThe PCIe Engine is designed byNikhef - Amsterdam, The Netherlands- for theATLAS/ FELIX project.     Its main purpose is to provide a simple Direct Memory Access (DMA)  interface to the Xilinx Virtex-7 PCIe Gen3 hard block.     The Engine is specifically designed for the 256 bit wide AXI4-Stream interface of theXilinx Virtex-7 FPGA Gen3 Integrated Block for PCI Express (PCIe).DMA read and writeThe main purpose of the PCIe Engine is therefore to provide an interface to standard FIFOs.     This is the d</div>
                    <a href='cores/communication_controller/pcie_gen3x8_dma_for_virtex7/index.html'>pcie gen3x8 dma for virtex7</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_pcie_gen3x8_dma_for_virtex7'>code</a>
                </td>
                <td>Apr 30, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionThe intention of the project is the development of a bus bridge, which enables the usage of WB compliant IP cores in a system, which uses the Processor Local Bus (PLB) as system and peripheral bus. The PLB-to-WB (PLB2WB) Bridge enables the access to slaves on the WB side for masters on the PLB side.Features:- separate clock domains for PLB and WB- separate resets for PLB and WB possible - PLB address pipelining (optional)- PLB fixed length burst transfers (only words, optional)- PLB line transfers (optional)- WB B.3 classic cycles (bl</div>
                    <a href='cores/communication_controller/plb-to-wb_bridge/index.html'>plb-to-wb bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_plb-to-wb_bridge'>code</a>
                </td>
                <td>Feb 23, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nal info:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis core aims at implementing host side of IBM PS/2 keyboard and mouse communication protocol.To run testbench:%&gt; iverilog -DSYS_CLOCK_HZ=100000 -o ps2_host_testbench ps2_host_testbench.v%&gt; vvp ps2_host_testbench -lxt2%&gt; gtkwave ps2_host_testbench.lxt</div>
                    <a href='cores/communication_controller/ps-2_host_controller/index.html'>ps/2 host controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ps-2_host_controller'>code</a>
                </td>
                <td>Dec 19, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ompliant: YesLicense:DescriptionCompact and optimized PS/2 controller for Keyboard and Mice.PS2 Core is build modular. There are one principal module that contains all communications logic, this can be used alone for hardware-only desings or used together with an wishbone bus top-level module for use in microprocessor systems.The main goal of PS2 Core is create an fully functional PS2 controller with a very efficient use of logic and resources but without loss any functionality. The wishbone top-level has been designed to be as small as possible, giving an very simple and easy to use interface</div>
                    <a href='cores/communication_controller/ps2_core/index.html'>ps2 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ps2_core'>code</a>
                </td>
                <td>Dec 9, 2010</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller esign done,FPGA proven,Specification doneWishBone Compliant: YesLicense: GPLDescriptionThis is a Quad-SPI Flash controller.  It currently works for me on the 4MB Spansion flash found within a Basys-3 development board.  The controller hides much, although not all, of the flash chip interactions from the user behind wishbone read and write accesses.  Indeed, reading from this memory is as simple as reading from the wishbone!For those not familiar with a Quad-SPI flash, the basic device is built upon a SPI interface.  Such an interface consists of four wires: a chip select, a clock, a master out</div>
                    <a href='cores/communication_controller/quad_spi_flash_controller/index.html'>quad spi flash controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_quad_spi_flash_controller'>code</a>
                </td>
                <td>Jun 4, 2015</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nfo:FPGA provenWishBone Compliant: NoLicense: GPLDescriptionThis is a very simple project for reading a quadrature device, such as an optical encoder.  The counter is initialized to zero, and then counts up and down when valid quadrature is present at the inputsFeatures- Simple VHDL for beginners; well documented; shows use of hierarchical design.- Count limited only by bit length of counter vector; simple to count very large values- VHDL Implementation of Xilinx application note #012 (xapp012.pdf)- NPL project file for immediate evaluation in Xilinx ISE/Webpack tools- Questions/Comments:http:</div>
                    <a href='cores/communication_controller/quadrature_decoder-counter/index.html'>quadrature decoder/counter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_quadrature_decoder-counter'>code</a>
                </td>
                <td>Apr 23, 2004</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ompliant: NoLicense: LGPLOverviewRapidIO is a standard protocol defined by the RapidIO Trade Association used to build high-speed embedded networks. It is an open standard and can be downloaded on www.rapidio.org.This project was founded 2013 when Bombardier decided to release some of its RapidIO IP-blocks to the general public. It contains basic IP-block to build switches, endpoints and switches with embedded endpoints.The main development has been moved tohttps://github.com/magro732/OpenRIO/to be able to use GIT instead of SVN.VHDL IPsRioSwitch.vhd - Contains a RapidIO switch IP.It has been </div>
                    <a href='cores/communication_controller/rapidio_ip_library/index.html'>rapidio ip library</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_rapidio_ip_library'>code</a>
                </td>
                <td>Jun 3, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nfo:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis is a small UART to byte uPC interface (compliant with RS232 and RS3232 CI's).Ideal to use with soft/hard processors in a FPGA project.Designed to sync internal clock of RX path. Independent clock sources (TX/RX).uPC InterfaceTX:- TX data;- TX request;- TX end of send;RX:- RX data;- RX data ready (data valid);</div>
                    <a href='cores/communication_controller/rs232_1/index.html'>rs232 1</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_rs232_1'>code</a>
                </td>
                <td>Apr 29, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller tional info:WishBone Compliant: YesLicense: LGPLDescriptionTwo wire RS232 communication module capable of 5, 6, 7, 8 bit word communication, Parity bit, Parity bit Polarity, 1 and 2 stop bits. Integrated with transmit and receive buffer controlled through a WishBone interface. Besides the WishBone interface auxiliary signals are provided for Buffer status and can be used for interrupt driven routines.</div>
                    <a href='cores/communication_controller/rs232_2/index.html'>rs232 2</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_rs232_2'>code</a>
                </td>
                <td>Sep 11, 2013</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller fo:Design done,FPGA provenWishBone Compliant: YesLicense: BSDDescriptionThis is a simple uart core which includes a baud generator. The core uses a fixed format: 1 start,8 data, 1 stop bit.+ baudX8/X16 mode selects in runtime</div>
                    <a href='cores/communication_controller/rtfsimpleuart/index.html'>rtfsimpleuart</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_rtfsimpleuart'>code</a>
                </td>
                <td>Nov 16, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ogDevelopment status:MatureAdditional info:ASIC proven,Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense:OverviewRXAUI interface uses two 6.25Gbps SERDES lanes to carry 10GE, instead of using four 3.125Gbps SERDES lanes.This enables a high port count lower power multi 10GE SOCs.This projects provides the specifications of RXAUI interface and the verilog code for an adapter froma XAUI to RXAUI interface</div>
                    <a href='cores/communication_controller/rxaui_interface_and_xaui_to_rxaui_interface_adapte/index.html'>rxaui interface and xaui to rxaui interface adapte</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_rxaui_interface_and_xaui_to_rxaui_interface_adapte'>code</a>
                </td>
                <td>Oct 22, 2009</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ishBone Compliant: NoLicense: OthersDescriptionStaus:Simulations are workingCurrently the stack is confusing to use, I'm working on this.I do not intend to push developer versions of the code to opencores if you are interested in observing the developer cores I work primarily through github:Nysa SATA GithubTODO: Modify Link layer so that it only instantiates one instance of a single scrambler, not twoCode Organization:rtl/sata_stack.v (Top File that applications interface with)sata_defines.v (Set defines for the stack in here)generic/ (small modules used throughout the design)/blk_mem.v (wraps</div>
                    <a href='cores/communication_controller/sata_controller/index.html'>sata controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sata_controller'>code</a>
                </td>
                <td>May 12, 2015</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: NoLicense: LGPLDescriptionSATA PHY layer which can be implemented as either a host or device for Xilinx 6 series devices.A host controller core with AXI interface is available, contact me for more information.</div>
                    <a href='cores/communication_controller/sata_phy/index.html'>sata phy</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sata_phy'>code</a>
                </td>
                <td>Mar 10, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :StableAdditional info:WishBone Compliant: NoLicense: BSDDescriptionThis is a scan based serial communication block designed to safely and easily move data onto and off of a chip with a minimal number of pins. Performance is not a priority, however, we have found it to be sufficiently fast most any student project. It has been used, successfully, on many tapeouts.Included is an on-chip synthesizble scan block and an off-chip testbench to interact with it.The on-chip scan block has six pad signals that go off-chip, and a configurable number of on-chip data input and output signals. Data signals</div>
                    <a href='cores/communication_controller/scan_based_serial_communication/index.html'>scan based serial communication</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_scan_based_serial_communication'>code</a>
                </td>
                <td>Jul 22, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller StableAdditional info:Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLIntroductionThe "sd card controller" is a Secure Digital Card Host Controller, which main focus is to provide fast and simple interface to SD/SDHC cards. One of the main goal with this project is that the controller should be usable as a system disk contain a file system. Therefore the core has been developed with features a system with operative system will benefit from.The design also include a simplified model of a SD-card to test against.http://www.opencores.org/?do=project&amp;who=sdcar</div>
                    <a href='cores/communication_controller/sd_card_controller/index.html'>sd card controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sd_card_controller'>code</a>
                </td>
                <td>May 3, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ign done,FPGA provenWishBone Compliant: NoLicense: GPLDescriptionThe SD/MMC Bootloader is a CPLD design that manages configuration and bootstrapping of FPGAs. It is able to retrieve the required data from SecureDigital (SD) cards or MultiMediaCards (MMC) and manages the FPGA configuration process. SD cards as well as MMCs are operated in SPI mode which is part of both standards thus eliminating the need for dedicated implementations. The SD/MMC Bootloader fits both. Beyond configuration, this core supports a bootstrapping strategy where multiple images are stored on one single memory card.For </div>
                    <a href='cores/communication_controller/sd-mmc_bootloader/index.html'>sd/mmc bootloader</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sd-mmc_bootloader'>code</a>
                </td>
                <td>Aug 19, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :Design done,FPGA provenWishBone Compliant: YesLicense: GPLDescriptionSD (Secure Digital) and MMC memory card controller with Wishbone slave interface. Handles all aspects of card initialization, 512 byte block read, and block write. Hides the complicated SD/MMC memory interface, and presents the user with a simple Fifo interface. Provides transfer speeds up to 24Mbps.If combined with the fpgaConfig project:http://opencores.org/project,fpgaconfigthen it is possible to configure an FPGA from SD memory. If the FPGA configuration includes this core (spiMaster) and a softcore processor, then the p</div>
                    <a href='cores/communication_controller/sd-mmc_controller/index.html'>sd/mmc controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sd-mmc_controller'>code</a>
                </td>
                <td>Nov 24, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :WishBone Compliant: NoLicense: BSDDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/sdhc_self_configuring_core/index.html'>sdhc self configuring core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sdhc_self_configuring_core'>code</a>
                </td>
                <td>Jan 4, 2011</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :BetaAdditional info:Design done,FPGA provenWishBone Compliant: NoLicense: GPLDescriptionThe SATA core implements the Command, Transport and Link Layers ofthe SATA protocol and provides a Physical Layer Wrapper for the GTXtransceivers. The Physical Layer Wrapper also includes an Out of BandSignaling (OOB) controller state machine which deals with initializationand synchronization of the SATA link. It can interface with SATA 2Winchester style Hard Disks as well as Flash-based Solid State DrivesThe core provides a simple interface to issue READ/WRITE sector commands.The DATA interface is 32-bit </div>
                    <a href='cores/communication_controller/serial_ata_host_bus_adapter_core_for_virtex_6/index.html'>serial ata host bus adapter core for virtex 6</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_serial_ata_host_bus_adapter_core_for_virtex_6'>code</a>
                </td>
                <td>Nov 12, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller mpliant: NoLicense:Specifications- as small as possible to fit in a Xilinx CPLD- fixed 9600 baudrate for this version- 1 start bit, 8 data bits, 1 stop bit data stream format- both interrupt-based and polling user interfaceDescriptionSerial UART open source core. The design is engineered for use as a stand alone chip or for use with other of our cores. The reason for developing the Serial UART core is the fact, that asynchronous serial communication is very common that almost every machine understands it.Also, for OCRP-1, we needed a way of communication with a host computer, to make it availa</div>
                    <a href='cores/communication_controller/serial_uart_1/index.html'>serial uart 1</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_serial_uart_1'>code</a>
                </td>
                <td>Apr 14, 2010</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ne Compliant: YesLicense:DescriptionDesign in VHDL:This UART is able to Transmit/Receive bytes in the configuration:1 start bit - no parity - 1 stop bit.It can be commanded by a microcontroller, or by other IP core.It is not suited to interface a modem as there is no control handshaking (CTS/RTS).It does'nt contain FIFO for emit/receive.Features WISHBONE interface in 8-bit data bus Two clock: one for wishbone interface, one for RS232 bitstream generation Baudrate divisor from 1 to 65536 (generic parameter set at integration time)Synthesis resultsXilinx: Spartan:    XCS10-TQ144-4:  71 flip-flop</div>
                    <a href='cores/communication_controller/serial_uart_2/index.html'>serial uart 2</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_serial_uart_2'>code</a>
                </td>
                <td>Aug 26, 2010</td>
                <td>Unknow</td>
                <td>Mature</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ditional info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionA device that convert a PC parallel port to serial , then serial to parallel. It can transport all signals of the PC parallel port into a single wire. Moreover, the data wire is intended to be a fiber optic in the final form of the project.OverviewProject idea :I would like to show you how I control my CNC equipment (which is usually controlled by a PC parallel port) with a single wire using a special FPGA device.The FPGA device serialize the control signals from the parallel port , transport </div>
                    <a href='cores/communication_controller/serializer-deserializer_for_audio_fiber_optic/index.html'>serializer/deserializer for audio fiber optic</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_serializer-deserializer_for_audio_fiber_optic'>code</a>
                </td>
                <td>Apr 28, 2014</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller n doneWishBone Compliant: NoLicense: GPLDescriptionGeneric SGMII / 1000X module that can be connected to any transceiver technology.This core has been verified with 88E1111 Phy- Autonegotiation- Rx &amp; Tx in 1000Mbps mode- Slow bit rate ~ 10MbpsI don't have adequate tools to verify at full speed.I appreciate any effort to verify and report bugs.Everyone is welcome to try this core.I can be contacted at jefflieu@fpga-ipcores.com for other license/support/bring-up issue. Btw, if you think it's useful to you, you can show your appreciation by donating to Paypal account: jefflieu@fpga-ipcores.co</div>
                    <a href='cores/communication_controller/sgmii/index.html'>sgmii</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sgmii'>code</a>
                </td>
                <td>Aug 1, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller n done,FPGA provenWishBone Compliant: NoLicense: LGPLFeaturesAES3 / SPDIF compatible receiverlocks to any sample rate from 20kHz to 100kHz with 50MHz master clock and reg_width = 5locks to any sample rate from 20kHz to 200kHz with 100MHz master clock and reg_width = 6very compact (only 39 macrocells with reg_width = 5)Newss2009/08/31 - Fixed previous fix - removed redundant bbbr_shift_reg_proc.2009/08/30 - Fixed bug preventing the receiver to lock on input signal in case that shortest pulse length was longer then master clock/2^reg_width. Also simple testbench has been uploaded to SVN.Design i</div>
                    <a href='cores/communication_controller/simple_aes3-spdif_receiver/index.html'>simple aes3/spdif receiver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_simple_aes3-spdif_receiver'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller  provenWishBone Compliant: NoLicense:DescriptionSimple asynchronous serial controller (aka UART). Includes 4byte receive and a 4 byte  transmit FIFO (FIFO size can be easilyadjusted). External baud rate  generator (included). Very small.Features- Implemented in Verilog- Flow Control (CTS/RTS)- 1 start bit, 1 stop bit, NO parity- 4 byte receive FIFO- 4 byte transmit FIFO- Fully Synthesisable- 102 LUTs in a Spartan IIStatusThis core is fully functional and completed.It was verified in hardware in an XESS XVC800 FPGA prototypeboard with a Maxim RS232 line driver.this_ip_core_is_provided_by:     </div>
                    <a href='cores/communication_controller/simple_asynchronous_serial_controller/index.html'>simple asynchronous serial controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_simple_asynchronous_serial_controller'>code</a>
                </td>
                <td>Mar 30, 2006</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller sign done,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionThis core is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.Minimal UART coreNo hardware FIFONo modem control signals (just TX and RX)Fully synchronous designConfigurable baud rateMeant to interface with Milkymist CSR bus and an edge sensitive interrupt controller (like that of LatticeMico32)More informationCore documentationCSR bus specifications</div>
                    <a href='cores/communication_controller/simple_rs232_uart/index.html'>simple rs232 uart</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_simple_rs232_uart'>code</a>
                </td>
                <td>Aug 7, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller GA provenWishBone Compliant: NoLicense:DescriptionSimple PCM Interface. Allows to interface to such popular deviceslike TI DSPs (via McBSP bus) in PCM mode. Of course many moreapplications. Very small and simple core.Features- Implemented in Verilog- Frame Start position adjustable- full 16 bit frames- 1 Receive holding register- 1 Transmit holding Register- Fully Synthesisable- Can handle PCM streams at any rate, 128KHz to 100MHz.- 38 LUTs in a Spartan IIStatusThis core is fully functional and completed. It was tested ona XESS XCV800 board interfacing to a proprietary device witha TI DSP, exc</div>
                    <a href='cores/communication_controller/single_slot_pcm_interface/index.html'>single slot pcm interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_single_slot_pcm_interface'>code</a>
                </td>
                <td>Feb 10, 2004</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Bone Compliant: NoLicense:DescriptionThis project's aim is to provide the smart-card side of an ISO 7816-3 interface.Features- Detects reset and sends ATR (Answer to Reset).- Translates between the raw ISO7816-3 serial data and a Wishbone compliant format.- Provides examples modules that interpret commands sent over the interface.Status- A working prototype is ready.- No work is currently being done.- Current version available for download fromhttp://www.opencores.org/pdownloads.cgi/list/iso7816-3(the download tab).</div>
                    <a href='cores/communication_controller/smartcard_interface_iso7816-3/index.html'>smartcard interface iso7816-3</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_smartcard_interface_iso7816-3'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller one Compliant: YesLicense:DescriptionThe System Management Bus (SMBus) is a two-wire interface through which simple system and power management related chips can communicate with the rest of a system. SMBus provides a control bus for system and power management related tasks. The SMBus is a multi-master bus, meaning that more than one device capable of controlling the bus can be connected to it. This core is based on the SMBus 2.0 specification, and utilizes its address resolution protocol using an 128-bit unique device identifier (UDID).Features- SMBUS 2.0 Compliant- 128-bit UDID- Hardware pa</div>
                    <a href='cores/communication_controller/smbus_if/index.html'>smbus_if</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_smbus_if'>code</a>
                </td>
                <td>Jan 22, 2004</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: YesLicense: LGPLFeatures- SpaceWire CODEC- testbench and stimuli to cover the exception conditions described in the standard- WISHBONE wrapper (optional)- Triple Modulo Redundant (optional)- Error Detection and Correction for TX and RX FIFOs (optional)- makefile for simulation and synthesis (vmake utility)StatusTentative release of the following documentation:- Architectural Requirement Specification (ARS)- Architectural Verification Plan         (AVP)- Architectural Design Report             (ADR)- Architectural Verification Report       (AVR)In accordance with ECCS-Q-60-0</div>
                    <a href='cores/communication_controller/spacewire/index.html'>spacewire</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spacewire'>code</a>
                </td>
                <td>Oct 17, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:Design doneWishBone Compliant: NoLicense: GPLDescriptionSpaceWire Light is a SpaceWire encoder-decoder with FIFO interface.It is synthesizable for FPGA targets (up to 200 Mbit on Spartan-3).An optional AMBA bus interface can be used to implement the core inLEON3-based designs.OverviewThe goal is to provide a complete, reliable, fast implementationof a SpaceWire encoder-decoder according to ECSS-E-50-12C.The core is "light" in the sense that it does not provide additionalfeatures such as RMAP, routing etc.SpaceWire Light supports two application interfaces. One interfaceprovides FIFO-</div>
                    <a href='cores/communication_controller/spacewire_light/index.html'>spacewire light</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spacewire_light'>code</a>
                </td>
                <td>Nov 1, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller nfo:Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe SPDIF interface (Standard IEC958 "Digital audio interface") allows transmission of digital audio signals between devices in a digital format. The goal of this project is to allow a controller/cpu with Wishbone interface to transmit and receive digital audio.Features- Separate transmitter and receiver- Dual sample buffer architecture with configurable buffer size- Access to channel status and subframe bits- Supports both 16bit and 32bit data busStatus- SPDIF Interface V1.1 has been released.</div>
                    <a href='cores/communication_controller/spdif_interface/index.html'>spdif interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spdif_interface'>code</a>
                </td>
                <td>Oct 14, 2007</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ishBone Compliant: YesLicense:DescriptionSPI (Serial Peripheral Interface) is serial, synchronous, full duplex communication protocol. It is widely used as a board-level interface between different devices such as microcontrollers, DACs, ADCs and others.This core is SPI/Microwire compliant master serial communication controller with additional functionality.Features- Full duplex synchronous serial data transfer- Variable length of transfer word up to 32 bits- MSB or LSB first data transfer- Rx and Tx on both rising or falling edge of serial clock independently- 8 slave select lines- Fully stat</div>
                    <a href='cores/communication_controller/spi_controller_core/index.html'>spi controller core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_controller_core'>code</a>
                </td>
                <td>Jun 5, 2015</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ditional info:WishBone Compliant: NoLicense: LGPLDescriptionModified SPI Master Core by Simon Srot.  This core is designed for use with the Spatan 3E, 3A, and 3AN starter kits, for interfacing with the onboard Linear Technology Analog to Digital and Digital to Analog convertors.</div>
                    <a href='cores/communication_controller/spi_controller_for_ad-da_chips_on_s3e-a-an_starter/index.html'>spi controller for ad/da chips on s3e/a/an starter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_controller_for_ad-da_chips_on_s3e-a-an_starter'>code</a>
                </td>
                <td>Dec 13, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:Design done,FPGA provenWishBone Compliant: YesLicense:DescriptionEnhanced version of the Serial Peripheral Interface available on Motorola's MC68HC11 family of CPUs.Enhancements include a wider supported operating frequency range, 4deep read and write fifos, and programmable transfer count dependent interrupt generation.As with the SPI found in MC68HC11 processors the core features programmable clock phase (CPHA) and clock polarity (CPOL). The core features an 8bit wishbone interface.Very simple, very small.Features- Compatible with Motorola's SPI specifications- Enhanced Motorola MC68HC11 S</div>
                    <a href='cores/communication_controller/spi_core/index.html'>spi core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_core'>code</a>
                </td>
                <td>Jul 15, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionThis project implements a controller for standard SPI flash ROMs (e.g. ST M25Pxx, Atmel AT25Fxxxx, etc.).For a design using an (embedded) microcontroller it is often a requirement to store user or configuration information. For this purpose the configuration ROM of the FPGA is a first-choice candidate because it is already there and usually has some space left. By using the VHDL module introduced in this project the microcontroller firmware is greatly simplyfied by moving the complexity of accessing the</div>
                    <a href='cores/communication_controller/spi_flash_controller/index.html'>spi flash controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_flash_controller'>code</a>
                </td>
                <td>Jul 17, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller n doneWishBone Compliant: NoLicense: LGPLthis core represents an minimalistic SPI receiver for ADC like AD747x.one have:- tunable sequence len, loaded data slice of sequence,- shut-down short sequense generation- ability continued sequence mode - without frame entry/completing- ready output for locking received data- shifht clock output provide ability to build parallel vector receivers byadding needed shift registersSyntesis on QuartusII 8.1 Web for EP1C3 16bit sequense with 10 loaded bit ocupies 31 cells</div>
                    <a href='cores/communication_controller/spi_master_receiver_for_adc_ad747x/index.html'>spi master receiver for adc ad747x</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_master_receiver_for_adc_ad747x'>code</a>
                </td>
                <td>Jun 23, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDevelopment StatusPlease if you are using this core, report if the marked bugs (CPHA='1', bit alignment) are solved for your toolchain.You can send me e-mail toI have confirmation from people using Xilinx ISE 13.1, 12.4 and 12.1 with WebPack, Altium + ISE 12.3, Synopsys and Altera tools.I would like to know if the VHDL style used in this core works for your toolchain, and if not, what seems to be the problem.My goal is to find a description style that is as friendly as possible to synthesis tools.The scope screen</div>
                    <a href='cores/communication_controller/spi_master-slave_interface/index.html'>spi master/slave interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_master-slave_interface'>code</a>
                </td>
                <td>Jul 25, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller provenWishBone Compliant: NoLicense: LGPLDescriptionAn implementation of serial Linear Technologies LTC2624 Quad 12bit DAC using SPI 32bit data transfer method. The core is FPGA proven, works on Spartan-3E Starter Kit.If someone would like to improve the project (i.e. add WishBone support, etc), please contact project maintainers.</div>
                    <a href='cores/communication_controller/spi_serial_dac_interface/index.html'>spi serial dac interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_serial_dac_interface'>code</a>
                </td>
                <td>Aug 6, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Additional info:WishBone Compliant: NoLicense: LGPLDescriptionThis Project provides SPI Mode-3 Master &amp; Slave modules in Verilog HDL.The data width is 8 bits. It is synthesized for Xilinx Spartan 3E, &amp; can be clocked upto 225MHz. Maximum SPI Clock (sck) Frequency is 112MHz, which is derived from Main Clock. The scaling factors for SCK from master clock can be 2, 4, 8 &amp; 16, which can also be reduced further.SPI Master Module is coded in FSM (finite state machine)The slave module is designed simply like a shift register.The interface signals are SCLK (or SCK), MOSI, MISO and SS. SCK </div>
                    <a href='cores/communication_controller/spi_verilog_master_and_slave_modules/index.html'>spi verilog master and slave modules</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spi_verilog_master_and_slave_modules'>code</a>
                </td>
                <td>Mar 6, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller shBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/communication_controller/spigpio/index.html'>spigpio</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spigpio'>code</a>
                </td>
                <td>Dec 21, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: NoLicense: LGPLDescriptionspislave is a minimalist spislave IP core that provides the basic framework for the implementation of custom spislave devices. The core provides a means to write up to 256 8-bit registers. These registers can be connected to the users custom logic, thus implementing a simple control and status interface. A full Icarus Verilog test bench is available.Test it for yourself, using the free Icarus Verilog simulator and the free GTKWave wave form viewer.Download and install Icarus Verilog. -Download and install GTKWave.- Download the project files. - For</div>
                    <a href='cores/communication_controller/spislave/index.html'>spislave</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spislave'>code</a>
                </td>
                <td>Mar 3, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller esign done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project provides a full function SPI master interface. It provides for a FIFO buffered transmit and receive data path. Further, a ninth bit in the transmit data controls whether the SPI input data (MISO) is saved into the receive FIFO. This allows this SPI interface module to easily support serial memory devices, whose outputs during command and address loads are undefined, and devices like serial ADCs, whose output data is valid on each transfer cycle. In addition, the module automatically asserts and deasserts the slave</div>
                    <a href='cores/communication_controller/spixif/index.html'>spixif</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_spixif'>code</a>
                </td>
                <td>May 19, 2015</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/sport_interface/index.html'>sport interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_sport_interface'>code</a>
                </td>
                <td>Feb 17, 2015</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller esign done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project provides a slave interface for a Synchronous Serial Peripheral (SSP) as found on NXP LPC21xx microprocessors. The implementation provided here supports a 16-bit frame size. Of the 16 bits defined in the serial interface, the first three bits function as a register address, the fourth bit is a read/write control bit, and the remaining 12 bits function as read/write data.This format is used in several commercial products to interface a LPC2138/LPC2148, or other processor equipped with an SSP or SPI master interface,</div>
                    <a href='cores/communication_controller/ssp_slv/index.html'>ssp_slv</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ssp_slv'>code</a>
                </td>
                <td>Apr 26, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller Design done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project provides a full-function UART. The UART provides direct support for a two-wire or a four-wire RS-232 style full-duplex serial interface, but it also provides direct support for a half-duplex RS-485 serial interface. In the RS-232 mode, automatic flow control can be enabled, and the UART will assert RTS when data is available to transmit and wait for CTS to be returned before the transmitter is enabled. In the RS-485 mode, the drive enable of the RS-485 driver is asserted and deasserted automatically.In both opera</div>
                    <a href='cores/communication_controller/ssp_uart/index.html'>ssp_uart</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_ssp_uart'>code</a>
                </td>
                <td>Apr 26, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller  info:FPGA provenWishBone Compliant: NoLicense: GPLDescriptionA very simple project for controlling any standard 4 or 6 wire stepper motor.  Only difference between 4 and 6 wire mode is the MOSFET driver circuit (6 wire steppers are considerably simpler...)Features- Simple VHDL for beginners; well documented- NPL project file for immediate evaluation in Xilinx ISE/Webpack tools- Quickly get a stepper motor running for testing or prototyping- Questions/Comments:http://www.franks-development.comProject Contents- StepperMotor.npl, project file for Xilinx ISE/Webpack- StepperMotorDrive.vhd, source</div>
                    <a href='cores/communication_controller/stepper_motor_controller/index.html'>stepper motor controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_stepper_motor_controller'>code</a>
                </td>
                <td>Dec 17, 2005</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ditional info:WishBone Compliant: YesLicense: LGPLDescriptionRS232 Protocol 16550D uart (mostly supported)- language : systemVerilog IEEE 1800-2005 (Quaruts2-9.1sp1 Support)- scale : fpga cyclone3 800cell, &gt;50Mhz- bus : wishbone-TODO:Lin's automotive standards-&gt; subset of transport layer circuit</div>
                    <a href='cores/communication_controller/systemverilog_uart16550/index.html'>systemverilog uart16550</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_systemverilog_uart16550'>code</a>
                </td>
                <td>May 5, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :Design done,FPGA provenWishBone Compliant: NoLicense: OthersDescriptionTCP Socket is a TCP/IP stack implementation. The core acts as a server, allowing a remote client to establish a bidirectional TCP socket connection directly to logic within your FPGA.Easily add network connectivity to your FPGANo need for a soft CPUSmall footprint (less than 800 LUTs in Spartan 6)Free Open Source Solution (MIT license)Connect to your FPGA with a web browser or telnet clientTCP Socket is implemented in C, and is compiled into synthesisable Verilog using theChipsdevelopment environment (included). A precompi</div>
                    <a href='cores/communication_controller/tcp-ip_socket/index.html'>tcp/ip socket</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_tcp-ip_socket'>code</a>
                </td>
                <td>Sep 22, 2014</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller pliant: YesLicense:Features- 8 bit parallel backend interface- Needs external Framer- Supports E1 bit rate and time slots (32 time slots or 32 DS0 channels at bit rate 2.048Mbps)- Supports ST-Bus (Serial Telecom bus) interface.- Routes time slots to/from HDLC controller via the backend interface and software support or to/from memory.- Supports read for all or partial TDM slots from the ST-bus.- Supports write for all or partial TDM slots to ST-bus.- Supports two serial lines one input and one output.Mli&gt;9. It supports N&mdash;64 mode (i.e. it supports sampling (or writing) to N consecutive</div>
                    <a href='cores/communication_controller/tdm_controller/index.html'>tdm controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_tdm_controller'>code</a>
                </td>
                <td>Dec 5, 2001</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:WishBone Compliant: NoLicense:DescriptionThe TDM_Switch core is a non-blocking digital switch that has a capacity of 256 x 256 channels at 2.048 Mb/s. Some of the main features are: Processor Mode and input offset delay.Features- 256 x 256 channel non-blocking switching at 2.048 Mb/s- Accept 8 serial data streams of 2.048 Mb/s- Per-stream frame delay offset programming- Connection memory block programming- Microprocessor InterfaceStatusThis IP core is synthesized for Xilinx SPARTAN-II series FPGA&euro;&trade;s, fit at xc2s50-6tq144 device and the post place &amp; route simulation model simul</div>
                    <a href='cores/communication_controller/time_slot_interchange_digital_switch/index.html'>time slot interchange digital switch</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_time_slot_interchange_digital_switch'>code</a>
                </td>
                <td>Dec 19, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller sign done,FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionThis is an 8 bits SPI master controller. It features optionalprogrammable baud rate and SPI mode selection. Altera SPI doesn'tsupport programmable rate which is needed for MMC SPI, nor doesXilinx SPI.It is small. It combines transmit and receive buffer and remove unusedfunctions. It takes only 36 LEs for SPI flash controller, or 53 LEs forMMC SPI controller in an Altera CycoloneIII SOPC project. While AlteraSPI takes around 143 LEs. OpenCores SPI takes 857 LEs and simple SPItakes 171 LEs.It doesn't generate SS_n signal. Please</div>
                    <a href='cores/communication_controller/tiny_spi/index.html'>tiny spi</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_tiny_spi'>code</a>
                </td>
                <td>Jan 9, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ne Compliant: YesLicense:Descriptionuart16550 is a 16550 compatible (mostly) UART core.The bus interface is WISHBONE SoC bus Rev. B.Features all the standard options of the 16550 UART: FIFO based operation, interrupt requests and other.The datasheet can be downloaded from the CVS tree along with the source code.StatusAug 2001Core updated and some more bugs fixed. It is now being verified more thoroughly but it is mostly usable.27.05.2001Documentation and core code are updated.17.05.2001The core is finished unless more bugs are found.The test bench is very basic yet and is asking for your help </div>
                    <a href='cores/communication_controller/uart_16550_core/index.html'>uart 16550 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_uart_16550_core'>code</a>
                </td>
                <td>Oct 2, 2011</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller PGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionSimple uart core with wishbone slave interface and programmable baud rate generator, based on clock speed and desired baud rate</div>
                    <a href='cores/communication_controller/uart_block/index.html'>uart block</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_uart_block'>code</a>
                </td>
                <td>May 5, 2012</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ishBone Compliant: YesLicense: LGPLIntroductionTransmitter and receiver in FPGA for converting UART to/from audio fiber optics.Photo of an assembled board with annotationIt is wishbone compliant because using an UART , it can be added to a Wishbone UART and be of interest for a Wishbone implementer. This core is well tested.They is two versions:-Fixed baudrate (0 to 2.5Mbit/s) - a full set of 2 transmitter and 2 receiver fit in a single XC9572XL CPLD-variable baudrate 50Mhz/n*p where n between 20 to 100 fiber optic baudrate and p&gt;=1  baudrate divider. Fit 1x transmiter + rec</div>
                    <a href='cores/communication_controller/uart_to-from_fiber_optic/index.html'>uart to/from fiber optic</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_uart_to-from_fiber_optic'>code</a>
                </td>
                <td>Dec 24, 2013</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ional info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: BSDDescriptionHave you ever needed a fast and easy way to test your new FPGA board?You know you have all the interfaces but it will take time to finish the software or the verification just to start debugging.This core might be what you are looking for.The UART to Bus IP Core is a simple command parser that can be used to access an internal bus via a UART interface. The parser supports two modes of operation: text mode commands and binary mode commands. Text mode commands are designed to be used with a hyper te</div>
                    <a href='cores/communication_controller/uart_to_bus/index.html'>uart to bus</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_uart_to_bus'>code</a>
                </td>
                <td>Sep 11, 2013</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller WishBone Compliant: NoLicense: LGPLDescriptionThe UART to SPI IP Core include a simple command parser that can be used to access an internal bus of SPI via a UART interface.  This IP can be used understand the SPI transaction protocol. The internal bus is designed with address bus of 16 bits and data bus of 8 bits. The core implements a very basic UART transmit &amp; receive blocks which share a common baud rate generator and a command parser. The parser supports text mode of command parsing. Text mode commands are designed to be used with hyper terminal software and enable easy access to the </div>
                    <a href='cores/communication_controller/uart_to_spi/index.html'>uart to spi</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_uart_to_spi'>code</a>
                </td>
                <td>Jan 31, 2013</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller hBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/uart_with_plb_interface/index.html'>uart with plb interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_uart_with_plb_interface'>code</a>
                </td>
                <td>Jun 3, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller sign done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionImplements a 16550/16750 UART core.Features- Full synchronous design- Pin compatible to 16550/16750- Register compatible to 16550/16750- Baudrate generator with clock enable- Supports 5/6/7/8 bit characters- None/Even/Odd parity bit generation and detection- Supports 1/1.5/2 stop bit generation- None or 16/64 byte FIFO mode- Receiver FIFO trigger levels 1/4/8/14/16/32/56- Control lines RTS/CTS/DTR/DSR/DCD/RI/OUT1/OUT2- Automatic flow control with RTS/CTS- All interrupt sources/modesStatus- Test script creation done, should cove</div>
                    <a href='cores/communication_controller/uart16750/index.html'>uart16750</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_uart16750'>code</a>
                </td>
                <td>May 6, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller :WishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of a UDP/IP core! Area-optimized for direct PC-FPGA communication!An advanced/versatile version of the core is included in the PC-FPGA Communication Platform project!</div>
                    <a href='cores/communication_controller/udp-ip_core/index.html'>udp/ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_udp-ip_core'>code</a>
                </td>
                <td>Mar 7, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller  info:Design done,FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionA simple full speed USB device core with 4 endpoints.Comes with virtual COM port demo sw.More details to follow.</div>
                    <a href='cores/communication_controller/usb_device_core/index.html'>usb device core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_usb_device_core'>code</a>
                </td>
                <td>Mar 27, 2014</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller o:WishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/communication_controller/usb_to_uart/index.html'>usb to uart</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_usb_to_uart'>code</a>
                </td>
                <td>Feb 19, 2013</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller  info:WishBone Compliant: YesLicense: LGPLOverviewThis is a modular IO component. With this modular IP design tou can get multiple (by default up to 8) IO channels. Each channel has a RX and TX FIFO with depth 31 bytes. The FIFO is based on the Versatile FIFO also available from OpenCores. All IO channels have a common bus interface compatible with 16550 UART. This makes software integreation easierThis IP support many different types of IO16550 compatible UARTLED controlRGB LED controlRC5 compatible IR receiverOther can be added</div>
                    <a href='cores/communication_controller/versatile_io/index.html'>versatile io</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_versatile_io'>code</a>
                </td>
                <td>Apr 23, 2009</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller gn done,FPGA provenWishBone Compliant: NoLicense: OthersDescription=== What's "vSPI"? ===vSPI is a Verilog implementation of an SPI slave. Think of it as a very fast serial port. It can reliably transfer data at 27.9 mbps on an Atlys FPGA devkit (a Spartan-6 with a 100 MHz system clock).You can use it to send data between your FPGA/ASIC project and other devices, such as a desktop computer I'm using it to send data between a self-flying RC-helicopter and my PC. If all goes according to plan, I'll be able to see live video from the helicopter's camera on my PC. I'll also be able to inject test </div>
                    <a href='cores/communication_controller/vspi/index.html'>vspi</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_vspi'>code</a>
                </td>
                <td>Mar 26, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ne Compliant: YesLicense: LGPLDescriptionImplements a 16550/16750 UART. The UART core is fully based on another OpenCores project: UART_16750 by Sebastian Witt.Please find there the documentation regarding the Uart core.The interface is now compatible with a 8-bit WishBone bus.With GHDL simulator simply run:./ghdl_uart.batUsing any other simulator, before starting the simulation the following perl script must be run:uart_test_stim.pl &gt; filename.txtwhere filename.txt is the name selected in generic "stim_file" inside wb8_uart_transactor.vhd.A correct simulation should exit with an assertion </div>
                    <a href='cores/communication_controller/wb_uart/index.html'>wb_uart</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_wb_uart'>code</a>
                </td>
                <td>Feb 14, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller sign done,FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionWishbone to LPC (Low-Pin Count) Bridge, includes master and slave modules.  Supports 8-bit I/O Read and Write cycles, 8-bit Memory Read/Write cycles, DMA cycles, and up to 32-bit Firmware memory read/write cycles.  Serial IRQ support is also provided.None of this has been tested (yet) with a third-party LPC Peripheral or Host.Features- Compliant to Intel(r) Low Pin Count (LPC) Interface Specification Revision 1.1- Wishbone Slave to LPC Host Module- Memory Read and Write (1-byte)- I/O Read and Write (1-byte)- Firmware Memory Re</div>
                    <a href='cores/communication_controller/wishbone_lpc_host_and_peripheral_bridge/index.html'>wishbone lpc host and peripheral bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_wishbone_lpc_host_and_peripheral_bridge'>code</a>
                </td>
                <td>Jan 31, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller one,FPGA provenWishBone Compliant: YesLicense: BSDConceptOverviewIf your projects are like ours, you always need the capability to set configuration bits for internal components, or externally monitor the status of other components.  We have implemented this in many different ways across dozens of projects.  We hope Wrimm is the last time we re-develop this same functionality.Every new design needs a different set of registers.  Frequently improving an existing design requires adding or changing a register which also requires some level of re-development of the register logic.The goal of Wrimm</div>
                    <a href='cores/communication_controller/wishbone_register_bank_intercon_multi-master_multi/index.html'>wishbone register bank intercon multi-master multi</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_wishbone_register_bank_intercon_multi-master_multi'>code</a>
                </td>
                <td>Jul 27, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller al info:Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe Wishbone SD Card Controller IP Core is MMC/SD communication controller designed to beused in a System-on-Chip. The IP core provides a simple interface for any CPU with Wishbonebus. The communication between the MMC/SD card controller and MMC/SD card is performedaccording to the MMC/SD protocol.IntroductionThis core is based on the "sd card controller" project fromhttp://opencores.org/project,sdcard_mass_storage_controllerbut has been largely rewritten. A lot of effort has been putforth to make </div>
                    <a href='cores/communication_controller/wishbone_sd_card_controller/index.html'>wishbone sd card controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_wishbone_sd_card_controller'>code</a>
                </td>
                <td>Sep 10, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ional info:WishBone Compliant: NoLicense: LGPLDescriptionthis core work whit uart.it is used to communicate as a wishbone master, it also contains slaves.these slaves are made to be a bridge between wishbone bus and I/O modules.the slaves handle the wishbone signal , addresses etc.it can be modded to work for an 8 bit processor.instruction set based.</div>
                    <a href='cores/communication_controller/wishbone_uart_controller_8_bit/index.html'>wishbone uart controller 8 bit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_wishbone_uart_controller_8_bit'>code</a>
                </td>
                <td>May 27, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>communication controller ovenWishBone Compliant: NoLicense: LGPLOverviewYANU (Yet Another Niosii Uart) has been built from scratch with the efficiency in mind in term of CPU load. A complete uCLinux TTY driver has been developed.Its main feature is that it has a TX and and RX FIFO buffers with a predictive "event to interrupt" generation.This will lead to a lower CPU usage needs in high efficiency point to point communication links at high baud rates.It has a fractional prescaler so that almost any baud rate can be generated from any input clock frequency.It detects all the common asynchronous errors (Parity,Framing,O</div>
                    <a href='cores/communication_controller/yanu-uart_with_predictive_interrupt_events_on_rx-t/index.html'>yanu-uart with predictive interrupt events on rx/t</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/communication_controller_yanu-uart_with_predictive_interrupt_events_on_rx-t'>code</a>
                </td>
                <td>Oct 17, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>COPROCESSOR</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>coprocessor License:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  SeeConfluent.orgfor more info.Several cores are provided in Verilog, Vhdl, and C.  If you don't see the configuration you need, chances are we can easily generate it for you.The Reconfigurable Computing Array (RCA) is a platform for dynamic reconfigurable computing.  RCA consists of a fine-grained array of reconfigurable "square" logic tiles.  Similar to an FPGA CLB, a tile can be programmed to perform a</div>
                    <a href='cores/coprocessor/cf_reconfigurable_computing_array/index.html'>cf reconfigurable computing array</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/coprocessor_cf_reconfigurable_computing_array'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>coprocessor ant: NoLicense: LGPLDescriptionA fabric coprocessor module (FCM) for the PowerPC 405 CPU providing code execution timestamp, allowing to measure precisely CPUcode execution times.</div>
                    <a href='cores/coprocessor/cpu_code_execution_timestamp/index.html'>cpu code execution timestamp</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/coprocessor_cpu_code_execution_timestamp'>code</a>
                </td>
                <td>Jun 11, 2010</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>coprocessor : NoLicense:DescriptionThis is a single precision floating point unit. It is fully IEEE 754 compliant. It can currently perform Add/Sub,  Mul and Divide operations, as well as integer to floating point and floating point to integer conversions. It supports four rounding modes: Round to Nearest Even, Round to Zero, Round to +INF and Round to -INF.There is now also a separate FP compare unit. It is located in the fpu/fcmp directory.Motivation- A 100% IEEE 754 compliant Floating Point Unit- Usable by the OR1K CPU- Options to extend the core- Free !CompatibilityTo the best of my knowledge the FPU </div>
                    <a href='cores/coprocessor/floating_point_unit/index.html'>floating point unit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/coprocessor_floating_point_unit'>code</a>
                </td>
                <td>Sep 2, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>coprocessor t: YesLicense: LGPLDescriptionThe Xgate Co-processor Module, Xgate, is a 16 bit programmable RISC processor that is managed by a host CPU to reduce the host load in handling interrupts.  Because the Xgate is user programmable there is a great deal of user control in how to preprocess data from peripheral modules. The module may be configured as a simple DMA controller to organize data such that the host only deals with whole messages and not individual words or bytes. The Xgate may also deal with higher levels of messaging protocols than the peripheral hardware recognizes. Encryption algorithm</div>
                    <a href='cores/coprocessor/xgate/index.html'>xgate</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/coprocessor_xgate'>code</a>
                </td>
                <td>May 22, 2012</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>CRYPTO CORE</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core liant: NoLicense:DescriptionSimple AES (Rijndael) IP Core.I have tried to balance this implementation and to trade off size and performance. The goal was to be able to fit in to a low cost Xilinx Spartan series FPGA and still be as fast as possible.As one can see from the implementation results below, this goal has been achieved !Other Implementations of this standard with different key sizes (192 &amp; 256 bit) and performance attributes (like a fully pipelined ultra-high-speed version) are commercially available fromASICS.ws.Even though no official testing has been performed we</div>
                    <a href='cores/crypto_core/aes_rijndael_ip_core/index.html'>aes rijndael ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes_rijndael_ip_core'>code</a>
                </td>
                <td>Oct 23, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core WishBone Compliant: YesLicense:Features- SystemC and Verilog code is provided- Verified using TLM(Transaction Level Modelling Style)- Encoder and decoder in the same blockThis work is given by Universidad Rey Juan Carlos (Spain)www.gdhwsw.urjc.esStatus- 128 bits low area implementation uploaded- 192 bits low area implementation uploadedDescriptionHere you can find two different implementations of AES encryption algorithm:- A 128 bits AES algorithm focusing on very low area applications.- A 192 bits AES algorithm focusing on very low area applications.The 128 bits low area implementation takes </div>
                    <a href='cores/crypto_core/128-192_aes/index.html'>128/192 aes</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_128-192_aes'>code</a>
                </td>
                <td>Apr 9, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core Bone Compliant: NoLicense:DescriptionThis is a VHDL implementation of Triple-DES (pipelined) and DES cryptographic algorithms, as recommended by NIST.In our tests the core has been verified to comply with thehttp://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf(NIST FIPS 46-3) (DES)recommendation.This core is provided by:http://www.coretexsys.com(Coretex Systems, LLC)Features- Pipelined architecture.- VHDL source code.- Verified in hardware.- Small footprint (the numbers are for Xilinx Virtex 2 FPGA)- 1742 slices,- 302 IOBs,- no block RAMs,- 1 GCLK.- Fast processing (the numbers assume </div>
                    <a href='cores/crypto_core/3des_triple_des-des_vhdl/index.html'>3des triple des/des vhdl</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_3des_triple_des-des_vhdl'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core PGA proven,Specification doneWishBone Compliant: NoLicense: OthersDescriptionAES (Advanced Encryption Standard) is a specification published bythe American National Institute of Standards and Technology in 2001, as FIPS 197.[1]AES describes a symmetric-key algorithm, in which the same key is used forboth encrypting and decrypting the data. The block size is restricted to 128 bits.The key size can be 128, 192, or 256 bits. [1]AES operates on a 4&mdash;4 matrix of bytes, called the state. Some rounds of transformationconverts the plaintext into the final cipher-text. The number of rounds is six </div>
                    <a href='cores/crypto_core/aes/index.html'>aes</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes'>code</a>
                </td>
                <td>Jul 25, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core : NoLicense:DescriptionThe NIST has selected cipher Rijndael as AES on October 20, 2000 based on the combination security, performance, efficiency, ease of implementation and flexibility. The algorithm has been designed by Joan Daemen and Vincent Rijmen. Rijndael is a symmetric-key iterated block cipher, length of the block is 128 bits and length of the key can be specified to be 128, 192 bit, 256 bits.Status-encryption block(done)-decryption block(done)You can also download the pdf formathereCompabilityThe core complies to FIPS 197. This document can be downloaded here :FIPS 197</div>
                    <a href='cores/crypto_core/aes_rijndael/index.html'>aes rijndael</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes_rijndael'>code</a>
                </td>
                <td>Dec 4, 2002</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ne,Specification doneWishBone Compliant: NoLicense:Consecutive AES coreDescription of project..Features- AES encoder- 128/192/256 bit- AES decoder- 128/192/256 bitStatus- Key Expansion added- Encoder added- Decoder added- Documentation added</div>
                    <a href='cores/crypto_core/aes_core_modules/index.html'>aes core modules</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes_core_modules'>code</a>
                </td>
                <td>Nov 24, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ant: NoLicense: GPLDescriptionThree different implementations of the AES-128 (VHDL).</div>
                    <a href='cores/crypto_core/aes_cores_compact/index.html'>aes cores compact</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes_cores_compact'>code</a>
                </td>
                <td>Sep 29, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionWhile there are many AES cores around, this one is designed with LUT6 based FPGA architecture in mind from day one.The AES Decryption Core for FPGA implements the decryption portion of the AES (a.k.a. Rijndael) algorithm described in the FIPS-197 specification. Key lengths of 128 / 192 / 256 bits are supported, each with a separate instantiation wrapper. Since the core is designed to take advantage of LUT6 based FPGA architecture, it packs very well in those devices. The result is a peak throughput of over 3Gbps f</div>
                    <a href='cores/crypto_core/aes_decryption_core_for_fpga/index.html'>aes decryption core for fpga</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes_decryption_core_for_fpga'>code</a>
                </td>
                <td>May 7, 2015</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core  Compliant: NoLicense: LGPLDescriptionFour stage pipeline design working at 361.890MHz on Xilinx's 28nm Kintex 7 speed grade 3 FPGA device. Calculating 4 blocks parallely, encrypting up to 4.25 Gbits data per second (0.361Ghz* 4 stage pipe * 128 bits parallel / 44 cycles a block).</div>
                    <a href='cores/crypto_core/aes_encryption_all_keylength/index.html'>aes encryption all keylength</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes_encryption_all_keylength'>code</a>
                </td>
                <td>Aug 10, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core e,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe AES behavioral model is not an encryption/decryption core, but a tool to facilitate the verification of AES IPs in HDL simulation.Traditionally crypto IPs are verified with C/C++ model, but that requires you to either interface with an external language in your HDL testbench, or to modify your C/C++ model to export test vectors in a format acceptable by your testbench. Either way is time consuming. A native SystemVerilog model elimates the need to interface with an external language model. You can include this model in your </div>
                    <a href='cores/crypto_core/aes_systemverilog_behavioral_model/index.html'>aes systemverilog behavioral model</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes_systemverilog_behavioral_model'>code</a>
                </td>
                <td>Aug 12, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core l info:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe AES-128 pipelined cipher module uses AES algorithm which is a symmetric block cipher to encrypt (encipher) information. Encryption converts data to an unintelligible form called ciphertext .Here the AES algorithm is capable of using cryptographic keys of 128bit to do this conversion .This module is optimized for speed as it pipeline hardware to perform repeated sequence called round. This module synthesized  on Xilinx virtex 6 6vcx240tff784-2 board using ISE. Fuctional and gate level simulation w</div>
                    <a href='cores/crypto_core/aes-128_encryption/index.html'>aes-128 encryption</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes-128_encryption'>code</a>
                </td>
                <td>Apr 3, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core neWishBone Compliant: NoLicense: LGPLDescriptionThis Core implements the Advanced Encryption Standard (Rijndael Algorithm) according to the NIST standard as documented in FIPS-197.This AES core is developed for a key size of 128 bits and operates in ECB mode.The project contains a synthesizable RTL along with a Test Bench set up to verify the Core with test vectors as described in the FIPS document.General FeaturesInput and Key size of 128 bits.Operation in ECB mode.Performance adheres to FIPS-197.Core with high speed and low latency.RTL and TB in VHDL.StatusCore verified in simulation and upl</div>
                    <a href='cores/crypto_core/aes128/index.html'>aes128</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_aes128'>code</a>
                </td>
                <td>Mar 26, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core proven,Specification doneWishBone Compliant: NoLicense: BSDGeneral DescriptionI know there are plenty of AES (Rijndael) implementations around. I created my own anyway because I was unhappy with either the implementation language (I don't know Verilog and I think its an ugly language), the documentation or the performance/resource usage of the ones I found on the net.Here are the key parameters for this core:- strictly modular design- generics for the keylength (128,192,256 Bit) and enabling and disabling of decrypt datapath.- Avalon Interface tested with niosII (can be adapted to match wishbo</div>
                    <a href='cores/crypto_core/avalon_aes_ecb-core_128_192_256_bit/index.html'>avalon aes ecb-core 128 192 256 bit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_avalon_aes_ecb-core_128_192_256_bit'>code</a>
                </td>
                <td>Apr 20, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ant: NoLicense: GPLDescriptionBit-serial multiplication on the NIST B-163 curve.This implementation utilizes DSP481E blocks (Artix-7 FPGA).</div>
                    <a href='cores/crypto_core/b-163_ec_arithmetic/index.html'>b-163 ec arithmetic</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_b-163_ec_arithmetic'>code</a>
                </td>
                <td>Sep 28, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core Bone Compliant: NoLicense: LGPLDescriptionThe module is designed and optimized for Bitcoin hash work on FPGA or ASIC.</div>
                    <a href='cores/crypto_core/bitcoin_double_sha256/index.html'>bitcoin double sha256</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_bitcoin_double_sha256'>code</a>
                </td>
                <td>Nov 16, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core shBone Compliant: NoLicense:DescriptionThis IP core loads an unsorted, encrypted list of numbers from memory.  It then decrypts and sorts the list.Sorting is acheived using a high-throughput, heavily parametric mergesort core.Features- Highly parametric mergsort core- folds a single comparator across multiple fifos mapped onto SRAMs- compartor scheduler as a parameter- High speed PLB master core- achieves effective memory throughput of more than 400MB/s- uses configurable burst transfers to obtain high throughput- Pipelined AES coreStatusThis project is completed and development is closed.  It</div>
                    <a href='cores/crypto_core/bluespec_cryptosorter/index.html'>bluespec cryptosorter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_bluespec_cryptosorter'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core shBone Compliant: NoLicense:Features- Latency insensitive design- Should be portable to most bus architectures/platforms- Easily amenable to multi-clock domain extension- Support for long burst transfers- Configurable number of compression cores, compression core parallelismStatusThis project is under on-going development as we seek to explore and to improve the architecture of the implementation.We have demonstrated this architecture on the Xilink XUP board, on which we have obtained throughputs in excess of 233 MB/s for MD6-512</div>
                    <a href='cores/crypto_core/bluespec_md6/index.html'>bluespec md6</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_bluespec_md6'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core liant: NoLicense: GPLDescriptionBTCMiner is a Bitcoin Miner software which allows you to make money with your ZTEX USB-FPGA Module. Since these FPGA Boards contain an USB interface no additional hardware (like JTAG programmer) is required and low cost FPGA-clusters can be build using standard USB hubs.FeaturesSupported FPGA Boards:Spartan 6 USB-FPGA Module 1.15b with XC6SLX75: 90 MH/s (typical)Spartan 6 USB-FPGA Module 1.15d with XC6SLX150: 215 MH/s (typical)Spartan 6 USB-FPGA Module 1.15x with XC6SLX150: 215 MH/s (typical)Spartan 6 USB-FPGA Module 1.15y with four XC6SLX150: 860 MH/s (typical)</div>
                    <a href='cores/crypto_core/btcminer-open_source_bitcoin_miner/index.html'>btcminer-open source bitcoin miner</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_btcminer-open_source_bitcoin_miner'>code</a>
                </td>
                <td>Nov 28, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core mpliant: NoLicense: GPLDescriptionCamellia block cipher cores.FeaturesThe project is composed of different cores:Performance optimized: exploits pipelining in order to maximize the throughput. There are two different versions: the first accept only 128-bit key in order to minimize area and the second accept all key sizes.Area optimized: exploits looping in order to minimize area.StatusAll the cores are tested only at pre-synthesis stage and therefore cannot be considered stable.</div>
                    <a href='cores/crypto_core/camellia_cores/index.html'>camellia cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_camellia_cores'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core cation doneWishBone Compliant: NoLicense: LGPLDescription</div>
                    <a href='cores/crypto_core/compact_aes-ccm_core/index.html'>compact aes-ccm core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_compact_aes-ccm_core'>code</a>
                </td>
                <td>Apr 16, 2013</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core A proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe main goal on this research work was to provide a compact hardware CLEFIA structure, while still being able to achieve implementations with adequate throughput and performance, even on low cost devices. Two hardware The structure allow for the cipher and decipher computations with all three Key sizes specified in the algorithm, also the key generation.</div>
                    <a href='cores/crypto_core/compact_clefia_for_fpga/index.html'>compact clefia for fpga</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_compact_clefia_for_fpga'>code</a>
                </td>
                <td>Mar 17, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core e,FPGA provenWishBone Compliant: NoLicense: GPLCrypto-PAnA hardware implementation of Crypto-PAn[1]. The core makes use of a fully pipelined 128-bit AES (Rijndael) cipher engine as the underlying pseudorandom function, supports online key changes, and is capable of line rates exceeding gigabit ethernet.[1] Blake, A. and Nelson, R. 2008. Scalable Architecture for Prefix Preserving Anonymization of IP Addresses. In Proceedings of the 8th international Workshop on Embedded Computer Systems: Architectures, Modeling, and Simulation (Samos, Greece, July 21 - 24, 2008). M. Berekovi&Dagger;, N. Dimopo</div>
                    <a href='cores/crypto_core/crypto-pan/index.html'>crypto-pan</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_crypto-pan'>code</a>
                </td>
                <td>Feb 26, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core Compliant: NoLicense:csathis project implement a dvb common Scrambling AlgorithmFeatures-decrypt- only decrypt yetStatus- status1- status2</div>
                    <a href='cores/crypto_core/csa/index.html'>csa</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_csa'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core fication doneWishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of the classic DES block cipher (iterative architecture).</div>
                    <a href='cores/crypto_core/des_core/index.html'>des core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_des_core'>code</a>
                </td>
                <td>Aug 10, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core : NoLicense:DescriptionSimple DES/Triple-DES core.Motivation- A simple DES core- Fast and Small Version- Open SourceCompatibilityI believe that the core complies to NIST-800-17. However, there has been no formal third party verification.The official NIST specification can be downloaded here:800-17.pdf.For the Triple DES, the NIST reference is located here:FIP46-3.PerformanceTriple DES IP Core==============1) Area Optimized (CBC Mode)This is a sequential implementation and needs 48 cycles to complete  a full encryption/decryption cycle.- 0.18u UMC ASIC process: 5.5K gates, &gt; 16</div>
                    <a href='cores/crypto_core/des-triple_des_ip_cores/index.html'>des/triple des ip cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_des-triple_des_ip_cores'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ification doneWishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of the DESL block cipher (iterative architecture).</div>
                    <a href='cores/crypto_core/desl_core/index.html'>desl core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_desl_core'>code</a>
                </td>
                <td>Aug 10, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core cification doneWishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of the DESLX block cipher (iterative architecture).</div>
                    <a href='cores/crypto_core/deslx_core/index.html'>deslx core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_deslx_core'>code</a>
                </td>
                <td>Aug 10, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ification doneWishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of the DESX block cipher (iterative architecture).</div>
                    <a href='cores/crypto_core/desx_core/index.html'>desx core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_desx_core'>code</a>
                </td>
                <td>Aug 10, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core oven,FPGA provenWishBone Compliant: NoLicense: OthersDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/crypto_core/fast_aes-128_encryption_only_cores/index.html'>fast aes-128 encryption only cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_fast_aes-128_encryption_only_cores'>code</a>
                </td>
                <td>Nov 19, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core hBone Compliant: NoLicense: LGPLProject informationThe Modular Simultaneous Exponentiation core is a flexible hardware design to support modular simultaneous exponentiations in embedded systems. It is able to compute a double exponentiation as given bymodWhere     ,     and     are     -bit numbers and the exponents     and     are     -bit numbers. This operation is commonly used in anonymous credential and authentication cryptosystems like DSA, Idemix, etc.. For this reason the core is designed with the use of large base operands in mind (     =512, 1024, 1536 bit and more..). The ha</div>
                    <a href='cores/crypto_core/flexible_design_of_a_modular_simultaneous_exponent/index.html'>flexible design of a modular simultaneous exponent</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_flexible_design_of_a_modular_simultaneous_exponent'>code</a>
                </td>
                <td>Jul 6, 2013</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ification doneWishBone Compliant: NoLicense: OthersDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/crypto_core/galois_counter_mode_advanced_encryption_standard_g/index.html'>galois counter mode advanced encryption standard g</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_galois_counter_mode_advanced_encryption_standard_g'>code</a>
                </td>
                <td>Oct 16, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ishBone Compliant: NoLicense: BSDDescriptionThis is a implementation of the GOST 28147-89 - a Soviet and Russian government standard symmetric key block cipher.GOST 28147-89 has a 64-bit blocksize and 256-bit keysize.This implementation provide trade off size and performance. The goal was to be able to fit in to a low cost Xilinx Spartan series FPGA and still be as fast as possible. As one can see from the implementation results below, this goal has been achieved.Features- SystemVerilog RTL and TB code is provided- Implements both encryption and decryption in the same block- GOST 28147-89 algo</div>
                    <a href='cores/crypto_core/gost_28147-89/index.html'>gost 28147-89</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_gost_28147-89'>code</a>
                </td>
                <td>Jun 2, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core enWishBone Compliant: NoLicense: BSDDescriptionThe GOST block cipher, defined in standard GOST 28147-89, is a Soviet and Russian government standard symmetric key block cipher.Developed in the 1970s, the standard has been marked &euro;?Top Secret&euro;? and the downgraded to &euro;?Secret&euro;? in 1990. Shortly after the dissolution of the USSR, it was declassified and it was released to the public in 1994.wikipedia:http://en.wikipedia.org/wiki/GOST_%28block_cipher%29ModesCore supported ecb, ecb pipeline, cfb, mac.StatusCore was tested on a Altera Cyclone IIecb mode needs ~200 LUTsecb pipelin</div>
                    <a href='cores/crypto_core/gost28147-89/index.html'>gost28147-89</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_gost28147-89'>code</a>
                </td>
                <td>Mar 13, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core : NoLicense:Thanks to Mr. Thomas Blum (tblum@ece.wpi.edu) who provide his documentation about High Radix Montgomery modular exponentiation.DescriptionRSA Cryptosystem is widely used in information technology. It encryptsand decrypts messages using public key mechanism. The security of thiscryptosystem is based on the fact that it's very difficult to factorizelarge prime number.RSA algorithm was proposed in 1978 by Rivest, Shamir, andAdleman. Since 1978 its algorithm has changed to get an efficientcryptosystem. The high radix Montgomery algorithm is used to get thefaster calculation of modular </div>
                    <a href='cores/crypto_core/high_radix_montgomery_rsa_crypto_core/index.html'>high radix montgomery rsa crypto core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_high_radix_montgomery_rsa_crypto_core'>code</a>
                </td>
                <td>Oct 14, 2001</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core info:FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe High Throughput Low Area AES IP core implements the Rijndael encryption &amp; decryption algorithm used in the AES standard. The standalone core implements the basic ECB mode described in publication 800-38A by NIST. Other modes can be easily implemented using the core.The core implements both key expansion, required each time the key is changed (also after reset or power-up), and encryption/decryption algorithms. The core supports all three key lengths: 128, 192 &amp; 256 bits, selected by an input signal. En</div>
                    <a href='cores/crypto_core/high_throughput_and_low_area_aes_core/index.html'>high throughput and low area aes core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_high_throughput_and_low_area_aes_core'>code</a>
                </td>
                <td>Apr 1, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core iant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/crypto_core/hight_crypto_core/index.html'>hight crypto core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_hight_crypto_core'>code</a>
                </td>
                <td>Feb 20, 2015</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core License:DescriptionThe IDEA (International Data Encryption Algorithm) is a symmetric-key block cipher that can encrypts 64-bits plaintexts to 64-bit ciphertexts using a 128-bit key, used for secure communications.  It is also can do decryption with the same block using the same key.It consists of 8 computationally identical rounds and an output transformation. A 64-bit input block is divided into four 16-bit blocks which become the input blocks to the first round of the algorithm. In each of the eight total rounds, the four sub-blocks are XOR-ed, added, and multiplied with one another and with</div>
                    <a href='cores/crypto_core/idea_core/index.html'>idea core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_idea_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core one,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionA high throughput, 64-stage pipelined implementation of MD5 written in Verilog. Completes one hash per cycle.</div>
                    <a href='cores/crypto_core/md5_pipelined/index.html'>md5 pipelined</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_md5_pipelined'>code</a>
                </td>
                <td>Nov 27, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ne Compliant: NoLicense: BSDMini AESAdvanced Encryption Standard (AES) implementation with small area/resources utilization.Features- Encryption and Decryption unit in single core.Status- Currently only AES 128 version.- Not small enough.-http://www.opencores.org/pstats.cgi/view/mini_aes(Project status)</div>
                    <a href='cores/crypto_core/mini_aes/index.html'>mini aes</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_mini_aes'>code</a>
                </td>
                <td>Mar 19, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core liant: NoLicense: LGPLDescriptionModular multiplication and modular exponentiation play an important role in the mostof existing cryptographic systems. In fact these are time and hardware consumingoperations.Up to now there were proposed modular multiplication and modular exponentiationimplementations. One of them, Montgomery method, is very efficient especially ifmodulus is coprime integer with the word length in which it is operated, what isalways true in binary systemsIn this project Montgomery multiplier and Montgomery exponentiation blocks wasdeveloped. They were prepared for Spartan 3ES5</div>
                    <a href='cores/crypto_core/montgomery_modular_multiplier_and_exponentiator/index.html'>montgomery modular multiplier and exponentiator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_montgomery_modular_multiplier_and_exponentiator'>code</a>
                </td>
                <td>Feb 1, 2015</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core pecification doneWishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of the NOEKEON block cipher (iterative architecture).</div>
                    <a href='cores/crypto_core/noekeon_core_lightweight_block_cipher/index.html'>noekeon core lightweight block cipher</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_noekeon_core_lightweight_block_cipher'>code</a>
                </td>
                <td>Jul 27, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core oLicense: BSDDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/crypto_core/nugroho_free_crypto_cores/index.html'>nugroho free crypto cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_nugroho_free_crypto_cores'>code</a>
                </td>
                <td>Jun 27, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ompliant: NoLicense: BSDDescriptionNugroho Free Hash Cores (NFHC) currently support SHA-1, SHA-256, SHA-512 from FIPS-180 standard.</div>
                    <a href='cores/crypto_core/nugroho_free_hash_cores/index.html'>nugroho free hash cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_nugroho_free_hash_cores'>code</a>
                </td>
                <td>Jun 24, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core one Compliant: NoLicense: LGPLDescriptionThis is a fully pipelined implementation of the AES (rijndael) cipher with 128 bit keysize. Post place and route logs show the maximum speed to be 333 MHz when implemented on a Virtex-5 LX50T speed grade -1 FPGA with 45% LUT utilization and 27% register utilization. This comes out to a maximum throughput of ~ 42Gbps with an average of 1 encryption every cycle. The overall design has a latency of 30 clock cycles. A brief documentation is availablehere.This core has been verified to be correct by the NIST designed Known Answer Tests (KAT).P.S. If you down</div>
                    <a href='cores/crypto_core/pipelined_aes/index.html'>pipelined aes</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_pipelined_aes'>code</a>
                </td>
                <td>Jul 9, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionPresent is a lightweight block cipher dedicated to implement in Hardware. It was developed by Knudsen team.This cipher operates on the 64 bit text with use of 80 bit key. It uses S/P blocks and xor operations for encryption and key update through 32 rounds.In this project I created:- Present module dedicated to 32 bit Hardware (32 bit I/O and working under state machine) This is much for 'archive' state due to it was part of my students project, and it is not a 'pure' implementation of PRESENT.- "Pure" Present implementat</div>
                    <a href='cores/crypto_core/present-a_lightweight_block_cipher/index.html'>present-a lightweight block cipher</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_present-a_lightweight_block_cipher'>code</a>
                </td>
                <td>Sep 17, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core Bone Compliant: NoLicense: LGPLAbout Present Block CipherPresent is a lightweight block cipher designed for hardware constrained applications such as RFID tags and Smart Cards.This cipher is a true example of SPN ciphers. The block size is 64 bits, key size can be either 80 or 128 bits and the number of rounds is 31.The S-Box used in Present is a 4-bit to 4-bit S-Box which is invoked both in the substitution layer and in the key scheduling routine.This project entails an encryption-only implementation of Present cipher with key size equal to 80 bits.</div>
                    <a href='cores/crypto_core/present_cipher_encryption_core/index.html'>present cipher encryption core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_present_cipher_encryption_core'>code</a>
                </td>
                <td>Feb 18, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core PGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionRC4 PRBS (Generates the RC4 stream, then you have to XOR it with your data to crypt or decrypt it), takes 768 clocks to do key-expansion, then start outputting one-byte of random stream for every clock (output_read signals valid output in K). Based on RC4 implementation in wikipedia.</div>
                    <a href='cores/crypto_core/rc4_pseudo-random_stream_generator/index.html'>rc4 pseudo-random stream generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_rc4_pseudo-random_stream_generator'>code</a>
                </td>
                <td>Feb 26, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ishBone Compliant: NoLicense: GPLDescriptionThe Cryptographic Algorithm which is most widely used throughout the worldfor  protecting  information.  Cryptography  is  the  art  of  secret  writing,followed by the guarantee to authenticate data and messages and protectthe  systems  from valid attacks  .It  comprises of encryption and decryptionoperations each associated with a key which is supposed to be kept secret .We have  implement RC6 Algorithm. Which  is considered as a  secured andelegant  choice  for  AES  due  to  its  simplicity,  security,  performance  andefficiency.    RC6  support</div>
                    <a href='cores/crypto_core/rc6_cryptography/index.html'>rc6 cryptography</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_rc6_cryptography'>code</a>
                </td>
                <td>May 23, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core t: NoLicense: LGPLDescriptionThe project presents an open-source implementaion of the 512 bit RSA algorithm. This is a reduced version of a full FIPS Certified capable RSA Crypto-core.The full version supports all key sizes (512, 1024, 2048, 4096) and includes a complete testbench. It can reach more than 150 operations per second with a 1024 key size in a Spartan 6 FPGA and more than 200 in a Virtex 6.The core fits in a XC6SLX25T, which makes it a nice solution for mobile devices needing RSA acceleration.For more information contact jcastillo@opencores.orgPlease read carefully the documentatio</div>
                    <a href='cores/crypto_core/rsa/index.html'>rsa</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_rsa'>code</a>
                </td>
                <td>Oct 24, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core icense:DescriptionRSA ( Rivest Shamir Adleman )is crypthograph system that used to give a secret information  and digital signature . Its security based on Integer Factorization Problem (IFP). RSA uses an asymetric key.RSA was created by Rivest, Shamir, and Adleman in 1977.Every user have a pair of key, public key and private key.Public key  (e). You may choose any number for e with these requirements,1, where(n)= (p-1) (q-1)( p and q are first-rate),gcd (e,(n))=1(gcd= greatest common divisor).Private key (d).  d=(1/e) mod((n))Encyption (C) . C=M  mod(n),                              </div>
                    <a href='cores/crypto_core/rsa_processor/index.html'>rsa processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_rsa_processor'>code</a>
                </td>
                <td>Jun 28, 2012</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core NoLicense: GPLDescriptionRTEA (from Ruptor's TEA or Repaired TEA) - a symmetric block encryption algorithm used type "Feistel cipher", designed by Marcos el Ruptor, expansion TEA. Fixed some vulnerability in the algorithm. Like other variants of the algorithm TEA, the operation based on work with 32-bit numbers. The algorithm is much simpler and more productive XTEA, while, according to the authors and conducted by the developers according to statistical tests, is more resistant to cryptanalysishttp://defectoscopy.com/results.htmlKey size 128/256 bitsBlock size 64 bit</div>
                    <a href='cores/crypto_core/rtea_128-256/index.html'>rtea 128/256</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_rtea_128-256'>code</a>
                </td>
                <td>Oct 5, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core t: NoLicense: LGPLDescriptionSalsa20 stream cipher is built on a pseudorandom function based on 32-bit addition, bitwise addition (XOR) and rotation operations, which maps a 256-bit key, a 64-bit nonce (number used once), and a 64-bit stream position to a 512-bit output. It has advantage that the user can efficiently seek to any position in the output stream.ImplementationThe target device for implementation was Cyclone 3 from Altera (EP3C120). The motivation for these was to have nonce-based PRSequence generator - proof of concept. It was intended to be used with 120MHz clock. It finally can </div>
                    <a href='cores/crypto_core/salsa20streamcipher/index.html'>salsa20streamcipher</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_salsa20streamcipher'>code</a>
                </td>
                <td>Nov 13, 2012</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core  Compliant: NoLicense: BSDDescriptionRuns at 199.788MHz on Xilinx's 28nm Kintex 7 speed grade 3 device. Processing speed: 1.598 Gbits per second.</div>
                    <a href='cores/crypto_core/secure_hash_standard_256_bits/index.html'>secure hash standard 256 bits</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_secure_hash_standard_256_bits'>code</a>
                </td>
                <td>Apr 5, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core Bone Compliant: NoLicense: LGPLDescriptionThis is a collection of SHA(Secure Hash Algorithm) cores. These include SHA-1, SHA-2 algorithms.These cores are non-pipelined version of SHA, and have simple interfaces with the host side.Features- Support SHA-1(160), SHA-2(256/384/512)- Use a simple 32-bit I/O bus interface- High performance- Share hardware between different SHA processing- Can operate up to 200MHz at 0.18um Standard cell design- Written in VerilogHDLStatus- Initial releaseTODO-  Combine SHA1/SHA2 in a single core-  Make it smaller and faster!</div>
                    <a href='cores/crypto_core/sha_cores/index.html'>sha cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_sha_cores'>code</a>
                </td>
                <td>Dec 17, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core rovenWishBone Compliant: NoLicense: GPLDescriptionOrganization</div>
                    <a href='cores/crypto_core/sha-256/index.html'>sha-256</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_sha-256'>code</a>
                </td>
                <td>Apr 16, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core GA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of the SHA-256 hashing algorithm. This project includes .do files for performing a simulation on ModelSim.</div>
                    <a href='cores/crypto_core/sha-256_core/index.html'>sha-256 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_sha-256_core'>code</a>
                </td>
                <td>Aug 8, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ense:DescriptionVerilog Implementation of SHA1 Secure Hash AlgorithmStatus- Initial Release</div>
                    <a href='cores/crypto_core/sha1_secure_hash_algorithm/index.html'>sha1 secure hash algorithm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_sha1_secure_hash_algorithm'>code</a>
                </td>
                <td>Jul 8, 2004</td>
                <td>Unknow</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core proven,Specification doneWishBone Compliant: NoLicense: OthersDescriptionSHA-3, originally known as Keccak [1], is a cryptographic hash function selected as the winnerof the NIST hash function competition [2]. Because of the successful attacks on MD5, SHA-0 andtheoretical attacks on SHA-1, NIST perceived a need for an alternative, dissimilar cryptographichash, which became SHA-3 [3].NIST requires the candidate algorithms to support at least four different output lengths {224,256,384,512}with associated security levels [4]. &euro;&oelig;SHA-3 512&euro;?, in which output length is 512-bit,has th</div>
                    <a href='cores/crypto_core/sha3_keccak/index.html'>sha3 keccak</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_sha3_keccak'>code</a>
                </td>
                <td>May 27, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core WishBone Compliant: NoLicense: LGPLDescriptionThe code presented here implements the bit-serialized SIMON block cipher. Please check the following publication for the details of the implementation: A. Aysu, E. Gulcan, P. Schaumont, "SIMON Says, Break Area Records of Block Ciphers on FPGAs,", IEEE Embedded Systems Letters, 6(2):37-40, April 2014</div>
                    <a href='cores/crypto_core/simon_core/index.html'>simon core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_simon_core'>code</a>
                </td>
                <td>Aug 6, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core License:Description( I still have problem to upload files to cvs.opencores......)Features- feature1- feature1.1-feature1.2-feature2Status- status1- status2</div>
                    <a href='cores/crypto_core/simple_camellia_crypto_core/index.html'>simple camellia crypto core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_simple_camellia_crypto_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Unknow</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionSimple to use SHA-2 algorithmIs a VHDL implementation of SHA-224/256 core.Major project choice is semplicity: just feed core with message a chunk per clock and wait for result.Italian (sorry) documentation included.</div>
                    <a href='cores/crypto_core/simple_to_use_sha-2_algorithm/index.html'>simple to use sha-2 algorithm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_simple_to_use_sha-2_algorithm'>code</a>
                </td>
                <td>Sep 19, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core shBone Compliant: YesLicense:DescriptionSystemC DES is a implementation of the DES algorithm in SystemC focusing on low area applications.Implements the encoder and decoder in the same block.It was fully verified using TLM (Transaction Level Modelling Style) defined in the SystemC Verification Library.Verilog translation for synthesis is also provided.The core was tested on a Virtex2 FPGA succesfully.This work is given by Universidad Rey Juan Carlos (Spain)www.gdhwsw.urjc.esFeatures- SystemC and Verilog code are provided- Verified using TLM(Transaction Level Modelling Style)- Encoder and decod</div>
                    <a href='cores/crypto_core/systemc-verilog_des/index.html'>systemc/verilog des</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_systemc-verilog_des'>code</a>
                </td>
                <td>Dec 1, 2011</td>
                <td>Other</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core shBone Compliant: NoLicense: LGPLFeatures- Implements the MD5 standard- It doesnt make the block padding, you must input the 128 bits blocks padded and in little endian mode- The output is given in little endianStatus- DoneDescriptionA SystemC/Verilog synthesizable MD5 hash core.This work is given by Universidad Rey Juan Carlos (Spain)www.gdhwsw.urjc.es</div>
                    <a href='cores/crypto_core/systemc-verilog_md5/index.html'>systemc/verilog md5</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_systemc-verilog_md5'>code</a>
                </td>
                <td>Apr 9, 2010</td>
                <td>Other</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ompliant: NoLicense: LGPLDescriptionThis project has been MOVED to bitbucket:https://bitbucket.org/vahidi/grain</div>
                    <a href='cores/crypto_core/the_grain_stream_cipher/index.html'>the grain stream cipher</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_the_grain_stream_cipher'>code</a>
                </td>
                <td>Jun 21, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core oneWishBone Compliant: NoLicense: LGPLDescription</div>
                    <a href='cores/crypto_core/three_compact_implementations_of_aes_encryption/index.html'>three compact implementations of aes encryption</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_three_compact_implementations_of_aes_encryption'>code</a>
                </td>
                <td>Apr 16, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ne Compliant: NoLicense: GPLDescriptionVHDL implementation of the twofish cipher for 128,192 and 256 bit keys.The implementation is in library-like form; All needed components up to, including the round/key schedule circuits are implemented, giving the flexibility to be combined in different architectures (iterative, rolled out/pipelined etc). Manual in English is included with more details about how to use the components and/or how to optimize some of them. All testbenches are provided (tables, variable key/text, ECB/CBC monte carlo) for 128, 192  and 256 bit key sizes, along with their respe</div>
                    <a href='cores/crypto_core/twofish_128-192-256/index.html'>twofish 128/192/256</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_twofish_128-192-256'>code</a>
                </td>
                <td>May 8, 2006</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core : NoLicense:DescriptionTwofish is a 128-bit block cipher that can accept variable key length 128,192 and 256 bit. In this project we just use key length128 bit. Twofish is fundamental built by F-function, rotate-left one bit, rotate-right one bit, and XOR.The cipher has 16 round F-function . F-function is made up by four key-dependent 8-by-8-bit S-box, a fixed 4-by-4 maximum distance separable matrix over GF(2^8), a pseudo-Hadamard transform,  bitwise rotation, and key scedule.As can be seen from figure 1, input will be latched first into a register and then separated into four word. The four </div>
                    <a href='cores/crypto_core/twofish_core/index.html'>twofish core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_twofish_core'>code</a>
                </td>
                <td>Oct 17, 2002</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ification doneWishBone Compliant: NoLicense: GPLDescriptionVHDL implementation of the XTEA block cipher (iterative architecture).</div>
                    <a href='cores/crypto_core/xtea_core/index.html'>xtea core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_xtea_core'>code</a>
                </td>
                <td>Jul 27, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>crypto core ne Compliant: NoLicense: LGPLDescriptionThis is a Verilog implementation of theXTEA block cipher. It works on two 32-bit blocks of data at a time with a 128-bit key.A proper OpenCores specification for this unit will be written at some point.Wishbonecompliance is also on the TODO list.This implementation was adapted from the public domain C release of the algorithm from David Wheeler and Roger Needham byDavid Johnson. It is licensed under the GNU Lesser General Public License.Features- a very small, efficient implementation- fast- secure- what more do you need?Current Stable ReleaseThe</div>
                    <a href='cores/crypto_core/xtea_crypto_core/index.html'>xtea crypto core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/crypto_core_xtea_crypto_core'>code</a>
                </td>
                <td>Jul 21, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>DSP CORE</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core doneWishBone Compliant: NoLicense: GPLAdaptive LMS EqualizerIn communication systems channel poses an important role. channels can convolve many different kind of distortions to our information. In perticular wireless channels multipath distortion is sevear.and more sevear is such distortion is random.To handle this, multipath affected channels require Equalizers at receaver end.such equalizer uses different learning Algorithms for identifying channels continuously.This project is VHDL implementation of LMS learning algorithm with pipelined architecture. so this implementation can work with hi</div>
                    <a href='cores/dsp_core/adaptive_lms_equalizer/index.html'>adaptive lms equalizer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_adaptive_lms_equalizer'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core WishBone Compliant: NoLicense: LGPLDescriptionThe circuits found here implement digital leapfrog filters as described in http://en.wikibooks.org/wiki/Signal_Processing/Digital_Filters     &gt;. All filters are of lowpass type. They are optimised in terms of area.This kind of filter structure is the digital counterpart of an analog lumped-elements ladder filter. It simulates the functioning of an all-pole lowpass filter under the assumption of a large oversampling. The circuit implements the integral relations between voltages and currents of the capacitors and the inductances with the help of</div>
                    <a href='cores/dsp_core/all-pole_iir_filters/index.html'>all-pole iir filters</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_all-pole_iir_filters'>code</a>
                </td>
                <td>Jul 20, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core ense:Specifications- IIR filter with two poles and two zeros- Data width set by user- Coefficient width set by user up to 16 bits- Wishbone interface for read and write of filter coefficient registers- Multiple filters can be combined to form filters with more than two poles and zerosDescriptionThe difference equation for the biquad filter is:y[n] = b10*x[n] + b11*x[n-1] + b12*x[n-2] + a11*y[n-1] + a12*y[n-2]This equation is implemented as shown below:IMAGE: bquad_blk.gifFILE: bquad_blk.gifDESCRIPTION:SynthesisSynthesized with Synopsys FPGA Express version 2000.11-FE3.5.If you use this core pl</div>
                    <a href='cores/dsp_core/biquad_iir_filter_core/index.html'>biquad iir filter core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_biquad_iir_filter_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core e,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionCanny edge detector with a 9x9 mask (gradient + gaussian filtering with sigma = sqrt(2)). Able to produce a throughput of 1 pixel per clock cycle. Succesfully implemented on a Virtex4 up to 300Mhz clock frequency.</div>
                    <a href='cores/dsp_core/canny_edge_detector/index.html'>canny edge detector</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_canny_edge_detector'>code</a>
                </td>
                <td>Oct 29, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core ne Compliant: NoLicense: LGPLDescriptionFIR filter- architecture written with pure verilog- parameterizable in verilog code- cascaded - processing is paralleled- data and coefficients stored in RAM - suitable for long pulse response FIR and limited registers count- complex data- fixed point* load coefficient from input data as option - for echo/sonar/radar/etc processingFPGA resources usingAltera Cyclone IV E EP4CE22E22C8Parameters of filterInput data width14 b, 2 channelsPulse response length2048 samplesCell size1024 (2 cells for 2048 samples used)Output data width28 b, 2 channelsResources us</div>
                    <a href='cores/dsp_core/cascaded_fir_filter/index.html'>cascaded fir filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_cascaded_fir_filter'>code</a>
                </td>
                <td>Jun 16, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core ense:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  SeeConfluentfor more info.Finite impulse response (FIR) filters are common in DSP applications and consist of a delay bank (filter taps) and a sum-of-products.FeaturesThe filter architecture consists of a delay bank and a pipelined sum-of-products network.  All arithmetics are lossless -- multipliers produce precision with the sum of the operands and each adder extends precision by 1 bit.The filter has a synchr</div>
                    <a href='cores/dsp_core/cf_fir_filter/index.html'>cf fir filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_cf_fir_filter'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core oLicense: GPLDescriptionThis is a structural model for cascaded integrator comb (CIC) decimation filters. The filter consists of integrator, downsampler and comb stages. Each block is developed in behavioral manner, however, the top-level is developed in structural hierarchal manner. A test-bench is included for each single block and for the top-level entity as well.</div>
                    <a href='cores/dsp_core/cic_decimation_filter/index.html'>cic decimation filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_cic_decimation_filter'>code</a>
                </td>
                <td>Jun 8, 2012</td>
                <td>SystemC</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core rovenWishBone Compliant: NoLicense: LGPLDescriptionCascaded integrator-comb (CIC) digital filters are computationally efficient implementations of narrowband lowpass filters and are often embedded in hardware implementations of decimation and interpolation in modern communications systems.NB: core is written in SystemVerilog.</div>
                    <a href='cores/dsp_core/cic-filter_core/index.html'>cic-filter core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_cic-filter_core'>code</a>
                </td>
                <td>Nov 4, 2014</td>
                <td>Other</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core  NoLicense: GPL</div>
                    <a href='cores/dsp_core/configurable_high_speed_viterbi_decoder/index.html'>configurable high speed viterbi decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_configurable_high_speed_viterbi_decoder'>code</a>
                </td>
                <td>Dec 2, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThe DDS IP core (dds_synthesizer) is a implementation of a direct digital frequency synthesizer (DDS) (also called number controlled oscillator, NCO) which produces a sinewave at the output with a specified frequency and phase (adjustable at runtime).Only one quater of the sinewave is stored in the LUT, the rest is computed by simple operations (negating, subtraction), resulting in a reduced memory requirement.The resolution of the frequency tuning word (FTW), the phase and the amplitude defined seperately. Several precomputed lo</div>
                    <a href='cores/dsp_core/dds_synthesizer/index.html'>dds synthesizer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_dds_synthesizer'>code</a>
                </td>
                <td>Apr 3, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core GA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionThe goal of this project is to create an IP core for an FFT that runs, in a pipelined fashion, at two samples per clock.  A C++ program will generate the Verilog files, allowing the FFT to be of an arbitrary length--subject only to the capability of the FPGA used to implement the FFT.One of my goals is to create an FFT core that can be used with open source and third party Verilog simulation facilities, such as Verilator.  This would be difficult with a proprietary IP core.For those who might be wondering, why would I nee</div>
                    <a href='cores/dsp_core/double_clocked_fft_core/index.html'>double clocked fft core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_double_clocked_fft_core'>code</a>
                </td>
                <td>Jun 2, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core Specification doneWishBone Compliant: YesLicense: LGPLDescriptionWDSP project includes three System on Chip (SoC) cores, which implement the Digital Signal Processing (DSP) functions: Finite Impulse Response (FIR) filter, Infinite Impulse Response (IIR) filter and Fast Fourier Transform (FFT). The FIR filter core is based on the transpose realization form, the IIR filter core is based on the Second Order Sections (SOS) architecture and the FFT core is based on the Radix 2^2 Single Delay Feedback (R2^2SDF) architecture. The three cores are compatible with the Wishbone SoC bus and they were desc</div>
                    <a href='cores/dsp_core/dsp_wishbone_compatible_cores/index.html'>dsp wishbone compatible cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_dsp_wishbone_compatible_cores'>code</a>
                </td>
                <td>Mar 17, 2014</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core pliant: NoLicense:DescriptionThe RTL computes Fast Hadamhard Transform of 8-bit input data. The code has been developed using standard FHT algorithm using matrix addition. The code has been functionally verified and also synthesized for Xilinx FPGA.Features- feature1- feature1.1-feature1.2-feature2Status- status1- status2</div>
                    <a href='cores/dsp_core/fast_hadamhard_transforms/index.html'>fast hadamhard transforms</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_fast_hadamhard_transforms'>code</a>
                </td>
                <td>Dec 18, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core liant: NoLicense: LGPLDescriptionFFT-based FIR Filter is a unit to perform the finite impulse responce filter based on the Fast Fourier Transform (FFT). It performs the convolution of the unlimited signal sequence with the synthesized impulse responce of the length of Ni=N/2 samples, where N = 64, 128, 256, 512, 1024. The data and coefficient widths are tunable in the range 8 to 18.Main Features:The filtering algorithm is the sectioned convolution with accumulating based on N-point radix-2 FFT, where N = 64, 128, 256, 512, 1024One complex signal channel or two parallel real signal channels.Fil</div>
                    <a href='cores/dsp_core/fft-based_fir_filter/index.html'>fft-based fir filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_fft-based_fir_filter'>code</a>
                </td>
                <td>Apr 27, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core provenWishBone Compliant: NoLicense: OthersDescriptionVHDL Parametrizable FIR FilterImplementation:-Direct Form II-Real format entry for normalized coeficients-Internal fixed-point implementation (configurable resolution)Simulation:-Matlab file (.m)-VHDL testbench and macro (.do) for simulation===========================================================EXAMPLE===========================================================duv_FIR_low_area : ENTITY WORK.FIR_low_areaGENERIC MAP(..data_length...=&gt;..12,....-- input/output length..data_signed...=&gt;..true,..-- input/output type (signed or unsigned)..</div>
                    <a href='cores/dsp_core/filtro_fir/index.html'>filtro_fir</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_filtro_fir'>code</a>
                </td>
                <td>Apr 13, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core  done,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionVHDL core generatorFIRGEN Project generates optimized VHDL codes for FIR Filters and Multiplier arraysusing "Nonrecursive Signed Common Subexpression Algorithm".program writen on C++--------------------------firgen [OPTION..]Available options are :-w Input Data Width-m Generate Only Multipliers Array-a Generate Asynchronus Multipliers array (no CLK signal)-e Use CLK_EN input-c filter coefficients, coma separated-o Output File Name-? HelpExample For Use:----------------FirGen -w 16 -c 1,2,3,4,5 -o my_firthis comman</div>
                    <a href='cores/dsp_core/firgen-multgen/index.html'>firgen/multgen</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_firgen-multgen'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core NoLicense: LGPLDescriptionThis project is the special floating-point Fast Fourier transform realization. Floating point representation has only 24 bits and takes into account the features of the Xilinx FPGA devices. FP24 is the reduced format of IEE 754. The word in FP24 format has 16-bit fraction, 1-bit sign and 7-bit exponent. It gives the best resource usage of the FPGA such as DSP48E1 and RAMB18E1. There is a word format:A = 2^(EXP(A)) * (-1)^SIGN(A) * FRAC(A), whereEXP(A) - 7-bit exponent (0-127),SING(A) - 1-bit sign (0 - positive, 1 - negative),FRAC(A) - 16-bit fraction (0-13071).Some sp</div>
                    <a href='cores/dsp_core/floating-point_fft-ifft/index.html'>floating-point fft/ifft</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_floating-point_fft-ifft'>code</a>
                </td>
                <td>Apr 10, 2015</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core icense: GPLDescriptionThis is an elementary generic structural VHDL code for FIR digital filters in transposed-form and direct-form implementations.This project covers a wide spectrum of design aspects, in particular design and both functional and formal verification.The project is developed in VHDL and modeled in SystemC. The SystemC model is used for functional and formal verification.TCL scripts for GHDL and SystemC is included within the project files.This code could be considered for VHDL classes or DSP classes for amateurs or beginners.The developed code was synthesized for FPGA and ASIC</div>
                    <a href='cores/dsp_core/g-fir_tf-df/index.html'>g-fir tf/df</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_g-fir_tf-df'>code</a>
                </td>
                <td>Apr 13, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core iant: NoLicense: LGPLDescriptionGeneric FIR filter. Builds optimized filter according to number of multipliers, supports serial or parallel architecture. Supports delays in input. Builds Verilog FIR filter according to input parameters: multiplier number, filter order, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/dsp_core/generic_fir_filter_1/index.html'>generic fir filter 1</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_generic_fir_filter_1'>code</a>
                </td>
                <td>Jun 18, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core ne Compliant: YesLicense: LGPLDescriptionThis FIR filter is very generic and flexible. It has been tested working on an FPGA, though the existing version does not yet have a Wishbone control interface. I will be adding one to it soon. Stay tuned!</div>
                    <a href='cores/dsp_core/generic_fir_filter_2/index.html'>generic fir filter 2</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_generic_fir_filter_2'>code</a>
                </td>
                <td>Mar 4, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core one,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThe Hilbert Transform is an important component in communication systems, e.g. for single sideband modulation/demodulation, amplitude and phase detection, etc. It can be formulated as filtering operation which makes it possible to approximate the Hilbert Transform with a digital filter. Due to the non-causal and infinite impulse response of that filter, it is not that easy to get a good approximation with low hardware resource usage. Therefore, different filters with different complexities have been implemented.The detailed discuss</div>
                    <a href='cores/dsp_core/hilbert_transformer/index.html'>hilbert transformer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_hilbert_transformer'>code</a>
                </td>
                <td>Apr 3, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core oLicense: GPLDescriptionThis is a structural modeling for IIR digital filters. It is developed in SystemC, however, it includes Matlab script and Simulink model as well. The developed code describes several structures for IIR filters, such as Transposed-form I, Transposed-form II, and Direct-form II. The implemented structures are well defined in the attached manual. Further, the detailed implementation is illustrated on the later file.</div>
                    <a href='cores/dsp_core/iir/index.html'>iir</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_iir'>code</a>
                </td>
                <td>Jul 20, 2012</td>
                <td>SystemC</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core done,Specification doneWishBone Compliant: NoLicense: BSDDescriptionThe IMA ADPCM audio compression algorithm belongs to the Adaptive Differential Pulse Code Modulation type algorithms. The algorithm is based on a simple adaptive quantization of the difference between the input and a predictor. Each 16-bit input sample is converted to a 4-bit coded information which yields a compression ratio of . We will not go through detailed description of the algorithm in this document. There are many online pages describing the algorithm, just Google &euro;&oelig;IMA ADPCM&euro;?.The main advantage of th</div>
                    <a href='cores/dsp_core/ima_adpcm_encdoer_and_decoder/index.html'>ima adpcm encdoer and decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_ima_adpcm_encdoer_and_decoder'>code</a>
                </td>
                <td>Dec 12, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core t: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/dsp_core/iq_phase_and_gain_correction/index.html'>iq phase and gain correction</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_iq_phase_and_gain_correction'>code</a>
                </td>
                <td>Mar 6, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core NoLicense:DescriptionThis project was undertaken to produce a low power FIR filter for inclusion in a VHDL target library. The design was completed using OrCAD's Capture CIS, from this the VHDL code has been extracted. This method has allowed complete testing of the system.The power consumption of various arithmetic architectures has been investigated, and the results have been provided in the intial report (FIRLowPowerConsiderations.doc). These results have enabled the correct power/performance optimization for the FIR filter design.The design was produced at the gate level, enabling low-powe</div>
                    <a href='cores/dsp_core/low_power_fir_filter/index.html'>low power fir filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_low_power_fir_filter'>code</a>
                </td>
                <td>Jan 28, 2012</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core iant: NoLicense: LGPLDescriptionLow-Pass IIR Filter IP core is a unit to perform the Infinite Impulse Responce (IIR) low pass filter which pass frequency is tuned dynamicallyMain Features:Dynamically tuned passband cutoff frequency in the range of 0.1 to 0.4 of the sampling frequency. The frequency is set by the 12-bit code with the linear scale.using 8-staged wave digital filter scheme of the 33-d order provides both sharp frequency responce &euro;&ldquo; up to 100 db/ octave - and high stopband ripple &euro;&ldquo; up to 80 db. Besides the passband ripple not succedes -2,5%, or &euro;&ldquo;</div>
                    <a href='cores/dsp_core/low-pass_iir_filter/index.html'>low-pass iir filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_low-pass_iir_filter'>code</a>
                </td>
                <td>Feb 2, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core Bone Compliant: NoLicense: GPLDescriptionThis core is a straight forward implementation of a Numerically Controlled Oscillator (NCO) - also referred to as a Direct Digital Synthesizer (DDS).  In addition to generating the standard SIN/COS output waveforms, it also generates Square and Sawtooth outputs with very little extra resource.  NCOs form an essential component in many Digital Comms applications - especially in digital modulation, up/down conversion and the generation of complex signals.  This core is also great for test-benches as it provides a simple way to generate input stimuli for F</div>
                    <a href='cores/dsp_core/nco-periodic_waveform_generator/index.html'>nco/periodic waveform generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_nco-periodic_waveform_generator'>code</a>
                </td>
                <td>Jul 26, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core e,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe PID controller IP core performs digital proportional&euro;&ldquo;integral&euro;&ldquo;derivative controller (PID controller) algorithm. The algorithm first calculates the error between a measured value (PV) and its ideal value (SP), then use the error as an argument to calculate the manipulate value(MV). The MV will adjust the process to minimize the error. It can be used to calculate duty cycle for PWM (Pulse Width Modulation).Features&euro; 16-bit signed coefficient and data input: Kp, Ki, Kd, SP and PV.&euro;</div>
                    <a href='cores/dsp_core/pid_controller/index.html'>pid controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_pid_controller'>code</a>
                </td>
                <td>Feb 3, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core  NoLicense: LGPLDescriptionDCT soft core is the unit to perform the Discrete Cosine Transform (DCT). It performs twodimensional 8 by 8 point DCT for the period of 64 clock cycles in pipelined mode.Main Features:more than 300 MHz sampling frequency, 64-cycle calculation period,approximately 330 CLBs and 4 DSP48E in Virtex-5 device,2 DSP48E when the scaled output data mode is used,8-bit input data,11-bit coefficients,12 &euro;&ldquo; bit results,pipelined mode,latent delay from input to output is 132 clock cycles,structure optimized for Xilinx Virtex, Spartan FPGA devices.Please, contact us if y</div>
                    <a href='cores/dsp_core/pipelined_dct-idct/index.html'>pipelined dct/idct</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_pipelined_dct-idct'>code</a>
                </td>
                <td>Oct 10, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core e Compliant: NoLicense: LGPLDescriptionPipelined FFT/IFFT 128 points IP core is a unit to perform the Fast Fourier Transform (FFT). It performs one dimensional 128 &euro;&ldquo; complex point FFT. The data and coefficient widths are adjustable in the range 8 to 16.Main Features:128 -point radix-8 FFTForward and inverse FFT.Pipelined mode operation, each result is outputted in one clock cycle, the latent delay from input to output is equal to 310 clock cycles (440 clock cycles when the direct output data order), simultaneous loading/downloading supportedInput data, output data, and coefficient </div>
                    <a href='cores/dsp_core/pipelined_fft-ifft_128_points_processor/index.html'>pipelined fft/ifft 128 points processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_pipelined_fft-ifft_128_points_processor'>code</a>
                </td>
                <td>Feb 2, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core e Compliant: NoLicense: LGPLDescriptionPipelined FFT/IFFT 256 points IP core is a unit to perform the Fast Fourier Transform (FFT). It performs one dimensional 256 &euro;&ldquo; complex point FFT. The data and coefficient widths are adjustable in the range 8 to 16.Main Features:256 -point radix-8 FFTForward and inverse FFT.Pipelined mode operation, each result is outputted in one clock cycle, the latent delay from input to output is equal to 580 clock cycles (839 clock cycles when the direct output data order), simultaneous loading/downloading supportedInput data, output data, and coefficient </div>
                    <a href='cores/dsp_core/pipelined_fft-ifft_256_points_processor/index.html'>pipelined fft/ifft 256 points processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_pipelined_fft-ifft_256_points_processor'>code</a>
                </td>
                <td>Jul 30, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core  Compliant: NoLicense: LGPLDescriptionPipelined FFT/IFFT 64 points IP core is a unit to perform the Fast Fourier Transform (FFT). It performs one dimensional 64 &euro;&ldquo; complex point FFT. The data and coefficient widths are adjustable in the range 8 to 16.Main Features:64 -point radix-8 FFT.Forward and inverse FFT.Pipelined mode operation, each result is outputted in one clock cycle, the latent delay from input to output is equal to 163 clock cycles, simultaneous loading/downloading supported.Input data, output data, and coefficient widths are parametrizable in range 8 to 16Two and three</div>
                    <a href='cores/dsp_core/pipelined_fft-ifft_64_points_processor/index.html'>pipelined fft/ifft 64 points processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_pipelined_fft-ifft_64_points_processor'>code</a>
                </td>
                <td>Feb 25, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core NoLicense: LGPLDescriptionThis is a behavioral SystemC model for Polyphase Decimation filters. It can be used as for system design and functional verification. It has been tested with Matlab and Octave as well. If you need any further illustrations or further modifications, don't hesitate to contact me. It can be used effectively for class instruction. It is a good practice for SystemC beginners and DSP student/engineers as well.Feel free to contact me whenever you have further requests or comments.</div>
                    <a href='cores/dsp_core/polyphase_decimation_filter/index.html'>polyphase decimation filter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_polyphase_decimation_filter'>code</a>
                </td>
                <td>May 11, 2012</td>
                <td>SystemC</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>dsp core shBone Compliant: NoLicense: LGPLDescriptionThis project is a digital signal processing (DSP) implementation of a circuit that provides periodic samples of both sine and cosine waveforms.  Technically, it is called a "discrete-time discrete-amplitude binary recursion oscillator."  Although that description sounds complex, the operation of the circuit is not complicated.  This particular implementation uses a multiplier and an adder, and can be configured to produce sine/cosine output at the desired frequency and with the specified number of bits per sample.The sine and cosine outputs represent</div>
                    <a href='cores/dsp_core/quadrature_oscillator/index.html'>quadrature oscillator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/dsp_core_quadrature_oscillator'>code</a>
                </td>
                <td>Jun 8, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>ECC CORE</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core cense:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  SeeConfluent.orgfor more info.The core is provided in Verilog, Vhdl, C, and Python.Low-density parity-check (LDPC) codes are forward error correction codes invented by Robert Gallager in the early 60's.  LDPC codes have record breaking error correction performance and approach Shannon's limit for channel capacity.FeaturesThis LDPC error corrector implements Gallager's "A" algorithm: an iterative, hard-deci</div>
                    <a href='cores/ecc_core/cf_ldpc_decoder/index.html'>cf ldpc decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_cf_ldpc_decoder'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core Compliant: NoLicense: LGPLDescriptionThe project describes an IPCore in verilog about binary BCH encoder and decoder. BCH is a popular error correcting code used in storage and transmission system. It adds some redundancy check data into original data frame, the redundancy data length depends on correcting capacity, and all the calculation proceed in the Galois Field that is suitable for FPGA.</div>
                    <a href='cores/ecc_core/configurable_bch_encoder_and_decoder/index.html'>configurable bch encoder and decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_configurable_bch_encoder_and_decoder'>code</a>
                </td>
                <td>Apr 6, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core nt: NoLicense: GPLDescriptionThis C++ program generates VHDL package with hamming encoder and decoder. It also generates a simple testbench that can be used to evaluate the generated Hamming code.my email is ale_amory@opencores.orgFeatures- It is a easy to use command-line program  - HammingGen \ \ \- It generates two types of Hamming code  - SEC - Single Error Correction  - SEC-DED - Single Error Correction and Dual Error Detection- It is easy to modify the original designExamplesGenerated Code for a Hamming SEC with 32 bits- FUNCTION hamming_encoder_32bit(data_in:data_ham_32bi</div>
                    <a href='cores/ecc_core/configurable_hamming_generator/index.html'>configurable hamming generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_configurable_hamming_generator'>code</a>
                </td>
                <td>Mar 21, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core nt: NoLicense:DescriptionFeatures- feature1- feature2Status- ...- ...</div>
                    <a href='cores/ecc_core/constellation_encoder/index.html'>constellation encoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_constellation_encoder'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core mpliant: NoLicense: LGPLDescriptionThe double error correcting (DEC) BCH encoder / decoder IP cores.Features :&euro;&ldquo; allows to correct up to 2 errors.&euro;&ldquo; supports 16/32/64/128 bit memories (typical memory word sizes).&euro;&ldquo; operates on complete memory words in a single cycle.&euro;&ldquo; pure combinational logic design.</div>
                    <a href='cores/ecc_core/double_error_correcting_dec_bch_encoder-decoder/index.html'>double error correcting dec bch encoder/decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_double_error_correcting_dec_bch_encoder-decoder'>code</a>
                </td>
                <td>Apr 29, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core oneWishBone Compliant: NoLicense:DescriptionHamming (7,4) Encoder: This core encodes every 4-bit message into 7-bit codewords in such a way that the decoder can correct any single-bit error.The encoder uses the generator matrix:G=[ 1110000100110001010101101001]The codewords are generated byC = M * Gwhere M=[m1 m2 m3 m4] is the 4-bit message.</div>
                    <a href='cores/ecc_core/ham_7_4_enc/index.html'>ham_7_4_enc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_ham_7_4_enc'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core Compliant: NoLicense:PCI express CRC verilog code 16 bit data 32 bit CRCFunctional DescriptionDesigners commonly use Cyclic Redundacy Codes (CRC) as an alternative to parity and checksum calcutions for checking and correcting errors in data transmissions.The CRC method for error detection and correction treats the data frame as a huge binary number.  The binary number is divided (at the CRC generation end) by a fixed binary number (the CRC generator polynomial)  and the resulting remainder of this division (CRC value) is appended to the end of the data frame.  The receiver upon reception of th</div>
                    <a href='cores/ecc_core/pci_express_16_bit_crc_verilog_file/index.html'>pci express 16 bit crc verilog file</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_pci_express_16_bit_crc_verilog_file'>code</a>
                </td>
                <td>Dec 17, 2007</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core :Design doneWishBone Compliant: NoLicense: BSDProduct Code Iterative DecoderAn iterative decoder for Product Code, this decoder works for two dimensional product code.Status- Preliminary Check usinghttp://asim.lip6.fr/recherche/alliance/(Alliance 5.0)- Synthesized using ISE Xilinx 6.3i for target XC2V2000-FF896-4- Bit errors rates:- SNR 100 dB got 0000 errors from 10000 samples- SNR 009 dB got 0000 errors from 10000 samples- SNR 006 dB got 0012 errors from 10000 samples- SNR 003 dB got 0279 errors from 10000 samples- SNR 000 dB got 1314 errors from 10000 samples-http://www.opencores.org/pstats</div>
                    <a href='cores/ecc_core/product_code_iterative_decoder/index.html'>product code iterative decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_product_code_iterative_decoder'>code</a>
                </td>
                <td>Mar 19, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core gn done,FPGA provenWishBone Compliant: NoLicense: GPLDescription&euro; Reed Solomon Decoder (204,188), with T=8.&euro; Input codeword length is 204 bytes and output length is 188 bytes.&euro; Corrects up to 8 byte errors per input codeword.&euro; Code generator polynomial: (x + ) (x + ^2) (x + ^3) ... (x + ^16).&euro; Field generator polynomial: x^8+ x^4+ x^3+ x^2+1.&euro; This version of the Reed Solomon core is distributed under the GPL license.An optimized and considerably more advanced version, which may becustomized on request for different code generator polynomials, isavailable under a </div>
                    <a href='cores/ecc_core/reed_solomon_decoder_204188/index.html'>reed solomon decoder 204188</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_reed_solomon_decoder_204188'>code</a>
                </td>
                <td>Nov 23, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core Bone Compliant: NoLicense:Status- RTL done and design verified using testbench.- Will upload soon.- June 27th 2004, updated. Please click on 'Downloads' (top right on this page).- June 29 2004, There was a typo in reed_solomon.v file.  The output ports d0, d1, d2, d3 actually refer to q0, q1, q2, q3 (see readme.txt file). Sorry for the confusion. Corrected now.Features-  User defined generator polynomial.-  Allows experimentation with diferent generator polynomials for best implementation.-  Replacable Galois field multiplier submodule for a different primitive polynomial.-  Can be used for sh</div>
                    <a href='cores/ecc_core/reed_solomon_encoder/index.html'>reed solomon encoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_reed_solomon_encoder'>code</a>
                </td>
                <td>Jul 3, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core  Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/ecc_core/reed_solomon_encoder-decoder/index.html'>reed solomon encoder/decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_reed_solomon_encoder-decoder'>code</a>
                </td>
                <td>Dec 14, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core nfo:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThis tool working on WinXP is used to generate verilog-RTL for Reed-Solomon Codec.- Selectable Decoder/Encoder/Both- Symbol width 3,4,5,6,7,8,9,10,11- Primitive polynomial- Erasure Enable/Disable- Configurable Data I/F- Automatically available testbench- Distributed under the GPL licenseIf you need more customize or hi-performance IP, please let us know.info@syslsi.com</div>
                    <a href='cores/ecc_core/reed-solomon_codec_generator/index.html'>reed-solomon codec generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_reed-solomon_codec_generator'>code</a>
                </td>
                <td>Aug 8, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core  doneWishBone Compliant: NoLicense:Specifications-  Hard-decision decoding scheme-  Codeword length (n) : 31 symbols-  Message length (k) : 19 symbols-  Error correction capability (t) : 6 symbols-  One symbol represents 5 bit-  Uses GF(2^5) with primitive polynomial p(x) = X^5 + X^2 + 1-  Generator polynomial, g(x) = a^15 + a^21*X + a^6*X^2 + a^15*X^3 + a^25*X^4 + a^17*X^5 + a^18*X^6 + a^30*X^7 + a^20*X^8 + a^23*X^9 + a^27*X^10 + a^24*X^11 + X^12.  Note: a = alpha, primitive element in GF(2^5) and a^i is root of g(x) for i = 19, 20, ..., 30-  Uses Verilog description with synthesizable RTL mo</div>
                    <a href='cores/ecc_core/reed-solomon_decoder_31_19_6/index.html'>reed-solomon decoder 31 19 6</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_reed-solomon_decoder_31_19_6'>code</a>
                </td>
                <td>Dec 1, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core t: NoLicense: LGPLDescriptionThis core implements Reed-Solomon decoder for the 8-bit wide symbols. The core is designed to occupy fewer amounts of logic blocks, be fast and parametrizable.Main Features:8-bit input and output data bussesFully synchronous and pipelined design using a single clock.Symbol width of 8 bitsCorrected byte number signalingDetects condition when the number of errors is too high to be correctedCan correct 2 symbols.Please, contact us if you wish to have this IP core modified or adjusted to meet your requirements.This core is provided byUnicore Systemshttp://unicore.co.ua</div>
                    <a href='cores/ecc_core/reed-solomon_decoder-encoder/index.html'>reed-solomon decoder/encoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_reed-solomon_decoder-encoder'>code</a>
                </td>
                <td>Feb 2, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core e Compliant: NoLicense:Reed Solomon (5, 3) Encoder-Decoder in GF(256)- Symbol width : 8-bits.- Encodes every 3-byte message into 5-byte codewords.- Capable of correcting any single symbol error (even if all the 8-bits are erronous) in a codeword.- This core has two operation modes: Encoding and Decoding.- In both operation modes, the inputs are taken in byte-by-byte at each clock cyle.- While encoding, message is input at three clock cycles and the next two clock cyles are reserved for the two parity symbols of the codeword.- While decoding, received vector is taken in at five clock cycles. Bu</div>
                    <a href='cores/ecc_core/rs_5_3_gf256/index.html'>rs_5_3_gf256</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_rs_5_3_gf256'>code</a>
                </td>
                <td>Jun 20, 2005</td>
                <td>Verilog</td>
                <td>Unknow</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core ditional info:WishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/ecc_core/spread_spectrum_modulator_and_demodulator_using_bp/index.html'>spread spectrum modulator and demodulator using bp</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_spread_spectrum_modulator_and_demodulator_using_bp'>code</a>
                </td>
                <td>Sep 21, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core  NoLicense: LGPLDescriptionThis project features a double binary, DVB-RCS turbo decoder using the SOVA algorithm.Two models are included:- a MyHDL model, along with a complete testbench,- a synthesizable VHDL model.FeaturesDouble binary, DVB-RCS codeSoft Output Viterbi AlgorithmMyHDL cycle/bit accurate model and testbenchSynthesizable VHDL modelStatusRelease 0.3:- Synthesizable VHDL model- Fixed ponderation filteringRelease 0.2:- DVB-RCS interleaver- DVB-RCS puncturing (decoder only)- Controllable SNR for the noiserRelease 0.1: MyHDL model posted- Simulation system consists of a random data pa</div>
                    <a href='cores/ecc_core/turbo_decoder_1/index.html'>turbo decoder 1</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_turbo_decoder_1'>code</a>
                </td>
                <td>Nov 19, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core ign done,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionUltimate CRC is a CRC generator/checker. Using generics the core can be fully customized. It creates a function of the data input and the CRC register using XOR-logic. Although the levels of logic gets very high for wide data inputs, the throughput still benefits from this architecture, as can be seen from the synthesis page.FeaturesExecutes in one clock cycle per data wordAny polynomial from 4 to 32 bitsAny data width from 1 to 256 bitsAny initialization valueSynchronous or asynchronous resetStatusRevision 1.0</div>
                    <a href='cores/ecc_core/ultimate_crc/index.html'>ultimate crc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_ultimate_crc'>code</a>
                </td>
                <td>Aug 1, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>ecc core  done,FPGA provenWishBone Compliant: NoLicense: GPLDescriptionA fully configurable VHDL Viterbi decoder compliant with the AXI4-Stream interface.Most standards using convolutional codes like Wifi or GSM are easy to implement by configuring some generic parameters.The decoder supports a high throughput even on low-cost devices.See theUser Guidefor more information about the core.FeaturesDesign-time configuration of encoder polynomials (different number of states and different code rates).Support for recursive and non-recursive convolutional codes.Windowing technique for reduced latency an</div>
                    <a href='cores/ecc_core/viterbi_decoder_axi4-stream_compliant/index.html'>viterbi decoder axi4-stream compliant</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/ecc_core_viterbi_decoder_axi4-stream_compliant'>code</a>
                </td>
                <td>Apr 16, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <td>
                    <b>LIBRARY</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>library License: OthersDescriptionCommon Design Environment (CDE) is a library of modules that usually require replacement with specific hardmacros when the design is retargeted to a IC process. By using modules from the CDE library it will be possibleto easily make this substitution with an ip-Xact enabled tool flow without having to touch the original rtl code.</div>
                    <a href='cores/library/common_design_environment/index.html'>common design environment</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_common_design_environment'>code</a>
                </td>
                <td>Aug 18, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library hBone Compliant: NoLicense:DescriptionThis project contains files you can use to expand upon the basic IEEE packages you normally use for creating testbenches and RTL code.Featuresautomatic count stop/start value generation functions.  You enter a time duration and clock frequency and the value is automatically computed.  Your choice of binary or LFSR number spaces.LFSR counters created by function call.clock generation procedurestype and number conversion functions:synthesizable binary_to_BCD and BCD_to_binary functionssynthesizable BCD_to_seven_segment display functionsstring value to std_lo</div>
                    <a href='cores/library/extension_pack/index.html'>extension_pack</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_extension_pack'>code</a>
                </td>
                <td>Oct 25, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library iant: NoLicense: LGPLDescriptionfixed_extensions_pkg is a fixed-point arithmetic package written in VHDLaccording to the VHDL-2008 update of the standard. It uses VHDL-2008 back-compatible libraries (by David Bishop) that are included in this distributionfor the sake of completeness.Currently, the "fixed_extensions_pkg" package implements the following:-ceil:round towards plus infinity.-fix:round towards zero.-floor:round towards minus infinity.-round:round to nearest; ties to greatest absolute value.-nearest:round to nearest; ties to plus infinity.-convergent:round to nearest; ties to closest</div>
                    <a href='cores/library/fixed_extensions/index.html'>fixed_extensions</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_fixed_extensions'>code</a>
                </td>
                <td>Feb 20, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library  Compliant: NoLicense: LGPLDescriptionFunbase project focuses on FPGA-based embedded product development. Immediate drivers are customer driven, networked development and design effort saving methods. Special goal is to make FPGA technology accessible to SW engineers without special HW experience.  The project has a web pagehttp://funbase.cs.tut.fibut the IP components will be hosted by OpenCores.</div>
                    <a href='cores/library/funbase_ip_library/index.html'>funbase ip library</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_funbase_ip_library'>code</a>
                </td>
                <td>May 8, 2012</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library shBone Compliant: NoLicense:DescriptionPerhaps more of a collection of part than a true library, this is a set of VHDL parts that may be used as a set of building blocks for larger designs.Featurescounters, shift registers, pulse stretchers (high, low, and programmable) and other MSI partssix fixed length LFSR's (24, 36, 48, 64 bits and two that are set with Generics)two Programmable length LFSR'sclocked delay lines (fixed and programmable)control registers (individual bits may be set, cleared, or inverted)GPIOPulse GeneratorBurst GeneratorParity generatorSweep GeneratorCIC filterNCO's (some u</div>
                    <a href='cores/library/gh_vhdl_library/index.html'>gh vhdl library</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_gh_vhdl_library'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library Bone Compliant: NoLicense: GPL</div>
                    <a href='cores/library/mitrion_virtual_processor_starter_kit/index.html'>mitrion virtual processor starter kit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_mitrion_virtual_processor_starter_kit'>code</a>
                </td>
                <td>Jun 10, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library oLicense: OthersDescriptionMyGPU is a library of large-scale components like FPU units, a processor and auxillary units which can be used to build SoCs, processors, etc.We do not only write verilog code, but also design layouts of our units, and develop tools to scale the layouts to appropriate tech process.</div>
                    <a href='cores/library/mygpu/index.html'>mygpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_mygpu'>code</a>
                </td>
                <td>Feb 12, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library hBone Compliant: NoLicense: GPLopenVeriFLA - FPGA logic analyzeropenVeriFLA is an FPGA integrated logic analyzer.It can be used for in-circuit debugging and verificationof the FPGA based applications.The FPGA part is written in verilog. The PC partis written in java and is platform independent.Being simple and well documented, the openVeriFLA libraryis well suited for didactical purposes and academic use.For more information, please unzip the project archiveand read the reference manual.Features- on-the-fly capture, graphical display, testing automationStatus- ready to useIMAGE: verifla_keyboa</div>
                    <a href='cores/library/openverifla-fpga_logic_analyzer/index.html'>openverifla-fpga logic analyzer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_openverifla-fpga_logic_analyzer'>code</a>
                </td>
                <td>Mar 3, 2008</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library ant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/library/qaztronics_libraries/index.html'>qaztronics libraries</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_qaztronics_libraries'>code</a>
                </td>
                <td>Dec 6, 2014</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library tion doneWishBone Compliant: NoLicense: GPLDescriptionThis library has functions for generating good quality random numbers in a VHDL testbench environment. The functions will NOT synthesize.Features- Based on a combination of 3 Tausworthe generators.- Distributions:- Uniform (continous)- Gaussian (continous)- Exponential (continous)- For use in test benchesStatus- Version 1.0 released.</div>
                    <a href='cores/library/random_number_generator_library/index.html'>random number generator library</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_random_number_generator_library'>code</a>
                </td>
                <td>Oct 14, 2007</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library icense: LGPLDescription"ratpack" is a rational arithmetic package written in VHDL.Currently, the "ratpack" package implements the following:- the RATIONAL data type.- to_rational: construction function of a rational given two integers(numerator and denominator).- int2rat: conversion function of an integer to its rationalrepresentation.- numerator: extracts the numerator of a rational number.- denominator: extracts the denominator of a rational number.- "+", "-", "*", "/": implementation of the basic arithmeticoperations for rationals.- abs: extracts the absolute value of a given rational numbe</div>
                    <a href='cores/library/ratpack/index.html'>ratpack</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_ratpack'>code</a>
                </td>
                <td>Feb 20, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library roven,Specification doneWishBone Compliant: YesLicense: GPLDescriptionThis core offers a real-time clock capability to a device.  Specific capabilities include 24-hour BCD time, a count down timer, a stop watch, an alarm, and an ability to precisely capture the time of an externally generated event.Other outputs include drivers for 16 LED's that will count up to each minute, 32 bits to control four digits of a seven segment display, and an interrupt strobe line which can be used to set off and edge triggered interrupt whenever the countdown timer gets to zero or the alarm goes off.The core is </div>
                    <a href='cores/library/real-time_clock/index.html'>real-time clock</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_real-time_clock'>code</a>
                </td>
                <td>May 26, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library liant: NoLicense:General Robot Control libraryThe aim of this project is to design and implement general control, sensor and actuator ip modules for robot applications.The modules will optionally connect to a opb or WishBone bus. Configuration of the individual modules are managed through the bus. A control loop is constructed by connecting the input/output of the individual modules together. This allows for parallel connection of multiple control loops.Features- PWM encoder- 32 bit OPB interface. Drivers for Microblaze. Supports 2-phase, 1-phase and enable chopping. Programmable frequency and</div>
                    <a href='cores/library/robot_control_library/index.html'>robot control library</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_robot_control_library'>code</a>
                </td>
                <td>Feb 14, 2007</td>
                <td>VHDL</td>
                <td>Unknow</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library esign done,FPGA provenWishBone Compliant: NoLicense: OthersDescriptionThe srdy-drdy library provides a group of components all built around a common data-transfer protocol.  This protocol is used in datapath applications and provides bidirectional flow control.Components in the library provide basic timing closure, clock domain crossing, basic and advanced buffering, and some arbitration and specialized components.  The components in the library have been used in multiple successful tape-outs and FPGA designs.</div>
                    <a href='cores/library/srdy-drdy_library/index.html'>srdy-drdy library</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_srdy-drdy_library'>code</a>
                </td>
                <td>Apr 20, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>library Compliant: NoLicense: LGPLDescriptionA Verilog HDL library with frequently used functions. Care have been taken to fully support synthesis of all modules. Different versions exist for optimal synthesis support. Currently ACTEL and ALTERA are supported</div>
                    <a href='cores/library/versatile_library/index.html'>versatile library</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/library_versatile_library'>code</a>
                </td>
                <td>Sep 14, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>MEMORY CORE</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core PGA provenWishBone Compliant: NoLicense: LGPLOverviewI implemented 2Q cache strategy from paper "2Q:  A Low Overhead High Performance Buffer Management Replacement Algorithm" written by Theodore Johnson and Dennis Shasha. It is written in VHDL and supports my FORTH-processor, which runs on a Spartan 3A DSP board from Xilinx. I think it can be adapted for other processors easily.parameters, user defineable:- blocksizeld   ld of size of tagram- ldways        ld of number of tagrams (n-way associative)- ldcachedwords ld of number of 32-bit words in one cachelinedefineable too:- ldram            l</div>
                    <a href='cores/memory_core/2q_cache/index.html'>2q cache</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_2q_cache'>code</a>
                </td>
                <td>Nov 26, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core pecification doneWishBone Compliant: YesLicense: GPLDescriptionFeature:&euro; 8/16/32 Configurable SDRAM data width&euro; Wish Bone compatible&euro; Application clock and SDRAM clock can be async&euro; Programmable column address&euro; Support for industry-standard SDRAM devices and modules&euro; Supports all standard SDRAM functions&euro; Fully Synchronous; All signals registered on positive edge of system clock&euro; One chip-select signals&euro; Support SDRAM with four bank&euro; Programmable CAS latency&euro; Data mask signals for partial write operations&euro; Bank management architecture</div>
                    <a href='cores/memory_core/8-16-32_bit_sdram_controller/index.html'>8/16/32 bit sdram controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_8-16-32_bit_sdram_controller'>code</a>
                </td>
                <td>Jun 17, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core nt: NoLicense: GPLDescriptionSUPERSEDED BYHPDMC.Please do not ask me about this core! It is old and totally unsupported. HPDMC support, however, is available from theMilkymist-develmailing list.</div>
                    <a href='cores/memory_core/asynchronous_wishbone-compatible_sdram_controller/index.html'>asynchronous wishbone-compatible sdram controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_asynchronous_wishbone-compatible_sdram_controller'>code</a>
                </td>
                <td>Aug 7, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core PGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis module implements a synchronous FIFO using Block RAM resources such as those found in SRAM-based FPGAs. This module has been used in several products/projects based on Xilinx Spartan 3AN FPGAs. It can be adapted to other development environments and FPGAs, but only Xilinx ISE and Xilinx Spartan 3A/3AN FPGAs has been used to date.All components used in this module are inferred, including the Block RAM. This allows the depth and width to be set by parameters. Furthermore, the state of the memory, the write pointer, and FIFO flags can b</div>
                    <a href='cores/memory_core/brsfmnce/index.html'>brsfmnce</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_brsfmnce'>code</a>
                </td>
                <td>Nov 1, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core iant: NoLicense:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  SeeConfluentfor more info.Memory interleavers are common components often found in signal processing applications.  They are useful for buffering and reordering data and typically form the separation between design stages.  Interleavers can be used for:- Transposing Images for Image Processing- Buffering Noncontinuous Input Data- Data Shuffling Between FFT RanksFeaturesThe memory interleaver</div>
                    <a href='cores/memory_core/cf_interleaver/index.html'>cf interleaver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_cf_interleaver'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core iant: NoLicense: LGPLDescriptionCFI flash controller IP.Provides two modes of operation - simple (Wishbone bus straight through to flash bus, essentially, but with 32-bit word read capability, allowing XIP - execute in place - for 32-bit processors) and a "CFI engine" mode, which aims to simplify interfacing with a CFI flash.Only implements asynchronous flash bus interface.System bus interface is Wishbone, or CFI engine module can be used stand-alone and provides a generic bus interface.Both modes tested with Intel P30 Strataflash part on Xilinx ML501 board.Is implemented in the ORPSoC ml501 b</div>
                    <a href='cores/memory_core/cfi_flash_controller/index.html'>cfi flash controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_cfi_flash_controller'>code</a>
                </td>
                <td>Oct 23, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core oLicense:DescriptionThe ddr_sdr controls read and write access of a programmablelogic device to a single 256 Mbit memory device. The 32-bitwide user interface basically accepts two commands, read orwrite. The control logic initializes the memory after resetand issues refresh commands from time to time to ensure dataintegrity. The data width to the memory device is 16 bitswide and performs a double data rate operation at 100 MHzclock rate.Status- Version 1.0 available</div>
                    <a href='cores/memory_core/ddr_sdram_controller_core/index.html'>ddr sdram controller core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_ddr_sdram_controller_core'>code</a>
                </td>
                <td>Apr 30, 2013</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core WishBone Compliant: YesLicense: LGPL</div>
                    <a href='cores/memory_core/ddr2_mem_controller_for_digilent_genesys_board/index.html'>ddr2 mem controller for digilent genesys board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_ddr2_mem_controller_for_digilent_genesys_board'>code</a>
                </td>
                <td>May 6, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core iant: NoLicense: LGPLDescriptionThis project implements a DDR2-SDRAM Controller on a Xilinx Spartan-3A BoardModulsFunctionAfter a Power on :==================1. Init-Sequenz for the RAM2. Automaic Write-Sequenz (writes 16 Datawords each 64Bit to the RAM)3. Automatic Read-Sequenz (reads the first Dataword from the RAM)4. Display the Dataword at the 8Bit LEDsSwitch-0 :==========&gt; SW0 is used as a Reset-SwitchSwitch-1 to 3 :===============&gt; SW1 to SW3 selects witch part of the Datawordis shown at the LEDsButton north :==============&gt; increments the AdresspointerButton south :============</div>
                    <a href='cores/memory_core/ddr2_sdram_controller/index.html'>ddr2 sdram controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_ddr2_sdram_controller'>code</a>
                </td>
                <td>Jun 3, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core esign doneWishBone Compliant: NoLicense: LGPLDescriptionThis is a fully synthesizable DDR3 Memory BFM. Implemented using Verilog 2001 without any vendor specific IP Block. As such, the BFM is not able to run a very high speed. Test shown that is is able to respond to WRITE and READ instruction at 10MHz.StatusMemory BFM has been tested and passes all Micron DDR3 testbench. It is also has been tested and able to passes Altera DDR3 Testbench.Has been synthesized using Xilinx ISE 13.2 and Quartus II Version 11.1 Build 173</div>
                    <a href='cores/memory_core/ddr3_synthesizable_bfm/index.html'>ddr3 synthesizable bfm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_ddr3_synthesizable_bfm'>code</a>
                </td>
                <td>Dec 3, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core ne Compliant: NoLicense: LGPLDescriptionThis project is to develop a direct mapped cache controller for embedded applications.Key Design Features- Direct mapped with configurable address size, line size and number of cache lines- Non Pipelined architecture- No Cache flushSynthesis will be conducted using VirtexII ProProgress7th January 2010Memory(RAM) implementation completed</div>
                    <a href='cores/memory_core/directmappedcachecontroller/index.html'>directmappedcachecontroller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_directmappedcachecontroller'>code</a>
                </td>
                <td>Jan 7, 2010</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core PGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project provides a parameterizable synchronous FIFO which uses LUTs instead of Block RAMs for its memory. The FIFO can be parameterized in depth and width. It has been used in a number of commercial products. It is primarily used for implementing small buffers for the transmit and receive functions of UARTs. (A companion project, BRSFmnCE, provides the same basic functionality using block RAMs.)Synthesis/PAR SummaryThe DPSFmnCE has been used in several projects/products. It is generally used as a small FIFO for UARTs. The following s</div>
                    <a href='cores/memory_core/dpsfmnce/index.html'>dpsfmnce</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_dpsfmnce'>code</a>
                </td>
                <td>Nov 2, 2013</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core e Compliant: NoLicense: LGPLDescriptionThe simu_mem project provides functional simulation models of commercially available RAMs.Advantages of the simu_mem models=================================1. Consumes few simulator memory if only few memory locations are accessed because it internally uses a linked list.2. Simulates quickly because it does not contain timing information. Fast simulator startup time because of the linked list.3. Usable for any data and address bus width.4. Works at any clock frequency.5. Programmed in VHDL.When the simu_mem models will not be useful=======================</div>
                    <a href='cores/memory_core/functional_simulation_models_for_commercially_avai/index.html'>functional simulation models for commercially avai</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_functional_simulation_models_for_commercially_avai'>code</a>
                </td>
                <td>Nov 18, 2008</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core  NoLicense: LGPLDescriptionA very generic implementation of a FIFO. Makes good use of VHDL transactors for data transfers.</div>
                    <a href='cores/memory_core/generic_fifo/index.html'>generic fifo</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_generic_fifo'>code</a>
                </td>
                <td>Feb 16, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core venWishBone Compliant: NoLicense:DescriptionGeneric, multi-purpose FIFOs. Available as single clock and dual clock version, binary, lfsr, and gray encoded (dual clock only). All are parameterizable and use generic_memories for memory. These FIFOs are fully portable from FPGAs to ASICS.Features- Written in Verilog- Fully Synthesizable (FPGA &amp; ASIC libraries)- Parameterized- Single and Dual ClockStatus- All FIFOs that are release are done. They have been simulated and most of them have been used in one way or another in one of my projects.  Some have been verified in real hardware.- October </div>
                    <a href='cores/memory_core/generic_fifos/index.html'>generic fifos</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_generic_fifos'>code</a>
                </td>
                <td>Jul 29, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core liant: YesLicense: LGPLDescriptionTwo WISHBONE wrappers will be developed for Xilinx Memory Interface Generator (MIG). The first is compliant with version B4 Registered Feedback Incrementing Burst Cycle. The second is a non-compliant but streamlined interface developed as a proposal for inclusion as a new Burst Cycle Type geared towards interfacing with high latency devices.</div>
                    <a href='cores/memory_core/high_latency_bursting_wishbone_wrapper_for_xilinx_/index.html'>high latency bursting wishbone wrapper for xilinx </a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_high_latency_bursting_wishbone_wrapper_for_xilinx_'>code</a>
                </td>
                <td>Apr 7, 2011</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core  proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionHPDMC is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.Fast DDR SDRAM controller with features targeted at high-bandwidth burst-oriented applications such as live video processing. The core has been re-used by several projects and institutions, such as the NASA as part of a software-defined radio system for the ISS (CoNNeCT experiment).Features- Current design is targeted at 32-bit wide DDR SDRAM.- Dedicated non-standard high-speed bus for efficient memory acc</div>
                    <a href='cores/memory_core/high_performance_dynamic_memory_controller/index.html'>high performance dynamic memory controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_high_performance_dynamic_memory_controller'>code</a>
                </td>
                <td>Aug 26, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core e Compliant: NoLicense:DescriptionHSSDRC IP core is the configurable universal SDRAM controller with adaptive bank control and adaptive command pipeline.HSSDRC IP core and IP core testbench has been written on SystemVerilog and has been tested in Modelsim.HSSDRC IP core is licensed under MIT LicenseFeaturesThe main features of HSSDRC IP core are :- Adaptive SDRAM bank control: command sequence is depending upon  previous accesses to the RAM.- Adaptive command pipeline control: bank control commands for following memory access commands are pipelined into previous command processing chain whenev</div>
                    <a href='cores/memory_core/high_speed_sdram_controller_with_adaptive_bank_man/index.html'>high speed sdram controller with adaptive bank man</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_high_speed_sdram_controller_with_adaptive_bank_man'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core nt: NoLicense:DescriptionCheck the memory cores site for more documentation atJamil Khatib site.Status- VHDL codes are stable and available on the CVS- Some cores need test benchs- we need more memory cores with different features- we need more people to test the cores on real hardware- You can download the memory codes from the CVS using the module name "memory_cores" and for new cores use module name "memory_cores2".-Note: it is recommended to download the whole module because files are dependent on each other</div>
                    <a href='cores/memory_core/memory_cores/index.html'>memory cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_memory_cores'>code</a>
                </td>
                <td>Oct 14, 2001</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core nt: YesLicense:DescriptionThe memory_sizer project is designed to automatically handle accesses to and from memory.  It does not handle refreshing DRAM at all, but it does automatically generate the cycles needed to fulfil a memory request by a processor.  For example, it can load 32-bit words from byte wide memory (if you want to boot from a single byte-wide flash chip, for instance).  Alternatively, it could load 16-bit words from byte wide memory.  It also handles loading and storing bytes from 32-bit wide memory and 16-bit memory, although the memory in this case must support the use of "b</div>
                    <a href='cores/memory_core/memory_sizer/index.html'>memory sizer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_memory_sizer'>code</a>
                </td>
                <td>Dec 21, 2001</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core e Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/memory_core/nand_controller_onfi_compliant/index.html'>nand controller onfi compliant</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_nand_controller_onfi_compliant'>code</a>
                </td>
                <td>May 27, 2015</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core  provenWishBone Compliant: NoLicense: GPLDescriptionThe OPB PSRAM-Controller connect a Pseudo-Staic-RAM, also named CellularRAM&bdquo;&tilde; to the OPB-Bus.FeaturesDesign- max. 80 Mhz Memory Clock for a Spartan-3 1500 FPGA- synchronous design, no DCM/DLL neededPerformance with micron MT45W8MW16BGX-701- 32-Bit Write: 3 Clock cycles- 32-Bit Read: 8 Clock cyclesStatus- Design Phase done- Simulation Tests done- Real-World Tests done</div>
                    <a href='cores/memory_core/opb_psram_controller/index.html'>opb psram controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_opb_psram_controller'>code</a>
                </td>
                <td>Feb 16, 2008</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core Compliant: NoLicense: LGPLDescriptionOpen FreeList ReadmeThe Open FreeList module is used to manage a set of variable sized packets inside a fixed memory block.	The memory block is partitioned into fixed sized chunks and each packet uses one or more chunks.	The module offers three possible actions:Write a packet into memoryRead a packet from memoryRelease a packetParametersNameDescriptionUnitDefault ValueRAM_WMemory block widthbits128RAM_EMemory block extra databits0RAM_SMemory block sizeKBytes64CHK_SChunk sizeBytes128RAM_TYPEMemory block typestring"MRAM"FL_AEMPTY_LVLFreeList almost empty </div>
                    <a href='cores/memory_core/open_freelist/index.html'>open freelist</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_open_freelist'>code</a>
                </td>
                <td>Feb 16, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core GA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionopenHMC is an open-source project developed by the Computer Architecture Group (CAG) at the University of Heidelberg in Germany. It is a vendor-agnostic, AXI-4 compliant Hybrid Memory Cube (HMC) controller that can be parameterized to different data-widths, external lane-width requirements, and clock speeds depending on speed and area requirements.     The main objective of developing the HMC controller is to lower the barrier for others to experiment with the HMC, without the risks of using commercial solutions.     F</div>
                    <a href='cores/memory_core/openhmc/index.html'>openhmc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_openhmc'>code</a>
                </td>
                <td>May 12, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core cense:DescriptionParameterisable DRAM model, i.e. scalable data and address widths. Simulation assertions can be toggled on/off. Uses !RAS/!CAS control sequence for modelling DRAM activity. Refresh is monitored with data corrupted to "UU ... "Status- VHDL code is available (see Downloads)Author- Damon P Thompson</div>
                    <a href='cores/memory_core/parameterisable_dram_model/index.html'>parameterisable dram model</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_parameterisable_dram_model'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core ishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/memory_core/parametrized_fifo_based_on_srl16e/index.html'>parametrized fifo based on srl16e</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_parametrized_fifo_based_on_srl16e'>code</a>
                </td>
                <td>Apr 19, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core ne Compliant: YesLicense: LGPLOverviewThis is a wishbone B3 compliant RAM memory. The memory array is defined as a 32 bit memory. This gives two valuable benefitsmemory array can be mapped into one block RAM with no need for byte select during synthesismemory content can be initialized with CPU instructions with no need to split content into byte chunks</div>
                    <a href='cores/memory_core/ram_wb/index.html'>ram_wb</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_ram_wb'>code</a>
                </td>
                <td>Mar 10, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core ompliant: NoLicense: LGPLDescriptionDDR SDRAM controller core targeted at the mt46v32m16 chip on the Spartan3e Starter Board. The testbench synthesizes and runs on the targeted hardware. Additionally I've integrated this controller core into an SoC design consisting of a T80 soft cpu with a VGA controller, Flash controller and UART.The design is more or less frozen, unless I change out soft CPUs and need to integrate again. Further changes will be driven by bug discoveries/reports.</div>
                    <a href='cores/memory_core/scratch_ddr_sdram_controller/index.html'>scratch ddr sdram controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_scratch_ddr_sdram_controller'>code</a>
                </td>
                <td>Sep 16, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core shBone Compliant: NoLicense: LGPLDescriptionThe main purpose of this project was two-fold. The first purpose was to implement a client-server test architecture based on Bergeron's work in VHDL. The main advantage to this verification method is greater stress-test ability and removes the need to create test script language to test the DUT.The second purpose was to bench-mark the running speed of the ASRAM implemented as three different architectures.1. Linked-list2. Bit-vector3. regular std_logic_vector implementation.Features- Demonstrates client-server testbench architecture in VHDL.- bit-vec</div>
                    <a href='cores/memory_core/single_port_asram/index.html'>single port asram</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_single_port_asram'>code</a>
                </td>
                <td>Dec 27, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core provenWishBone Compliant: YesLicense: LGPLDescriptionThis is a wrapper for an inferred single port RAM, that converts it into a Three-port RAM with one WISHBONE slave interface for each port.Very useful as a drop-in module to create configuration registers for any core.Features- Generics for data and address widths of internal RAM- Included inferred single port ram (but ready to use an instantiated SPRAM component, i.e.: generated by coregen)- Wait states are reduced to the very minimum (writes immediately acked)- Provides a way to lock access to only one port at a time (by keeping wb_cyc line</div>
                    <a href='cores/memory_core/sp_ram_to_3p_ram_wishbone_wrapper/index.html'>sp_ram to 3p_ram wishbone wrapper</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_sp_ram_to_3p_ram_wishbone_wrapper'>code</a>
                </td>
                <td>Jan 23, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core one Compliant: NoLicense: LGPLStatus- Simulated and ( 16 and 32 ) programmed into a Spartan 3 FPGA- Synthesised with ISE 10.1- looking at a generic srl fifo now ise can handle suchDescriptionSynchronous FIFO's based upon the SRL feature found in Xilinx FPGA's.Built to be small.In a Spartan 3, the 8 bit wide , 16 bit deep FIFO utilises19 Lutsof which 8 are used as SRL, 11 as Logic.FeaturesPure VHDL, no instantiated components, all inferredsmall size</div>
                    <a href='cores/memory_core/srl_fifo/index.html'>srl_fifo</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_srl_fifo'>code</a>
                </td>
                <td>Feb 28, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core ense:DescriptionThe 'SSRAM interface core' is a collection of designs for easy integration of synchronous srams (ZBT srams) in your designs.Core descriptionCurrently 2 designs have been implemented. ssram_conn and cs_ssram.The entity ssram_conn provides a standard interface to the ssram. It provides the pipeline correction and all IO structures needed for high speed bidirectional data transfers (including full FPGA IO-cell usage).The entity cs_ssram uses the standard interface to turn the ssram into a cycle shared memory. Because ZBTs feature zero bus latency there is no impact on throughput. </div>
                    <a href='cores/memory_core/ssram_interface/index.html'>ssram interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_ssram_interface'>code</a>
                </td>
                <td>Oct 14, 2001</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core :Design doneWishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/memory_core/synchronous_reset_fifo_with_testbench/index.html'>synchronous_reset_fifo with testbench</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_synchronous_reset_fifo_with_testbench'>code</a>
                </td>
                <td>Dec 19, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core oven,Specification doneWishBone Compliant: NoLicense: LGPLIntroductionThe FIFO implementation outlined in this document can easily be configured to suit the followingasynchronous FIFO with different clock domains for read and write sidessynchronous FIFO with programmable flagsmultiple FIFO sharing the same memory resourceThis FIFO can easily be extended to have common wishbone interface for all individual FIFO channels.</div>
                    <a href='cores/memory_core/versatile_fifo/index.html'>versatile fifo</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_versatile_fifo'>code</a>
                </td>
                <td>Feb 11, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core ishBone Compliant: YesLicense: LGPLOverviewThis is a modular memory controller supporting different types of memories. Initial design will have support for SDR SDRAM. Upcoming releases will add support for DDR SDRAM and possibly other variants as wellThe design is built with the following modulesWishbone interfaceDual async FIFO buffersSpecific memory controllerWishbone interfaceThe wishbone interface supports up to 8 independent interfaces where 4 are high priority real time portsDual async FIFO buffersThis design uses up to 8 outgoing and up to 8 incoming FIFO queues. On the outgoing channel</div>
                    <a href='cores/memory_core/versatile_memory_controller/index.html'>versatile memory controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_versatile_memory_controller'>code</a>
                </td>
                <td>Nov 4, 2010</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core hBone Compliant: YesLicense: LGPLDescriptionThis project provides a bridge between asynchronous external memory interfaces found on many processors and a WishBone bus. It is being used on the de1_olpcl2294_system project.</div>
                    <a href='cores/memory_core/wb_async_mem_bridge/index.html'>wb_async_mem_bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_wb_async_mem_bridge'>code</a>
                </td>
                <td>Dec 4, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core done,FPGA provenWishBone Compliant: YesLicense:OverviewThis IP provides a 8-bit or 16-bit bridge for a 32-bit WishBone interface. There is no buffering. The 32-bit transaction is delayed until the transaction is complete. An example using the wb_size_bridge is included that interfaces to an asynchronous memory. The asynchronous memory module has configurable setup times, hold times, and big/little endian support.</div>
                    <a href='cores/memory_core/wb_size_bridge/index.html'>wb_size_bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_wb_size_bridge'>code</a>
                </td>
                <td>Feb 4, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core PGA provenWishBone Compliant: YesLicense: LGPLDescriptionWishbone to Parallel FLASH interface with integral wait-state generator.  This design has been used with the Intel StrataFlash Xilinx Spartan 3E Starter Kit.  Provides an 8-bit data interface to the FLASH, and a 32-bit Wishbone Slave Interface with byte enables.The StrataFlash on the S3E Starter Kit can be programmed using the PicoBlaze RS-232 StrataFlash&bdquo;&tilde; Programmer downloadable from the following site:http://www.xilinx.com/products/boards/s3estarter/reference_designs.htmFeatures- Compatible with Intel StrataFlash J3 on Xil</div>
                    <a href='cores/memory_core/wishbone_flash_interface_for_parallel_flash/index.html'>wishbone flash interface for parallel flash</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_wishbone_flash_interface_for_parallel_flash'>code</a>
                </td>
                <td>Jul 20, 2008</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core o:WishBone Compliant: NoLicense: LGPLDescriptionThis module uses an interface to SPI serial FLASH memory devices to allow reading/writing/erasing of the FLASH.  It includes a state machine that coordinates many of the required commands automatically, to make the process of reading and writing SPI FLASH appear as though a simple RAM is being used.  Moreover, the state machine has an initialization mode which can read bytes out of the selected SPI FLASH device and present them on an 8-bit parallel output port. This initialization mode can be set up so that the module takes action immediately aft</div>
                    <a href='cores/memory_core/wishbone_interface_for_spi_flash/index.html'>wishbone interface for spi flash</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_wishbone_interface_for_spi_flash'>code</a>
                </td>
                <td>Sep 7, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>memory core provenWishBone Compliant: YesLicense:DescriptionThis is a ZBT SRAM controller which is Wishbone rev B.3 compatible (classic + burst r/w operations).PLEASE NOTICE THAT THIS CORE IS LICENSED UNDERhttp://creativecommons.org/licenses/by-nc-sa/3.0/(Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported). That means you may use it only for NON-COMMERCIAL purposes.It has been simulated and verified on a Xilinx Virtex-5 FPGA board of type ML-506.This core is Wishbone compliant, using registered feedback cycles.The only quirk is that, in burst operations, the "wb_tga_i" input must be '0' d</div>
                    <a href='cores/memory_core/zbt_sram_controller/index.html'>zbt sram controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/memory_core_zbt_sram_controller'>code</a>
                </td>
                <td>Sep 4, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <td>
                    <b>OTHER</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionController for 16 character - 2 line LCD displays as used on various Xilinx evaluation boards.Features- 4-bit LCD data interface- One 128bit-wide std_logic_vector input for each diplay line (16x8bit=128). Everything you send to those inputs goes directly to the display.Synthesis- Tested on Xilinx ML501 and ML507- Virtex5: 37 flip flops, 228 LUTs, &gt;300MHz</div>
                    <a href='cores/other/16x2_lcd_controller/index.html'>16x2 lcd controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_16x2_lcd_controller'>code</a>
                </td>
                <td>Nov 28, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other one Compliant: NoLicense: OthersDescriptionPublic domain code of the 2nd order Sigma-Delta DAC. Allows to produce reasonable quality audio signal from single digital ouput pin in the FPGA.The resource consumption is very low (24-bit version of the DAC consumed 5% of slices in xc3s200).Detailed descriptionThis project implements 2nd order DAC, which I have created whenI needed to add the voice output to one of my FPGA based systems.The converter generates 1-bit digital signal on the dout output.You need to connect a simple RC lowpass filter to convert it intothe analog signal.There are d</div>
                    <a href='cores/other/2nd_order_sigma-delta_dac/index.html'>2nd order sigma-delta dac</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_2nd_order_sigma-delta_dac'>code</a>
                </td>
                <td>May 1, 2014</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ovenWishBone Compliant: YesLicense:DescriptionInterface an 8051-compatible microcontroller with the Wishbone bus.Features- Multiplexed 8051 address/data bus to Wishbone Master- Very simple, very small.- Since 8051 has no way to add additional wait-states via an external pin, the Wishbone must be fast enough to complete the cycle in time for the 8051.Status- Tested with Silicon Labs C8051 Microcontroller and Xilinx Coolrunner2 CPLD.- Tested with Silicon Labs C8051 Microcontroller and Xilinx Spartan3 FPGA.- this core is used in the Altair32 Front Panel: www.altair32.com</div>
                    <a href='cores/other/8051_slave_to_wishbone_master_interface/index.html'>8051 slave to wishbone master interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_8051_slave_to_wishbone_master_interface'>code</a>
                </td>
                <td>Jul 25, 2008</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other shBone Compliant: NoLicense:Descriptiona VHDL version of the Intel 8254 timer.Note: uses a synchronous (Wishbone) processor interface, rather than an asynchronous of the Intel 8254.Design assumes asynchronous interface/counter clocks &euro;&ldquo; includes Boolean generics (for each counter) if the same clock is used for interface and counter, or if the clocks are synchronous (different frequency, but with aligned rising edges)FeaturesUses parts from the gh_vhdl_library projectStatusadded version with AMBA APB interface 16 Aug 2008</div>
                    <a href='cores/other/vhdl_8254_timer/index.html'>vhdl 8254 timer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_vhdl_8254_timer'>code</a>
                </td>
                <td>May 14, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other done,Specification doneWishBone Compliant: NoLicense: LGPLUsage and OperationIn order to operate the circuit correctly it must first be reset (asynchronously).Below is a timing diagram that illustrates the reset pulse timing requirements.Note: the circuit only needs to be reset once to operate properly.  Every time the divide factor N changes, the circuit automatically resets itself.SpecificationsThe adjustable frequency divider is designed in two parts:Even DividerWhen the input signal 'N' is set to an even number the even divider is used because the output will be synchronized with the r</div>
                    <a href='cores/other/adjustable_frequency_divider/index.html'>adjustable frequency divider</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_adjustable_frequency_divider'>code</a>
                </td>
                <td>Mar 3, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other e Compliant: YesLicense: LGPLDescriptionThe Advanced Debug Interface is a suite of IP cores and software programs designed to allow a developer to download code to a target CPU in a System-on-Chip, then perform source-level debugging of that code.  In particular, target systems using the OpenRISC 1200 processor and a WishBone bus are currently supported by the Advanced Debug Interface.This system includes four components.  The first component, the "adv_dbg_if" core, is a hardware core designed to interface directly to the OR1200 CPU and a WishBone bus, controlling the CPU and reading and writi</div>
                    <a href='cores/other/advanced_debug_system/index.html'>advanced debug system</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_advanced_debug_system'>code</a>
                </td>
                <td>Jul 4, 2013</td>
                <td>Other</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ishBone Compliant: NoLicense: OthersDescriptionThe Artificial Intelligence System is a neuromorphic FPGA/ASIC project undertaken by a number of volunteers with the scope of simulating real-time celullar and sub-cellular biological processes.</div>
                    <a href='cores/other/aisystem/index.html'>aisystem</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_aisystem'>code</a>
                </td>
                <td>Mar 31, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ne Compliant: NoLicense:DescriptionAlternaScope provides a cheap alternative to expensive oscilloscopes; Using a VGA display and a simple mouse interface, a user can use this scope to look at and measure signals up to about 80Mhz.This kind of scope would be ideal for hobbyists and students looking to learn and debug circuits.Development is based on the Spartan III Starter Kit from Xilinx. The ADC is simply controlled by an MCU (another starter kit: the ATK500 from Atmel) but will soon be controlled by the FPGA (to achieve the faster speeds).In the future, schematics and PCB layout binaries wil</div>
                    <a href='cores/other/an_alternative_oscilloscope/index.html'>an alternative oscilloscope</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_an_alternative_oscilloscope'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ion doneWishBone Compliant: NoLicense: GPLDescriptionThis module is software compatible with the PSG (Programmable Sound Generator) AY-3-8910. It can be used to produce music.</div>
                    <a href='cores/other/ay-3-8910_compatible_module_in_verilog/index.html'>ay-3-8910 compatible module in verilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_ay-3-8910_compatible_module_in_verilog'>code</a>
                </td>
                <td>May 15, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other License: LGPLDescriptionSimple backtracking 9x9 Sudoku solver written in Verilog. Uses an exact cover algorithm to quickly find a solution with minimal backtracking (C implementation of algorithm provided too).High wiring complexity due to explicit "neighbor" interconnect (row, column, and 3x3 sub-block) may result in unroutable designs on FPGA families with reduced routing resources.Working on an Zynq XC702 FPGA.</div>
                    <a href='cores/other/backtracking_sudoku_solver/index.html'>backtracking sudoku solver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_backtracking_sudoku_solver'>code</a>
                </td>
                <td>Sep 5, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other oLicense: GPLDescriptionUses the shift register technology to create a big counter, that gives out a pulse at the period specified as a genericFeaturesDesigned for Xilinx FPGA's, with SRL's.An efficient way of generating a divide by n**16 counter, where N can be very big.Statusbasic counter in cvs</div>
                    <a href='cores/other/bigcounter/index.html'>bigcounter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_bigcounter'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ne Compliant: NoLicense:DescriptionThis project is a collection of small designs involved with clock boundaries.The clock_switch designs are based on an eetimes article.The bc_fifo_basic design is based on ideas from generic_fifo_dc_gray.Features- debouncer: debounce a mechanical switch.- clock_switch2_basic: select 1 of 2 clocks, no glitches.- clock_switch3_basic: select 1 of 3 clocks, no glitches.- clock_switch4_basic: select 1 of 4 clocks, no glitches.- clock_switch8_basic: select 1 of 8 clocks, no glitches.- oc_fifo_basic: a one-clock fifo- bc_fifo_basic: a boundary-crossing fifo- clock_de</div>
                    <a href='cores/other/boundaries/index.html'>boundaries</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_boundaries'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ishBone Compliant: NoLicense: GPLDescriptionThis is for the final project of EC551 Advanced Digital Design using Verilog, a course offered in Boston University. It's basically the classic pacman game on Spartan3 FPGA dev board by Digilent. Team member: Huaxin Dai, Nael Musleh, Krishnan Nair.Features- PS/2 Keyboard Input- WSAD direction control, with reset and pause function- Use standard PS/2 keyboard, no more pushbuttons or 4x4 mini keyboards.- VGA OutputStatus- PS/2 keyboard Interface basically done: may have problem when pressing multiple keys- Basic VGA display done: something shows up on </div>
                    <a href='cores/other/bu_pacman/index.html'>bu pacman</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_bu_pacman'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionsimple fast bubble sort module in verilog</div>
                    <a href='cores/other/bubblesortmodule/index.html'>bubblesortmodule</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_bubblesortmodule'>code</a>
                </td>
                <td>Mar 30, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other e Compliant: NoLicense: BSDDescriptionClock Domain Crossing micro FIFO (Verilog/SystemVerilog):cdc_ufifo provide an minimalist fifo. Most advantage - not use RAM blocks.it can be 4 buffer data cells minimum.by default used implementation without ram, only standart register cells used, and it can be selected if need. most slowest stage is the output multiplexorShadowed outputs: provide an register after multiplexer to remove data unsynchronized changes from outputs when skiped some cycles.tested:CycloneII project works on up to 50 MHz data transfers</div>
                    <a href='cores/other/cdc_micro_fifo/index.html'>cdc micro fifo</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_cdc_micro_fifo'>code</a>
                </td>
                <td>Jan 28, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other doneWishBone Compliant: YesLicense: BSDDescriptionThe Computer Operating Properly Module, COP, is a watchdog timer module that triggers a system reset if it is not regularly serviced by writing two specific words to its control registers. The intention of the module is to bring an embedded system back to a &euro;&oelig;good&euro;? state after the software program has lost control of the system.</div>
                    <a href='cores/other/computer_operating_properly/index.html'>computer operating properly</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_computer_operating_properly'>code</a>
                </td>
                <td>Jan 27, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other t: NoLicense: LGPLDescriptionThis application parses a Verilog define file and presents a GUI to the user</div>
                    <a href='cores/other/configurator/index.html'>configurator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_configurator'>code</a>
                </td>
                <td>Aug 24, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other mpliant: NoLicense: GPLCONNECT-6 SOLVERConnect-6 is usually played on a 19 &mdash; 19 GO Board, with each player having either black orwhite pieces. The Black starts the game with only one move, and after that each player makestwo moves at a time. The game stops when one of the player forms a vertical, horizontal ordiagonal line connecting six pieces of his color, or the board is full.The fact that makes this game more interesting, is that each player makes two moves at a time,except for the first move. This considerably increases the search space for moves and end-games.Because of these reaso</div>
                    <a href='cores/other/connect-6_solver/index.html'>connect-6 solver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_connect-6_solver'>code</a>
                </td>
                <td>Feb 14, 2012</td>
                <td>C/C++</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other t: NoLicense: LGPLDescriptionThis is a date/time keeping core. It uses an external 100,60 or 50 Hz time-of-day signal to update a group of BCD counters which record the date and time. The date and time is presented as a 16 digit BCD format YYYYMMDDHHMMSSJJ which fits into a 64-bit word.Features- optional 50,60, or 100 Hz time-keeping- 64 bit bus interface-    internally decoded to respond in address range $DC0400-$DC0418- Mars timekeeping option (millennium style calendar)- leap year tracking- independent system bus and time-of-day clocks- alarm setting</div>
                    <a href='cores/other/datetime/index.html'>datetime</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_datetime'>code</a>
                </td>
                <td>Jun 17, 2012</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other Compliant: YesLicense: GPLDescriptionA VHDL implementation of the open DEFLATE data compression algorithm. The DEFLATE standard is specified in RFC 1951 and was jointly developed by Jean-loup Gailly and Mark Adler.  More information about the DEFLATE algorithm is available on the zlib library home page www.zlib.orgThe full text of the deflate specification and a brief explanation are available on :http://www.gzip.org/zlib/rfc-deflate.htmlAt the core the algorithm uses LZ77 compression, a veriy nice explanation for which is available on the zlib website and I have quoted belowLZ77 compressionLZ</div>
                    <a href='cores/other/deflate/index.html'>deflate</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_deflate'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other NoLicense: LGPLDescriptionThis is an easily configurable systolic array of processors to compute the optimal alignment between two DNA sequences. It supports affine gap penalties, and is configurable between local (smith-waterman) and global (needleman-wunsch) alignment algorithms by setting an internal register. All code is in Verilog.</div>
                    <a href='cores/other/dna_sequence_alignment_accelerator/index.html'>dna sequence alignment accelerator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_dna_sequence_alignment_accelerator'>code</a>
                </td>
                <td>Aug 17, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ovenWishBone Compliant: YesLicense:DescriptionThis is a Motorola DragonBall/68K to Wishbone bridge. The core translates the 16bit DragonBall/68K bus into a full featured 16bit Wishbone master bus.Features- 16bit Motorola DragonBall/68K Interface- 16bit full featured RevB.3 Wishbone Classic Master interface- programmable address-bus size- static synchronous design- fully synthesisable- 6LUTs in a Spartan-II, 32LCELLs in an ACEXStatusDesign is finished and available in Verilog for download from OpenCores CVS.</div>
                    <a href='cores/other/dragonball-68k_wishbone_interface/index.html'>dragonball/68k wishbone interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_dragonball-68k_wishbone_interface'>code</a>
                </td>
                <td>Feb 14, 2004</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other se:FeaturesLeGall 5/3Max image size: 512x512 grey scaleMax levels: 7Tools: ISE Foundation 6.3i; ModelSim 5.7gDescriptionThis core implements Forward and Inverse Discrete Wavelet Transform (FDWT and IDWT) on still image. Wavelet LeGall 5/3 is selected in design. The project is simulated on ModelSim 5.7g and going to implement on Spartan-3 Starter Kit.Status11/10/2004: started20/12/2004: Core is correctly simulated on Lena image (512x512).</div>
                    <a href='cores/other/dwt_coprocessor_on_still_image/index.html'>dwt coprocessor on still image</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_dwt_coprocessor_on_still_image'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other iant: NoLicense:DescriptionThe aim of this Core is to track the first file savedinto a FAT16 volume and to read the information from it offering those data to a Wishbone bus trough a Wishbone slave interface. The Core has an IDE interface that permits the attachment of devices as Compact Flash (no DMA support). It uses about 300 Xilinx Spartan II slices (if Area optimization is chossen about 285).Internally it has two Modules that can be used indepently. Both of them are implemented using a Picoblaze Programmable State Machine, using Xilinx BlockRams for instructions. Those modules are:1 - HOS</div>
                    <a href='cores/other/first_file_reader_fat16/index.html'>first file reader fat16</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_first_file_reader_fat16'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other e: GPLDescriptionThis project is to design a Fuzzy Logic Hardware Accelerator (FLHA) that is WishBone compatible. FLHA is capable of generating fuzzy rule matrix and inference for it. The input and output data will be 64-bit. Each input and output data will have 8 elements in each universal space, and each degree of membership is a discreet set of 256 members from 0 to 1. For the rule matrix, it can either generate it based on the input data or directly input it to its matrix. When the rule memory has already builded, a master can read the whole matrix from this FLHA. For inference, the output</div>
                    <a href='cores/other/fuzzy_logic_hardware_accelerator/index.html'>fuzzy logic hardware accelerator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_fuzzy_logic_hardware_accelerator'>code</a>
                </td>
                <td>Dec 25, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other : NoLicense:DescriptionCVS is currently out of date, update when I get the time (as well as things such as schematics)Custom built and designed video game system. Also includes hardware interface C routines and code for StarCell XF-1 (the 'release' game). All designs are open source and specification are free to be modified by the community. Specifications are currently for an early 16 bit system.Specifications- Graphics accelerator (XESS XSA-50 Spartan II based development board)- 320x240 resolution at 64 colors, plus 64 possible intensity field colors- 8 MB graphics RAM (approximately 7.5 MB</div>
                    <a href='cores/other/g9_impulse_video_game_system/index.html'>g9 impulse video game system</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_g9_impulse_video_game_system'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other  provenWishBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/other/general-purpose_pulse-processing_algorithm/index.html'>general-purpose pulse-processing algorithm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_general-purpose_pulse-processing_algorithm'>code</a>
                </td>
                <td>Dec 5, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ,FPGA provenWishBone Compliant: NoLicense: OthersDescriptionVectorial generator:-Interface: bit or bus-Configuration: dynamic-Applications: waveform generator, serial or parallel communicationExamples:-Included in the own .vhd headfileConfiguration:-It is necessary to adjust the following type which defines the input size (it affects to area resources):SUBTYPE valores_vector  IS INTEGER RANGE -1 TO nat_synth_65536'high;  -- values range for each sample (always from -1)TYPE    vector_integer  IS ARRAY (nat_synth_128'high DOWNTO 0) OF valores_vector; -- number of samples*2where:SUBTYPE nat_synth</div>
                    <a href='cores/other/gen_vectorial/index.html'>gen_vectorial</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_gen_vectorial'>code</a>
                </td>
                <td>Mar 31, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other provenWishBone Compliant: NoLicense: OthersStatus- [Match 3rd - 2009] Initial RTL benchmark downloads from Imperial College addedDescriptionGroundHog 2009 is a benchmark suite for reconfigurable architectures in the mobile domain.  The benchmark suite can be downloaded fromhttp://cc.doc.ic.ac.uk/projects/GROUNDHOG/.The benchmark suite includes designs described in a high-level format that is non-synthesizable.  For this reason, this project on OpenCores is a space where individuals in the community can release synthesizable (and compilable) versions of their implementations of the 6 benchmarks</div>
                    <a href='cores/other/groundhog_2009-benchmark_suite_for_mobile_applicat/index.html'>groundhog 2009-benchmark suite for mobile applicat</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_groundhog_2009-benchmark_suite_for_mobile_applicat'>code</a>
                </td>
                <td>Nov 2, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other cense: GPLDescriptionDescription of project..Features- feature1- feature1.1-feature1.2-feature2</div>
                    <a href='cores/other/gsc/index.html'>gsc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_gsc'>code</a>
                </td>
                <td>Feb 22, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ant: NoLicense: GPLHardware looping unitTha main purpose of the hardware looping unit (HWLU) is to enhance program control units found in modern microprocessors, by efficiently handling loop increments and branches in nested loop structures. It is based on recently published work (details can be found in the specification document). The main advantage of the presented architecture is that successive last iterations of nested loops are performed in a single cycle. This architecture can be useful in the case that all data processing in context of a nested loop structure is performed in the inner</div>
                    <a href='cores/other/hardware_looping_unit/index.html'>hardware looping unit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_hardware_looping_unit'>code</a>
                </td>
                <td>Jul 9, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other PGA proven,Specification doneWishBone Compliant: YesLicense: GPLDescriptionThis project features a full-hardware sound compressor using the well known algorithm: IMA ADPCM.The core acts as a slave WISHBONE device.The output is perfectly compatible with any sound player with the IMA ADPCM codec (included by default in every Windows). Includes a testbench that takes an uncompressed PCM 16 bits Mono WAV file and outputs an IMA ADPCM compressed WAV file.Compression ratio is fixed for IMA-ADPCM, being 4:1.PLEASE NOTICE THAT THIS CORE IS LICENSED UNDERhttp://creativecommons.org/licenses/by-nc-sa/3.0</div>
                    <a href='cores/other/ima_adpcm_sound_encoder/index.html'>ima adpcm sound encoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_ima_adpcm_sound_encoder'>code</a>
                </td>
                <td>Apr 27, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other e Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/other/interrupt_controller_68k/index.html'>interrupt controller 68k</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_interrupt_controller_68k'>code</a>
                </td>
                <td>Mar 18, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other DescriptionThis implementation of the Test Access Port (TAP) is fully IEEE 1149.1 compliant. It includes a TAP controller, a 4-bit instruction register and three test data registers: idcode register, bypass register and boundary scan register. Boundary scan register is connected to eight pins (2 inputs, 2 outputs, 2 tristatable outputs and 2 bidirectional pins). Besides the Verilog code, a BSDL file is also provided. The number of pins can be easily increased by following the instructions. The design had been tested with the JTAG Technologies testing equipment (The TAP controller was implement</div>
                    <a href='cores/other/jtag_test_access_port_tap/index.html'>jtag test access port tap</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_jtag_test_access_port_tap'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ishBone Compliant: NoLicense: GPLDescriptionThe controller scans the keyboard by making a different column in "rows" logic-0therefor the inputs "cols" have to be PULL-UP high. It processes the inputs "cols" andthe newly found keychange (keypress or keyrelease) is converted to the correspondingscancode (translated set2). Note that an interrupt pin is attached as well to make itpossible to connect this controller to a PIC.Also note that the keyboard_controller uses an internal clock divider to dividethe system clock of 50 Mhz to 100 kHz. Should you want to use an other frequencythan 100 kHz plea</div>
                    <a href='cores/other/keyboardcontroller/index.html'>keyboardcontroller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_keyboardcontroller'>code</a>
                </td>
                <td>May 3, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other YesLicense:DescriptionThis is a very small and simple module, which scans through an X-Y matrix of keys, and produces a "snapshot" of bits which represent the sampled state of the keyswitches during the scan.There is memory in the module, so that the outputs are held constant during a scan, and updated simultaneously.  The keys are sampled sequentially, but the memory stores up all of the keyswitch data until the final output "snapshot" is produced.This module is parameterized Verilog, and is recommended for use with small matrix type keypads.  It has been tested in real hardware.Features- Par</div>
                    <a href='cores/other/keypad_scanner/index.html'>keypad scanner</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_keypad_scanner'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other nt: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/other/lcd_block/index.html'>lcd block</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_lcd_block'>code</a>
                </td>
                <td>May 18, 2012</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ne,FPGA provenWishBone Compliant: NoLicense: LGPLDescription LFSR Counter Generator is a command-line application that generates Verilog or VHDL code for an LFSR counter of any value up to 63 bit wide. The code is written in C and is cross-platform compatible. There is an online version of the tool atOutputLogic.comIt's more convenient to access, but the online tool is slower to generate the code for large counter values.</div>
                    <a href='cores/other/lfsr_counter_generator/index.html'>lfsr counter generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_lfsr_counter_generator'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>C/C++</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other WishBone Compliant: NoLicense: LGPLDescriptionHave you ever wanted to add some color to your project?  Then this might be your answer.  The LPD8806 RGB LED strings are available for low cost from various sites on the internet, and they come in strips which can be cut or joined to the desired length.  Since the Red/Green/Blue (RGB) LEDs on the strip are driven by a serial controller IC that is also on the strip, your project can set each LED color independently of the others.The connections to the LED strip include 4 wires: +5V, GND, clock and data.  It turns out that these LED strips will also</div>
                    <a href='cores/other/lpd8806_rgb_led_string_driver/index.html'>lpd8806 rgb led string driver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_lpd8806_rgb_led_string_driver'>code</a>
                </td>
                <td>Aug 20, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ishBone Compliant: YesLicense: LGPL[EN] DescriptionThe aim of the project is to develop oscilloscope functions (conversion control, trigger, FFT, ...) in several cores and implement a usefull oscilloscope in a development board. The results are shown in a computer with a simple software.The software will be developed using LGPL tools and distributed under such license, like the cores.The beginig of this project is part of a universitary work in National University of San Luis, Argentina. For now, it is only a unipersonal project, but in some months it will have more maintainers.[EN] Features</div>
                    <a href='cores/other/modular_oscilloscope/index.html'>modular oscilloscope</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_modular_oscilloscope'>code</a>
                </td>
                <td>Oct 15, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other  proven,Specification doneWishBone Compliant: NoLicense: LGPLDevelopment StatusThe core is tested and is being used in FPGA hardware in several projects.The scope screen below shows 7 switches being debounced with 50us of debounce time. See in the photo at right the 1 clock cycle STRB pulse right after the output register loading. The system clock in the example is 100MHz.Related LinksThis core is being used in the SPI_MASTER_SLAVE verification test circuit:http://opencores.org/project,spi_master_slaveTo get the latest version:http://opencores.org/download,debouncer_vhdlIf you have issues you </div>
                    <a href='cores/other/multiple_switch_debouncer_in_vhdl/index.html'>multiple switch debouncer in vhdl</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_multiple_switch_debouncer_in_vhdl'>code</a>
                </td>
                <td>Apr 20, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other cense: LGPL</div>
                    <a href='cores/other/nios_ii_custom_instructions/index.html'>nios ii custom instructions</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_nios_ii_custom_instructions'>code</a>
                </td>
                <td>Feb 23, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ense:DescriptionStatusI just started reading the Ogg Vorbis spec. and I'm seeing if other people are interested.</div>
                    <a href='cores/other/ogg_vorbis_encoder-decoder_for_virtex-ii_pro/index.html'>ogg vorbis encoder/decoder for virtex-ii pro</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_ogg_vorbis_encoder-decoder_for_virtex-ii_pro'>code</a>
                </td>
                <td>Apr 19, 2010</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other t: NoLicense: LGPLDescriptionThis project will have a slow start .. I won't be able to support new joiners until at least 2016.However, advice and experience is welcome, especially if there are LGPL/BSD projects I missed or that can be reused (eg the 'esoc')ExpectationThe open_hitter will be accessible to fpga newbies yet offer a realistic high frequency trading system, in open source.  In delivery terms, an HFT techie might buy an ebay ML605 demo board and use an old Mac to demonstrate an out-of-the box working and extendable prototype at their workplace, and so bring more firms into this tec</div>
                    <a href='cores/other/open_hitter_for_traded_options_and_futures/index.html'>open hitter for traded options and futures</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_open_hitter_for_traded_options_and_futures'>code</a>
                </td>
                <td>Apr 21, 2015</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other Compliant: NoLicense: GPLDescriptionThis is a Tcl/Tk script to configure OpenRisc 1200 options.I use it to configure the core and I think it could be usefull for other people.The look is very similar to LEON graphicall configuration tool.For comments, feedback, patches or whatever you want javier.castillo@urjc.esThis tool is provided under the GPL license  Universidad Rey Juan Carlos (Spain)www.gdhwsw.urjc.es</div>
                    <a href='cores/other/openrisc_1200_graphic_configuration_tool/index.html'>openrisc 1200 graphic configuration tool</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_openrisc_1200_graphic_configuration_tool'>code</a>
                </td>
                <td>Apr 9, 2010</td>
                <td>Other</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other t: NoLicense: LGPLDescriptionSee video on YouTube:http://www.youtube.com/watch?v=UsYXRPRBsmk</div>
                    <a href='cores/other/oscilloscope/index.html'>oscilloscope</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_oscilloscope'>code</a>
                </td>
                <td>Sep 18, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other oneWishBone Compliant: NoLicense: LGPLDescriptionCRC Generator is a command-line application that generates Verilog or VHDL code for a parallel CRC of any data width between 1 and 1024 and polynomial width between 1 and 1024. The CRC can be custom or protocol specific, for example PCI Express, USB5, USB16, 802.3, SATA.The code is written in C and is cross-platform compatibleThere is an online version of the tool atOutputLogic.comIt's more convenient to access, but the online tool is slower to generate the code for CRC with large data and polynomial widths.</div>
                    <a href='cores/other/parallel_crc_generator/index.html'>parallel crc generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_parallel_crc_generator'>code</a>
                </td>
                <td>Jul 30, 2014</td>
                <td>C/C++</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other e:DescriptionPerlilog is a design tool, whose main target is easy integration of Verilog IP cores for System-on-Chip (SoC) designs.At a smaller scale, Perlilog is a great starting point for writing scripts which handle Verilog code in general. It comes with a rich set of functions, that can be used for several purposes, such as instantiation of ASIC pads, automatic connection and generation of simple Verilog modules, and so on.The philosophy behind Perilog is that an IP core should be like a black box. Fitting it for a certain purpose should be as easy as defining the desired requirements. Con</div>
                    <a href='cores/other/perlilog/index.html'>perlilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_perlilog'>code</a>
                </td>
                <td>Mar 6, 2004</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other sign doneWishBone Compliant: NoLicense:DescriptionPicoblaze's interrupt controller expands picoblaze's interrupt (up to 8-interrupt sources is supported).The controller is put as input port. If interrupt occurs, the firmware will need to read this port, do some interrupt handling, turn-off/ACK the interrupt source and ACK the interrupt controller.The firmware's sample code, along with testbenches and picoblaze implementation is within the project.Free beer for any excellent ideas that is accepted..(but you will need to visit me in Bali first ^^ )..Features- Configurable input sources- Based on</div>
                    <a href='cores/other/picoblazes_interrupt_controller/index.html'>picoblazes interrupt controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_picoblazes_interrupt_controller'>code</a>
                </td>
                <td>Dec 22, 2006</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other liant: NoLicense: LGPLDescriptionFast binary counter, designed to minimize logic path length in between flip-flopsto one gate (MUX/AND) only, at the expense of not so straightforward binary counting.Aimed to slow architectures without fast carry chain.SummaryThe reason for this design has emerged while using Actel (MicroSemi)ProASIC/IGLOO architecture, lacking any hardwired support for fast carry.During our work on Actel FPGAs (basically, 3-LUT &amp; DFF only), we wereaware of following types of faster counters:- LFSR counter- Johnson counter- "RLA counter" (as tailored using Actel's SmartGen </div>
                    <a href='cores/other/pipelined_synchronous_pulse_counter/index.html'>pipelined synchronous pulse counter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_pipelined_synchronous_pulse_counter'>code</a>
                </td>
                <td>Oct 1, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other doneWishBone Compliant: YesLicense: BSDDescriptionThe Programmable Interval Timer Module, PIT, is a simple timer to generate aperiodic signal for a microcontroller system. This signal may be used fora variety of purposes such as triggering the start of an Analog to Digital orDigital to Analog conversion, as a periodic system interrupt, real time clockupdate, or to synchronize the start of various other hardware processes.Features	16 bit Main Counter with programmable modulo	15 bit Prescale Counter with programmable modulo selections	Slave mode for synchronizing multiple PIT modules	Interrupt o</div>
                    <a href='cores/other/programmable_interval_timer/index.html'>programmable interval timer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_programmable_interval_timer'>code</a>
                </td>
                <td>Feb 10, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other one,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project is a Logic Unit that works as an interface between the PS/2 keyboard and any other microprocessor. It outputs the scan code of the key being pressed, it count the number of pressings.As an FPGA test , this project includes displaying the last 2 keys pressed on 7-Segment Display Units, it displays the numbers of pressings on some other LEDs.StatusTill Now, it outputs the Hexa Scan Code on the 7-Segment Display Units on an FPGA Kit for test and debugging purposes.</div>
                    <a href='cores/other/ps-2_keyboard_interface/index.html'>ps/2 keyboard interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_ps-2_keyboard_interface'>code</a>
                </td>
                <td>Dec 3, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other escriptionThe PS/2 interface project (ps2_interface) is interface hardware to allow using a ps2 mouse or keyboard in your project. The code is written in Verilog, and was sythesized into a Xilinx SpartanII XC2S200 chip. Debugging was done with an HP16500 series logic analyzer, and there is no testbench for these interfaces.For the keyboard interface, there is translation from scan codes into ASCII characters, for those scan codes that have ASCII equivalents. Also, the keyboard interface traps the left/right shift scan codes, and produces uppercase ascii when appropriate. This means that the ke</div>
                    <a href='cores/other/ps2_interface/index.html'>ps2 interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_ps2_interface'>code</a>
                </td>
                <td>Mar 10, 2013</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other pecification doneWishBone Compliant: YesLicense: LGPLDescriptionPulse Width ModulatorFeatures&euro; Work as one PWM or one timer.&euro; 16 bits main counter.&euro; PWM/Timer can choose between Wishbone interface clock or external clock as working clock.&euro; PWM can choose between dedicated duty cycle input or internal register as source of duty cycle.&euro; Duty cycle and period can be changed at runtime.&euro; Hosted through Wishbone slave interface.&euro; Working clock's frequency can be divided to at most 1/65535 of original frequency.&euro; Period register also serves as timer target reg</div>
                    <a href='cores/other/pwm/index.html'>pwm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_pwm'>code</a>
                </td>
                <td>Oct 13, 2012</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other DescriptionPWM/Timer/Counter (PTC) IP core is a user-programmable PWM, Timer and Counter controller. Its use is to implement functions like Pulse Width Modulation (PWM), timer and counter facilities.FeaturesThe following lists the main features of PTC IP core:- 32-bit counter/timer facility- single-run or continues run of PTC counter  Programmable PWM mode- System clock and external clock sources for timer functionality- HI/LO Reference and Capture registers- Three-state control for PWM output driver- PWM/Timer/Counter functionalities can cause an interrupt to the CPU- </div>
                    <a href='cores/other/pwm-timer-counter_ptc_core/index.html'>pwm/timer/counter ptc core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_pwm-timer-counter_ptc_core'>code</a>
                </td>
                <td>Nov 17, 2006</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other Compliant: YesLicense: LGPLDescriptionVHDL Implementation of a quadrature decoder module with a Wishbone bus interface.  This module has the following features:UPDATED per version v1.0.0 Release (July 2010)--      July, 2010--      1)Release version v1.0.0--      2)Changes from prior release:--      a) Bit 3 of the Quadrature Control Register (offset 0x00) is now changed--      functions, to enable / disable of the Index Zero Count function.  When--      the bit is 0, an index event does not affect the count. When the bit is--      1, and index events are permitted, the internal quadrature cou</div>
                    <a href='cores/other/quadrature_decoder_for_optical_encoders/index.html'>quadrature decoder for optical encoders</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_quadrature_decoder_for_optical_encoders'>code</a>
                </td>
                <td>Jul 12, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other n done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionPoisson process generator. The time between each pair of consecutive pulses has an exponential distribution with desired rate. h auxiliary pseudo-random uniform generator is based on 32-bit LFSR. The deign is tested on MICROSEMI IGLOO2 FPGA.Histogram of the number of clocks between output pulses:Result of simulation for the rate of one pulse per 16 clocks (parameter LN2_PERIOD=16):</div>
                    <a href='cores/other/random_pulse_generator/index.html'>random pulse generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_random_pulse_generator'>code</a>
                </td>
                <td>Apr 22, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other  Compliant: NoLicense: GPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/other/round_robin_arbiter/index.html'>round robin arbiter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_round_robin_arbiter'>code</a>
                </td>
                <td>Mar 26, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other liant: NoLicense: LGPLDescriptionHere i am trying to demonstrate my idea, that Russell's paradox of set theory can be solved by computer simulation in discrete time. It leads to oscillating sets, meaning theese sets automatically become existent and then disappear over time by their definition. Furthermore i try to describe it in such an event driven way, where theoretically the time between the events can be infinitely short...</div>
                    <a href='cores/other/russells_paradox/index.html'>russells paradox</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_russells_paradox'>code</a>
                </td>
                <td>Jan 21, 2015</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ,FPGA provenWishBone Compliant: NoLicense: BSDDescriptionA scalable synchronous round-robin arbiter. The arbiter is designed to run at reasonable clock speeds with up to hundreds of request lines, and it grants in just a few clock cycles. The arbiter's interface has individual request and grant lines for each requesting device, as well as a binary encoded grant that can be used to control a bus multiplexer.The basic structure is a tree of small arbiters connected to form a larger arbiter. The tree structure yields linear size scaling and logarithmic delay scaling with respect to the number of </div>
                    <a href='cores/other/scalable_arbiter/index.html'>scalable arbiter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_scalable_arbiter'>code</a>
                </td>
                <td>Jan 8, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other  NoLicense:DescriptionConfigure Altera and Xilinx FPGAs using a small low cost micro-controller and commodity SD/MMC/SPI flash memory.There are already solutions available that use a CPLD and SD/MMC/SPI flash memory, but this scheme uses a very small C8051 micro-controller in place of the CPLD, and this has several advantages.1. Smaller. C8051 is available in a 4mm x 4mm package.2. Very few additional components. eg C8051 has internal oscillator.3. Less programming headers. Only one small header required.4. A local microprocessor can be connected to the C8051 UART port, and program the flash m</div>
                    <a href='cores/other/sd-mmc-spiflash_fpga_config/index.html'>sd/mmc/spiflash fpga config</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_sd-mmc-spiflash_fpga_config'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Other</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other en,Specification doneWishBone Compliant: YesLicense: GPLDescriptionThis core is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.16-bit 48kHz stereo onlyFull duplex supportDMA support (Wishbone master)Codec register access support.Ultra small size.More informationCore documentationCSR bus specifications</div>
                    <a href='cores/other/simple_ac97_controller/index.html'>simple ac97 controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_simple_ac97_controller'>code</a>
                </td>
                <td>Aug 7, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other one,FPGA provenWishBone Compliant: NoLicense: GPLDescriptionThe design of the All Digital FM Receiver circuit in this project uses Phase Locked Loop (PLL) as the main core. The task of the PLL is to maintain coherence between the input (modulated) signal frequency, and the respective output frequency, via phase comparison. This self-correcting ability of the system also allows the PLL to track the frequency changes of the input signal once it is locked.In the new architecture we propose improvement of the new architecture of digital FM demodulator. This work enhances signal quality, system clo</div>
                    <a href='cores/other/simple_all_digital_fm_receiver/index.html'>simple all digital fm receiver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_simple_all_digital_fm_receiver'>code</a>
                </td>
                <td>Jan 7, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ishBone Compliant: NoLicense: BSDSimple FM ReceiverSimple implementation of FM Receiver to demodulate square wave signal modulatedin FM. This design uses PLL to demodulate FM modulated signal.Features- Synthesizable- This design can be synthesize using Xilinx 6.3i- This design can be simulated and synthesized usinghttp://asim.lip6.fr/recherche/alliance/(Alliance 5.0)- Simple- Use it to understand PLL to see how FM Receiver works.- Good for introduction in design process.- Modular design, can be use for other design.</div>
                    <a href='cores/other/simple_fm_receiver/index.html'>simple fm receiver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_simple_fm_receiver'>code</a>
                </td>
                <td>Mar 19, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other  provenWishBone Compliant: YesLicense:DescriptionSimple General Purpose IO port. It supports up to 8 GPIO pins. Each pin is individually programmable as either input or output. The core features an 8bit wishbone interface. Wider wishbone interfaces are easily supported by using multiple instances (e.g. 4 simple GPIO cores provide a 32bit wishbone interface).Very simple, very small.Features- Up to 8 GPIO pins per core- Each GPIO pin individually programmable as either input or output- Static synchronous design- Fully synthesisable- 11 LUTs in a Spartan-II, 43 LCELLs in an ACEXStatusDesign is fi</div>
                    <a href='cores/other/simple_general_purpose_io/index.html'>simple general purpose io</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_simple_general_purpose_io'>code</a>
                </td>
                <td>Sep 7, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other t: NoLicense: LGPLDescriptionThis simple HD44780 LCD Driver takes care of the most basic commands such as clear screen, cursor home and writing characters with single bit inputs. It uses the 8-bit data tranfer mode, 4-bit is not supported. The user can supply a number of timing parameters to taylor the timing between the driver and the LCD. Both Busy Flag reading and non-BF reading are supported.</div>
                    <a href='cores/other/simple_hd44780_driver/index.html'>simple hd44780 driver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_simple_hd44780_driver'>code</a>
                </td>
                <td>Oct 26, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ne Compliant: YesLicense:DescriptionSimple programmable interrupt controller. It supports up to 8 interrupt sources. Polarity and sensitivity (either edge or level) is programmable per interrupt source. The core features an 8bit wishbone interface. Wider wishbone interfaces are easily supported by using multiple instances.Very simple, very small.Features- Up to 8 interrupt sources- Sensitivity (edge/level) programmable per interrupt source- Polarity programmable per source- Static synchronous design- Fully synthesisable- 48 LUTs in a Spartan-II, 83 LCELLs in an ACEXStatusDesign is finished and</div>
                    <a href='cores/other/simple_programmable_interrupt_controller/index.html'>simple programmable interrupt controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_simple_programmable_interrupt_controller'>code</a>
                </td>
                <td>Mar 4, 2008</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ant: NoLicense: LGPLDescriptionThe goal of this project is to provide a simple traffic light controller for different transport modeling purposes like model railways.I repeat "modeling purposes", don't even think about using it in real-world applications :)Features- Very simple, stand-alone Traffic Light Controller- Through generics parameterizable light timing lengths- Testbench written in VHDL.- Makefile for synthesis with XST (Xilinx) and simulation with Modelsim (Mentor Graphics).StatusThe main phase of the project is already finished, but a lot of additional features still need to be adde</div>
                    <a href='cores/other/simple_traffic_light_controller_for_modelmaking_pu/index.html'>simple traffic light controller for modelmaking pu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_simple_traffic_light_controller_for_modelmaking_pu'>code</a>
                </td>
                <td>Jun 18, 2008</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other esLicense:DescriptionDebug Interface is used for development purposes (debugging). It is an interface between the CPU(s), peripheral cores and any commercial debugger/emulator. The external debugger or BS tester connects to the core via JTAG port that is fully IEEE 1149.1 compatible. For that reasonjtag TAPneeds to be used together with this core.Status- New version tested with a test bench and in real HW. (April 8, 2004)- Old debug (development) was separated into two different projects. Debug interface is rewritten, documentation updated. Use rel_22 tag for downloading. [January 27, 2004]- A</div>
                    <a href='cores/other/soc_debug_interface/index.html'>soc debug interface</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_soc_debug_interface'>code</a>
                </td>
                <td>Aug 5, 2011</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other venWishBone Compliant: NoLicense: LGPLDescriptionA simple module to get the most of your on board heartbeat LED. Change or add more sequences easily in parameters file.</div>
                    <a href='cores/other/status_led/index.html'>status led</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_status_led'>code</a>
                </td>
                <td>Sep 14, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other : NoLicense: GPLPLEASE NOTEThis work is managed via git:https://github.com/feddischson/soc_makerand synchronized to this SVN repository.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!DUE TO A OPENCORES SVN SERVER BUG, THE SYNCHRONIZATION FAILS FOR REVISION 11 (AND EVERYTHING LATER).THIS MEANS, THAT THE CURRENT SVN REPOSITORY IS NOT UP TO DATE.PLEASE USEhttps://github.com/feddischson/soc_makerUNTIL THIS ISSUE IS FIXED AND TRACK THE ISSUE HERE:http://opencores.org/forum,Other,0,5524!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!DescriptionThe System-on-Chip (SoC) Maker is a tool to design and create SoCs in a simple </div>
                    <a href='cores/other/system-on-chip_maker/index.html'>system-on-chip maker</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_system-on-chip_maker'>code</a>
                </td>
                <td>Sep 11, 2014</td>
                <td>Other</td>
                <td>Planning</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other  NoLicense:Features- Full source code- PDF documentation- Written using lex and yacc toolsDescriptionThe sc2v translator is a software tool that translates a SystemC RT description into a Verilog equivalent one.The sc2v translator is based on lex and yacc tools.You need lex and yacc installed in order to compile sc2v.This work is given by Universidad Rey Juan Carlos (Spain)www.gdhwsw.urjc.esStatus- Version 0.5- TODO: See README File- LOOKING FOR CONTRIBUTORS</div>
                    <a href='cores/other/systemc_to_verilog_synthesizable_subset_translator/index.html'>systemc to verilog synthesizable subset translator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_systemc_to_verilog_synthesizable_subset_translator'>code</a>
                </td>
                <td>Apr 9, 2010</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other one Compliant: NoLicense: LGPLDescriptionA SystemC/Verilog random number generator based on the combination of a LFSR and a CASR with very good statisticall properties.Based on the Thomas E. Tkacik work available at:http://ece.gmu.edu/crypto/ches02/talks_files/Tkacik.pdfThis work is given by Universidad Rey Juan Carlos (Spain)www.gdhwsw.urjc.esFeatures- Very good statisticall properties- SynthesizableStatus- Done</div>
                    <a href='cores/other/systemc-verilog_random_number_generator/index.html'>systemc/verilog random number generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_systemc-verilog_random_number_generator'>code</a>
                </td>
                <td>Apr 9, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ompliant: YesLicense: LGPLDescriptionTechnica Corporation is sponsoring a new open source project.  Wizardry, an open source network intrusion detection system, provides protocol analysis as well as deep packet inspection.  Target for the Virtex 4 FPGA platform, this project includes several hardware components that enable basic network intrusion detection functionality:&euro;	The Embedded Protocol Analyzing Classifier (EmPAC) is designed to perform the task of packet classification through protocol analysis.  Its goal is to take an unclassified byte stream coming from the Ethernet Physical La</div>
                    <a href='cores/other/the_wizardry_project/index.html'>the wizardry project</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_the_wizardry_project'>code</a>
                </td>
                <td>Jan 21, 2010</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ecification doneWishBone Compliant: NoLicense: LGPLAbout the TosNet projectTosNet is developed at theUniversity of Southern Denmark, and is intended to:Reduce the development time of experimental robotic controllers to arrive faster and cheaper at fully working demonstrations of new technology and concepts.Increase the reusability of experimental systems and components, thus increasing the life-span and utilization of these, and reducing the amount of redundant work.Ease the use of interacting with experimental low-level controller, to open experimental robotics up to a wider audience, and to </div>
                    <a href='cores/other/tosnet_framework/index.html'>tosnet framework</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_tosnet_framework'>code</a>
                </td>
                <td>Sep 7, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other oLicense: OthersInfoI had finished simple parser and I am working for Code Generate.</div>
                    <a href='cores/other/turbo-toy_system_verilog_compiler/index.html'>turbo/toy system verilog compiler</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_turbo-toy_system_verilog_compiler'>code</a>
                </td>
                <td>Sep 9, 2011</td>
                <td>Bluespe</td>
                <td>Planning</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other  NoLicense: LGPLDescriptionHi, Everyone, You can find detailed information about project inthis pdf.The pdf explains most of the things about the project like:1. Port list for unconfuser.2. Address for each pad.3. Polynomials used for each pad.4. Steps to be followed to code state machine.5. Diagrams briefly explaining confuser and unconfuser working.Hope this much information would be sufficient to grasp everything about project.The project need to be optimized for number of gates, Have 12k count for now need to make it to around 8k. Hope it will be done in 2 weeks :)</div>
                    <a href='cores/other/unconfuser/index.html'>unconfuser</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_unconfuser'>code</a>
                </td>
                <td>Jun 23, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ant: NoLicense:Status- Found the old project files and documentation and uploaded to opencores- PCB with XC9536XL 90% done, may go into new PCB rev- Several configurations have been tested with an prototypeDescriptionThe goal was to create a set of HDL designs that can convert a small PLD to emulate any JTAG/ISP/Download cable. In most cases those designs are pretty trivial.All (almost all) current testing is now done using Chameleon dongle fromhttp://www.amontec.comFeatures- Emulated Cables- ByteBlasterMB/II- Xilinx Parallel Cable III- Atmel ATDH2081- Atmel STK200- JTAG Wiggler- Cypress Ultra</div>
                    <a href='cores/other/universal_programming_cable/index.html'>universal programming cable</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_universal_programming_cable'>code</a>
                </td>
                <td>Dec 3, 2004</td>
                <td>Verilog</td>
                <td>Unknow</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other pecification doneWishBone Compliant: NoLicense: LGPLAbout the uTosNet projectuTosNet (pronounced microTosNet) is developed at the University of Southern Denmark ( http://www.sdu.dk ), and is intended to:Reduce the development time of experimental robotic controllers to arrive faster and cheaper at fully working demonstrations of new technology and concepts.Increase the reusability of experimental systems and components, thus increasing the life-span and utilization of these, and reducing the amount of redundant work.Ease the use of interacting with experimental low-level controller, to open ex</div>
                    <a href='cores/other/utosnet_framework/index.html'>utosnet framework</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_utosnet_framework'>code</a>
                </td>
                <td>Aug 26, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ne Compliant: NoLicense: LGPLOverviewVeristruct is an an IEEE1364.1995 preprocessor that adds some C-style struct support to the Verilog language. It takes as input Veristruct files (with a .vs extension) and struct definition files (with a .struct extension). It outputs standard Verilog files (with a .v extension). Veristruct files are, for the most par t, standard Verilog filesbut, as well as the normal nets and regs, bundled, hierarchical variables can be declared and used.Veristruct can process one veristruct file per invocation (which may include many .struct struct definition files).Veri</div>
                    <a href='cores/other/veristruct/index.html'>veristruct</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_veristruct'>code</a>
                </td>
                <td>Aug 24, 2009</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other iant: NoLicense: GPLDescription of projectThis project emulates a CPU for an FPGA under simulation with the use of text files. It can be used to test an FPGA - CPU interface using realistic real-world stimuli. One main text file per CPU emulation instance is used for global CPU commands, and thread spawning. Each spawned thread is tied to an additional text file to use as its 'source code'.Functionality:Features:Configuration of clock, and reset, and read latency.Wait for time periodWait for signal value (good for interrupts)Declare local and global variables (bit, vector8, or string)Nested wh</div>
                    <a href='cores/other/vhdl_file-based_cpu_emulator/index.html'>vhdl file-based cpu emulator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_vhdl_file-based_cpu_emulator'>code</a>
                </td>
                <td>Sep 7, 2009</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other nal info:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionAn Virtual RS232 Terminal developed with Avnet Xilinx Spartan 3A Evaluation Kit ( Spartan XC3S400A ) that has a LVDS LCD Controller (Notebook LCD used for development, 3 LVDS Pairs interface) and a PS2 Keyboard Receiver.The Core receives the ScanCodes on PS2 Keyboard, and sends ascii through serial port. Also, it received the ASCII Chars on Serial port and write on a CharRam Buffer (80x60 chars) that displays on the LCD Screen.Video from project:http://www.youtube.com/watch?v=fX3_T2NMSnMMore info at:http://www.energylabs.com.br(</div>
                    <a href='cores/other/virtual_rs232_terminal_with_lvds_lcd_controller/index.html'>virtual rs232 terminal with lvds lcd controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_virtual_rs232_terminal_with_lvds_lcd_controller'>code</a>
                </td>
                <td>Mar 3, 2011</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other se:DescriptionWB Interface for TI 5x DSP (HPI) developed for use with Opencores PCI Bridge.Features1. Direct access to DSP Control Registers2. Block transfer from DSP address space to WB address space3. Block transfer from WB address space to DSP address space4. Interrupt support (both are maskable)- interrupt after block transfer; and- interrupt from DSP.5. Maped DSP address space to WB address space.Status- Core is finished, testing some parts at the moment- Writing documentation- Test bench for PCI card, with hex editor for DSP memory, was written (Win Platform).  It will be available with </div>
                    <a href='cores/other/wb_interface_for_ti_5x_dsp_wb2hpi/index.html'>wb interface for ti 5x dsp wb2hpi</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_wb_interface_for_ti_5x_dsp_wb2hpi'>code</a>
                </td>
                <td>Feb 20, 2004</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other nse:DescriptionReal Time Clock IP core with wishbone bus complaint. The RTC can transmit data to CPU as Binary Coded Decimal (BCD) values through wishbone bus. The data include the time by second, minute, hour, date, day, month, and year. It is 24-hour format. The RTC module can work with an external crystal that the frequency is not very fixed,  such as 32.768kHz and so on. It also can generate two flexible interrupt requests: alarm and repetitive mode.IMAGE: structure.jpgFILE: structure.jpgDESCRIPTION: Structure of wb_rtc coreIMAGE: ports.jpgFILE: ports.jpgDESCRIPTION: Ports of wb_rtc coreFe</div>
                    <a href='cores/other/wb_rtc/index.html'>wb_rtc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_wb_rtc'>code</a>
                </td>
                <td>Sep 20, 2003</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ne Compliant: YesLicense: LGPLDescriptionA AHB master to WishBone slave bridge along with a basic testbench is included. Burst in not yet supported.</div>
                    <a href='cores/other/wb_to_amba/index.html'>wb_to_amba</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_wb_to_amba'>code</a>
                </td>
                <td>Aug 30, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other nse: LGPLDescriptionHave you ever wanted to add some color to your project? Then this might be your answer. The WS2812 RGB LED "pixels" and WS2811 driver ICs are available for an encouragingly low cost from various sites on the internet, and they come in strips which can be cut or joined to the desired length. Since the Red/Green/Blue (RGB) LEDs inside the WS2812 part are driven by the serial driver IC which is also inside the part, only three wires are needed, and your project can set each LED color independently of the others.The connections to the LED strip include 3 wires: +VCC, GND, and d</div>
                    <a href='cores/other/ws2812_rgb_led_string_driver/index.html'>ws2812 rgb led string driver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_ws2812_rgb_led_string_driver'>code</a>
                </td>
                <td>Nov 1, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other roven,Specification doneWishBone Compliant: YesLicense: GPLDescriptionAs the title says, this core provides access to the Xilinx Internal Configuration Access Port, Edition 2, via a 32-bit wishbone bus.  The ICAPE2 contains address space for 32 registers, and this port provides access to all of them.  Specific ports/registers that have been tested and proven include the warm boot start address (WBSTAR) and the command (CMD) register.  Using these, together with the Quad SPI Flash core, I can reconfigure my Basys-3 development board from my bedroom nightstand without needing to come into the of</div>
                    <a href='cores/other/xilinx_configuration_port_icape2_via_wishbone/index.html'>xilinx configuration port icape2 via wishbone</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_xilinx_configuration_port_icape2_via_wishbone'>code</a>
                </td>
                <td>May 26, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other ompliant: NoLicense: LGPLBenefits of data compressionThe use of lossless data compression can bring about a number of increasingly important benefits to an electronic system. The term lossless means that the original data can be exactly recreated after a decompression operation, and should not be confused with audio and video compression systems (such as JPEG and MPEG) which are lossy and hence only recreate an approximation of the original data.The most obvious benefit of data compression is a reduction in the volume of data which must be stored. This is important where the storage media itse</div>
                    <a href='cores/other/xmatchpro_lossless_data_compressor/index.html'>xmatchpro lossless data compressor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_xmatchpro_lossless_data_compressor'>code</a>
                </td>
                <td>Sep 15, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>other esLicense: LGPLDescriptionAn implementation of theVector Graphic, Inc. Computer Systemof the early 1980's on aXilinx Spartan 3E Starter Kit.  TheVector ZCB and FlashWriter IIvideo card are implemented.  The system also includes a memory management unit, serial ports, and keyboard interface.  This design is based on several cores fromOPENCORES.ORG.You can see some pictures of it runningon my blog.Features- Vector ZCB CPU Card  - Uses OpenCoresWishbone High-Performance Z80 CPU Core- Can optionally use the OpenCoresTV80 CPU Coreif the wb_tv80 Wishbone wrapper is used.  - Vector Graphic MON4.3</div>
                    <a href='cores/other/z80-based_vector_graphic_single-board_computer/index.html'>z80-based vector graphic single-board computer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/other_z80-based_vector_graphic_single-board_computer'>code</a>
                </td>
                <td>Dec 29, 2008</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>PROCESSOR</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor pliant: YesLicense: LGPLFeatures800 Xilinx slices for CPU1000 Xililinx slices for complete SoCOptimized for exeution of C programsVHDL, Assembler, C Compiler, Simulator6 kByte RTOSStatusDone.To browse the SVN sources, or to fetch a tarball of the sources, click one of links above underDetailsUsersRiccardo Cerulli-Irelli:http://ubceru.ifsi-roma.inaf.it/~cerulli/projects/c16/</div>
                    <a href='cores/processor/16_bit_microcontroller/index.html'>16 bit microcontroller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_16_bit_microcontroller'>code</a>
                </td>
                <td>Jun 20, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  NoLicense: LGPLDescriptionA 16-bit classical CPU based loosely on Caxton Foster's Blue CPU from the book "Computer Architecture". Includes a cross assembler and a very novel front panel for the Digilent Spartan 3 board.Main DocumentationThe project has a wiki atHotsolder.Video</div>
                    <a href='cores/processor/16-bit_cpu_based_loosely_on_caxton_fosters_blue_ar/index.html'>16-bit cpu based loosely on caxton fosters blue ar</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_16-bit_cpu_based_loosely_on_caxton_fosters_blue_ar'>code</a>
                </td>
                <td>Feb 6, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor oLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/processor/16-bit_open_urisc_core_processor/index.html'>16-bit open urisc core processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_16-bit_open_urisc_core_processor'>code</a>
                </td>
                <td>Jul 26, 2013</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor oLicense: OthersDescriptionOverview16,32,64 bit microprocessor - simulator source configurable.16 bit fixed instruction length. All instructions conditional.up-to 128 instructions. 64 registers.Run-time instruction configuration / code obfuscation.Simulator software includes macro assembler, console debugger and interpreter using host system calls.Public domain.</div>
                    <a href='cores/processor/1664_microprocessor/index.html'>1664 microprocessor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_1664_microprocessor'>code</a>
                </td>
                <td>Mar 26, 2010</td>
                <td>C/C++</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  NoLicense: OthersDescriptionThe Intel 4004 was the first commercially-available single-chip CPU. Developed by Intel in 1969 for the Busicom company for use in the Busicom 141-PF calculator, and made commercially available for other uses in November 1971, the 4004 CPU and the other MCS-4 family chips were used in embedded applications into the mid-1980s.This project is a translation of the pMOS, dynamic-logic MCS-4 chip set design into static-logic, functional Verilog that can be synthesized for most any FPGA. The implementation intentionally uses the net naming convention found in the 400x si</div>
                    <a href='cores/processor/4004_cpu_and_mcs-4_family_chips/index.html'>4004 cpu and mcs-4 family chips</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_4004_cpu_and_mcs-4_family_chips'>code</a>
                </td>
                <td>Nov 13, 2012</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor NoLicense:DescriptionFeatures- feature1- feature2Status- ...- ...</div>
                    <a href='cores/processor/6502vhdl/index.html'>6502vhdl</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_6502vhdl'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionA verilog, vendor independent, no cycle accurate MC6809/HD6309 compatible processor core.Goals:- Execute all implemented opcodes- Allow asnychronous memories- &gt;40 MHz clockStatus- Most instructions need less clocks than the original.- Synthesizes in Lattice Diamond for the MachXO2 requiring ~1260 Slices (two-cycle multiplier) @ &gt;40 MHz, tested, works.- Synthesizes in XST for Spartan 2 using a bit less than 1200 Slices (fits in a XC2S100). Testing pending.- Synthesizes in XST for Spartan 3 using ~1150 Slices, hw-multiplier. Testing </div>
                    <a href='cores/processor/6809_and_6309_compatible_core/index.html'>6809 and 6309 compatible core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_6809_and_6309_compatible_core'>code</a>
                </td>
                <td>Jul 31, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor Compliant: NoLicense:MC68HC05A MC68HC05 clone in VHDL as single file. Twice performance as the original. Multiplication is done in one clock cycle.2007.02.11 first versiontested with C compiler works OK</div>
                    <a href='cores/processor/68hc05/index.html'>68hc05</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_68hc05'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor Compliant: NoLicense:MC68HC08 cloneA MC68HC08 clone in VHDL as single file. Twice performance as the original. Multiplication is done in one clock cycle. Division in two clock cycles.Features- feature1- feature1.1-feature1.2-feature22007.02.08 first versiontested with C compiler works OK with interrupts2009.07.16  new version, bugfix at opcode 7E  mov ,X+,opr8a  X post increment fixed</div>
                    <a href='cores/processor/68hc08/index.html'>68hc08</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_68hc08'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor icense: LGPLDescriptionThe goal of this project is to create a very well documented, fully synthesizable VHDL model of an 8-bit microcontroller with extended peripheral set. The model should be highly configurable, making it possible to exclude unused peripheral units. These features make it a very good choice for SoC (System-on-a-chip) designs and for purely educational purposes.An assembler and a testbench describing the behavior of both program and data memory are provided.http://www-user.tu-chemnitz.de/~dimo/opencores/cpu8.gifFeatures- assembler- testbench describing the behavior of progra</div>
                    <a href='cores/processor/8-bit_microcontroller_with_extended_peripheral_set/index.html'>8-bit microcontroller with extended peripheral set</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_8-bit_microcontroller_with_extended_peripheral_set'>code</a>
                </td>
                <td>Aug 10, 2008</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nse:DescriptionThe 8051 microcontroller is member of MCS-51 family, originally designed in the 1980's by Intel. The 8051 has gained great popularity since its introduction and is estimated it is used in a large percentage of all embedded system products. The basic form of 8051 core includes several on-chip peripherals, like timers and counters, additionally there are 128 bytes of on-chip data memory and up to 4K bytes of on-chip program memory.Features- 8-bit CPU optimized for control applications- Exstensive Boolean processing (single-bit logic) capabilities- 64K Program Memory address space-</div>
                    <a href='cores/processor/8051_core/index.html'>8051 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_8051_core'>code</a>
                </td>
                <td>Sep 18, 2013</td>
                <td>Unknow</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one Compliant: NoLicense:DescriptionThis is an 8080 core I created as a project to get to know Verilog.The 8080 was the second in the series 8008-&gt;8080-&gt;Z80. It was the secondcommercially available single chip CPU (disregarding the requiredclock and demultiplexor chips), after the 4 bit 4004. Besides being an interestingproject, it also can serve as a very compact core, suitable for a supervisor role on anFPGA with other blocks. It has extensive support, all freely available, includingassemblers, compilers, an operating system (CP/M).Although the Z80 is a more popular core due to being a</div>
                    <a href='cores/processor/8080_compatible_cpu/index.html'>8080 compatible cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_8080_compatible_cpu'>code</a>
                </td>
                <td>Mar 6, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor roven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionA-Z80is a conceptual implementation of the venerable Zilog Z80 processor targeted to synthesize and run on a modern FPGA device. It differs from the existing (mostly Verilog) Z80 implementations in that it is designed from the ground-up through the schematics and low-level gates. It is a result of a research and tedious reverse-engineering of Z80 at all levels, including micro-photographs of a die.Project includes a fully working     implementation based on this CPU.It has been described in more details atBaltazarStudios.Fe</div>
                    <a href='cores/processor/a-z80_cpu/index.html'>a-z80 cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_a-z80_cpu'>code</a>
                </td>
                <td>Dec 24, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ompliant: YesLicense: LGPLDescriptionThe AE18 is a clean room implementation of the Microchip PIC18 series CPU core using information from the PIC18C documentation from their website. It is cycle and instruction compatible to the PIC18 for most software commands.This is just a CPU core that is capable of moving and manipulating data to and from memory. It does not have any peripherals nor interrupt controllers although support for both high and low level interrupts are provided. Any peripherals and their respective registers should be mapped to the data memory space. It has a separate ins</div>
                    <a href='cores/processor/ae18/index.html'>ae18</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ae18'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor enWishBone Compliant: YesLicense: LGPLFeatures- Non-architecture compatible with MB.- Harvard architecture with separate instruction and data bus.- Provides GET/PUT implementation on a FSL bus.- Uses WISHBONE instead of LMB/OPB bus protocol for I/O.- Fully pipelined for single cycle execution of all instructions.- Single cycle barrel shifter and multiplier.- Instruction compatible except for optional instructions not used in GCC.- Missing: WIC,WDC,IDIV,IDIVU- Optional parameterised multiplier and barrel shifter.- Software division- Software floating-pointStatus- Tested in software simulation:-</div>
                    <a href='cores/processor/aemb/index.html'>aemb</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_aemb'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor rovenWishBone Compliant: NoLicense: GPLDescriptionThe main features of ag_6502 implementation:* It provides not only clock-level compatibility, but phase-level compatibility too. Thus it may be possible to connect simulated 6502 instead of the original one. Source code includes two possibilities to simulate two-phase clocking: by the use of external phi1 and phi2 clock generators and by the simulation of the phase shift using higher frequency source (I used standard 50 MHz clock generator to simulate phases phi1 and phi2 in my test project).* It requires a relatively small amount of FPGA logic</div>
                    <a href='cores/processor/ag_6502_soft_core_with_phase-level_accuracy/index.html'>ag_6502 soft core with phase-level accuracy</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ag_6502_soft_core_with_phase-level_accuracy'>code</a>
                </td>
                <td>Jul 31, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  provenWishBone Compliant: YesLicense: LGPLDescriptionAltOR32 is an OpenRISC 1000 architecture derived RISC CPU targeted at small FPGAs and contains only the most basic ISA features from the OpenRisc project.Instructions &amp; registers relating to Vector, floating-point, 64-bit extensions, MMU &amp; Cache have been omitted.The aim of AltOR32 is to provide a simple 32-bit soft CPU architecture aimed at control applications that can fit in low-end FPGA technology.This design implements all instructions that cannot be disabled. Anything else is viewed as beyond the scope of this cut-down soft-CP</div>
                    <a href='cores/processor/altor32-alternative_lightweight_openrisc_cpu/index.html'>altor32-alternative lightweight openrisc cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_altor32-alternative_lightweight_openrisc_cpu'>code</a>
                </td>
                <td>Feb 15, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor tion doneWishBone Compliant: YesLicense: LGPLDescriptionAlwcpu is a light weight CPU in terms of logic resources.- 16 bit address and data bus. (Instructions are 16 bit as well)- Wishbone interface- Is parameterizable to optimize size, e.g. skipping of instruction groups, selectable 8 or 16 registers...- Core size is about 52-55 FF and 335-478 LUT's (depending on configuration) in a Spartan 3-400 when compiled for Area.- The core has 4 special registers and 4(*4) general purpose registers in minimum configuration- If more registers needed another 8(*2) registers could be enabled through config</div>
                    <a href='cores/processor/alwcpu-a_light_weight_cpu/index.html'>alwcpu-a light weight cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_alwcpu-a_light_weight_cpu'>code</a>
                </td>
                <td>Oct 26, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor roven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe Amber processor core is an ARM-compatible 32-bit RISC processor. The Amber coreis fully compatible with the ARM v2a instruction set architecture (ISA) and istherefore supported by the GNU toolset. The Amber project provides a complete embeddedsystem incorporating the Amber core and a number of peripherals, including a UART, atimer and an Ethernet MAC.There are two versions of the core provided in the Amber project. The Amber 23 hasa 3-stage pipeline, a unified instruction &amp; data cache, a 32-bit Wishboneinterface, an</div>
                    <a href='cores/processor/amber_arm-compatible_core/index.html'>amber arm-compatible core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_amber_arm-compatible_core'>code</a>
                </td>
                <td>Apr 29, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor Compliant: NoLicense: BSDDescriptionThe ao486 is an x86 compatible Verilog core implementing all features of a 486 SX.The core was modeled and tested based on the Bochs software x86 implementation.Together with the 486 core, the ao486 project also contains a SoC capable ofbooting the Linux kernel version 3.13 and Microsoft Windows 95.Current status31 March 2014 - initial version 1.0.19 August 2014 - driver_sd update, ps2 fix.Linksao486 project on github.com:http://github.com/alfikpl/ao486.FeaturesThe ao486 processor model has the following features:pipeline architecture with 4 main stages: dec</div>
                    <a href='cores/processor/ao486/index.html'>ao486</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ao486'>code</a>
                </td>
                <td>Aug 19, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor : YesLicense: BSDDescriptionThe OpenCores ao68000 IP Core is a Motorola MC68000 binary compatible processor.IntroductionJuly 2011: Project copied to (https://github.com/alfikpl/ao68000). Further development of ao68000 will continue on github.FeaturesCISC processor with microcode,WISHBONE revision B.3 compatible MASTER interface,Not cycle exact with the MC68000, some instructions take more cycles to complete, some less,Uses about 4750 LE on Altera Cyclone II and about 45600 bits of RAM for microcode,Tested against the WinUAE M68000 software emulator. Every 16-bit instruction was tested with ran</div>
                    <a href='cores/processor/ao68000-wishbone_68000_core/index.html'>ao68000-wishbone 68000 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ao68000-wishbone_68000_core'>code</a>
                </td>
                <td>Oct 23, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor : NoLicense: BSDDescriptionThe aoR3000 is a MIPS R3000A compatible core capable of booting the Linux kernel version 3.16 in about 3 seconds and with a rating of 48.74 BogoMIPS. It features a compatible MMU, but no FPU.Current status11 August 2014 - initial version 1.0.LinksaoR3000 project on github.com:http://github.com/alfikpl/aoR3000.FeaturesThe aoR3000 soft processor core has the following features:5 stage pipeline (single-issue, in-order, forwarding, hazard detection);implements all MIPS I instructions (this includes the privileged coprocessor 0 instructions);the MMU in coprocessor 0 is co</div>
                    <a href='cores/processor/aor3000/index.html'>aor3000</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_aor3000'>code</a>
                </td>
                <td>Aug 12, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ompliant: NoLicense: GPLDescriptionA Xilinx Spartan-3E FPGA implementation of the Block II Apollo Guidance Computer (AGC) in VHDL.Has anyone found this project useful? Any chance of some feedback so I can improve the project?</div>
                    <a href='cores/processor/apollo_guidance_computer_nor_emulator/index.html'>apollo guidance computer nor emulator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_apollo_guidance_computer_nor_emulator'>code</a>
                </td>
                <td>Jul 25, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor enWishBone Compliant: NoLicense: GPLDescriptionThis processor, done as an university project, is a functional clone of the ARM processor, is almost entierely compatible with the ARMv3 instruction set and can be targetted by the GCC toolchain if the proper options are used during the compilation process.The processor uses a classical 5-stages RISC pipeline and an instruction cache. It was made to connect to the Altera Avalon bus, as a Q-Sys compatible component. It should however be simple to retarget it for other similar buses.We made it run at 50 MHz on a Cyclone IV FPGA.Full VHDL sources, sc</div>
                    <a href='cores/processor/arm4u/index.html'>arm4u</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_arm4u'>code</a>
                </td>
                <td>May 2, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor icense:DescriptionThe ASPIDA project has implemented an asynchronous IP of the DLX Instruction Set Architecture (ISA) with incorporated support for ISA conversion so it can be easily converted to any RISC ISA. The DLX architecture, is well-supported by existing software development tools (compiler, assembler, loader, instruction set simulator and debugger).The synchronous single-pipeline architecture, which is standard for the basic synchronous DLX implementations, is identical to the architecture of the asynchronous version. A suitable Open IP interface (WISHBONE) is embedded onto the process</div>
                    <a href='cores/processor/aspida_sync-async_dlx_core/index.html'>aspida sync/async dlx core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_aspida_sync-async_dlx_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ication doneWishBone Compliant: YesLicense: GPLDescriptionWelcome to theAtlas Processor Coreproject!The Atlas 2k Processor is intended to be a small 16-bit RISC general purpose processor for all kind of applications, that require minimal hardware resources while providing a maximum functionality and processing power. The instruction set was inspired by famous architectures like the ARM and AVR ISAs and many of you, who worked with these architectures, will see the resemblance. However, the CPU features a lot of additional nice features and functionalites, which - at least from my point of view</div>
                    <a href='cores/processor/atlas_processor_core/index.html'>atlas processor core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_atlas_processor_core'>code</a>
                </td>
                <td>Dec 20, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor License:DescriptionMicrocontroller core compatible with one used in AT mega 103 and written in VHDL. It has the same instruction timing  and the same instruction set (with a few exceptions).Features Core features: 32 x 8 general purpose registers Twenty three interrupt vectors Supports up to 128 Kb of program and up to 64 Kb of data memory Peripheral features: Programmable UART Two 8-bit Timer/Counters with separate prescalers and PWM Eight external interrupt sources Two parallel portsStatusThe core was tested with several ASM and C programs.It was implemented in Altera EPF10K50ETC144-3 device</div>
                    <a href='cores/processor/avr_core/index.html'>avr core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_avr_core'>code</a>
                </td>
                <td>Nov 22, 2014</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor Compliant: NoLicense: LGPLDescriptionThe project is based on OpenCores' AVR project by Ruslan Lepetenok.The core is now hyper pipelined. It is a technique to multiply the functionalityof a design by adding registers (called pipeline stage registers) to the core logicin order to multiply its functionality. If you are interested in the technology, go to www.cloudx.ccThe functional behavior of the AVR remains the same, the hyper pipelined versionis used when multiple, equal AVR cores (2, 3, ...) are instantiated in thedesign (multicores).The main benefit is the multiplication of the core's functi</div>
                    <a href='cores/processor/avr_hp_hyper_pipelined_avr_core/index.html'>avr hp hyper pipelined avr core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_avr_hp_hyper_pipelined_avr_core'>code</a>
                </td>
                <td>Dec 22, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor hBone Compliant: NoLicense: LGPLDescriptionThis is a Atmel AVR ATtiny261/461/861 compatible core.It should be (more or less) fully code compliant, but it is not clock-cycle compliant.The reason it was developed was to have a simple core to develop C-code to.The implementation is rather strait forward without any pipelining.One reason was also to see how hard it was to implement a standard mcu in vhdl and make it run on gcc-generated code.The implementation is a bit quick-n-dirty, I spent about 15h coding the core and about 15h to writing test bench and simulate the core.I must also say that I'</div>
                    <a href='cores/processor/avrtinyx61core/index.html'>avrtinyx61core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_avrtinyx61core'>code</a>
                </td>
                <td>Nov 10, 2008</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor se:DescriptionMicrocontroller core compatible with 90S1200 and 90S2313.Same instruction timing as in the original MCUs. Both MCUs use the configurable AX8 core. Other MCUs using one of the two instruction sets the core supports can easily be implemented by creating a new top level.There are utilities included that can create VHDL ROMs for simulation and synthesis. The utilites create generic ROMs that can be used for simulation and for synthesis with Leonardo and also Xilinx specific ROMs that can be used for XST synthesis.Batch files for runnning XST and Leonardo synthesis can be </div>
                    <a href='cores/processor/ax8_mcu/index.html'>ax8 mcu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ax8_mcu'>code</a>
                </td>
                <td>Feb 16, 2010</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor liant: NoLicense: LGPLDescriptionBrainfuck CPU is a hardware implementation of Brainfuck programing language. It uses simple 2-stage pipelining and Harvard's architecture.This CPU is very similar to Touring machine. It operates over linear memory space. Main difference is that the memory if finite.Instruction set is fairy simple. Opcodes are only 3-bit wide. This allows lower usage of resources over original coding (7 bit ASCII). Verion using original instruction set is available as well.Can't place oposite of &gt; char for some reason, so I'll use "(oposite of &gt;)" instead.OpcodesOpcodes:00</div>
                    <a href='cores/processor/brainfuck_cpu/index.html'>brainfuck cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_brainfuck_cpu'>code</a>
                </td>
                <td>Sep 7, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor cense:DescriptionCores are generated fromConfluence; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  SeeConfluent.orgfor more info.Several cores are provided in Verilog, Vhdl, and C.  If you don't see the configuration you need, chances are we can easily generate it for you.The State Space Processor is used for implementing discrete linear systems, such as finite and infinite impulse response filters, multiple input and output systems, and general state space equations common in control and DSP applicatio</div>
                    <a href='cores/processor/cf_state_space_processor/index.html'>cf state space processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_cf_state_space_processor'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor t: NoLicense: GPLDescriptionIntroductionThe aim of the project is to port and maintainCodezeromicrokernel to the OpenRISC 1000 family.L4 microkernel architectureCodezero is a new L4 microkernel that has been written from scratch, following the latest development and research principles on microkernel design. It is a modern microkernel implementation that provides capabilities for virtualization and implementation of native OS services.Design principlesCodezero and L4 line of microkernels are founded on a few fundamental design principles. The primary principle is that only the most fundamental</div>
                    <a href='cores/processor/codezero_openrisc_port/index.html'>codezero openrisc port</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_codezero_openrisc_port'>code</a>
                </td>
                <td>Jun 15, 2010</td>
                <td>C/C++</td>
                <td>Planning</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  NoLicense:StatusCPU passes simple tests.  Verification is not complete.DescriptionThis is a new implementation of the OpenRisc 1000 architecture in the Confluence language.Features- OpenRisc 1000  32-bit CPU- ORBIS32-I instructions implemented- Exception handling partially implemented- C test harness runs S-record programs- Cache- Not implemented- MMU- not implemented- Other stuff- not implementedNews16 June 04  Upgraded to Confluence 0.9.0</div>
                    <a href='cores/processor/confluence_openrisc_1000/index.html'>confluence openrisc 1000</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_confluence_openrisc_1000'>code</a>
                </td>
                <td>Jun 17, 2004</td>
                <td>Other</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor eWishBone Compliant: YesLicense: LGPLDescriptioncopyBlaze is a from-scratch synthesizable &amp; behavioral VHDL clone of Ken Chapman's popular 8bit PicoBlaze embedded microcontroller.It support wishbone interface.Assembler and C Compiler are used in the developpement.STATUSThe developpement is still in progress.* All the PicoBlaze III instructions have been tested.* Actually the wishbone instructions are in test validation* PBCC Compiler is in test.FeaturescopyBalze have the followings features:'''SET INSTRUCTION'''* picoblaze III instruction compatible + specific wishbone instructions* 1k x 1</div>
                    <a href='cores/processor/copyblaze/index.html'>copyblaze</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_copyblaze'>code</a>
                </td>
                <td>May 23, 2013</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ompliant: NoLicense:Status- Initial tests and debugging have been performed.- Initial code revision is 80-90% complete- Initial cvs commit (27 Mar 2006)FeaturesLogical and arithmetic operations have been tested and are functional.Pretty much everything works, as far as my test have shown.  I've also writen some software that generates a ROM in VHDL from assembly source code.  It's available at my website.  Plus, there's an assembly simulator!DescriptionThis is an implementation of an instruction set that I created.  It's not a particularly useful thing to do, but it's something I've always bee</div>
                    <a href='cores/processor/cowgirl/index.html'>cowgirl</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_cowgirl'>code</a>
                </td>
                <td>May 31, 2007</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor NoLicense:DescriptionCpugen (TM) generates customizable RISC cpu cores.It allows direct customization of address/data/instruction bus size,interrupt handling, indirect addressing, data/instruction latencytimings and custom instructions definition.It is targeted to low size FPGAs, easy to use and getting started with.GNU VHDL source code provided.Features1) Portability:vendor dependent blocks (ex. memory blocks) are kept separate from vendor independent logic.Customizable built-in assembler with data/instruction memory files generation; output file formats for the following environments:</div>
                    <a href='cores/processor/cpu_generator/index.html'>cpu generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_cpu_generator'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one,FPGA provenWishBone Compliant: NoLicense: GPLDescriptionThis is a VHDL/Verilog IP core with True Cycle Timing for Rockwell's 6502 8-Bit CPU. With full functional input signals like ready, interrupt, non maskable interrupt and set overflow flag. Also available is the output signal sync which signals an op fetch. The ready signal is usable for DMA operations or multiprocessing. Signal sync can be used for software/hardware debugging via single stepping (single cycles or complete op codes) the 6502.This core was successfully tested in an APPLE ][+ SoC (completely designed into a FPGA with Z80</div>
                    <a href='cores/processor/cpu6502_tc-r6502_processor_soft_core_with_accurate/index.html'>cpu6502_tc-r6502 processor soft core with accurate</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_cpu6502_tc-r6502_processor_soft_core_with_accurate'>code</a>
                </td>
                <td>Jul 24, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ovenWishBone Compliant: NoLicense: GPLDescriptionThe 65C02 by Rockwell is the upgraded version of the legendary Rockwell's R6502. cpu65c02_tc offers you an accurate timing for all new and upgraded op codes of the R65C02. This soft core was generated in VHDL and was designed with Mentor's HDL Designer.It comes also with graphical views formatted in HTML to show and explain very clearly the hierarchy of the whole design.Please feel free to tell me any ideas, errors or some thing else like special functions, test benches or documentation. Use the "Tracker" link to do this.Features- true cycle tim</div>
                    <a href='cores/processor/cpu65c02_tc-r65c02_processor_soft_core_with_accura/index.html'>cpu65c02_tc-r65c02 processor soft core with accura</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_cpu65c02_tc-r65c02_processor_soft_core_with_accura'>code</a>
                </td>
                <td>Aug 2, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor pliant: NoLicense:DescriptionThe data flow processor (DFP) is a flexible microprocessor written in VHDL which you can program down to the gate level to optimize your entire design. It is composed of 7 components with a specific data flow architecture. In most cases you just provide a VHDL file containing the program you want the processor to run, compile the whole design and then download it to an FPGA. For more specific designs, the code for the components can be altered to suit your needs. The components are:TR - top register - top-most register for manipulating data or data flowFU - functio</div>
                    <a href='cores/processor/data_flow_processor/index.html'>data flow processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_data_flow_processor'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor Compliant: NoLicense:DescriptionThis Project was developed within a Computer Architecture Course. It demonstrates a simple RISC architecture. Please note that it was developed on a Sparten-3E Starter Kit and memory in VHDL code is embedded via XILINX specific routines.Features- Assembler- Simulator- Simple I/O (Leds, Buttons, UART, Hitachi LCD)- VGA ControllerStatus- presented in class as working</div>
                    <a href='cores/processor/diogenes_student_risc_system/index.html'>diogenes student risc system</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_diogenes_student_risc_system'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor WishBone Compliant: NoLicense: LGPLDescriptionsimple alu</div>
                    <a href='cores/processor/distributed_limited_cores/index.html'>distributed limited cores</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_distributed_limited_cores'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor t: NoLicense: GPL</div>
                    <a href='cores/processor/ecpu/index.html'>ecpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ecpu'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor NoLicense: LGPLDescriptionEdge is a microarchitecture implementation for mips1 ISA.It has a 32 bit datapath divided into  five pipeline stages operating at 50 MHz frequency.Supporting timer and other interrupt types and exceptions is implemented through co-processor0.Edge has been tested and verified on Atlys that has a Spartan-6 XC6SLX45 FPGA.For the Atlys board, UART driver is provided to communicate with PC at 115200 baud rate.Youtube link for simple C programs running [1]https://www.youtube.com/watch?v=Hxwq2KWzycU</div>
                    <a href='cores/processor/edge_processor_mips/index.html'>edge processor mips</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_edge_processor_mips'>code</a>
                </td>
                <td>Jun 29, 2014</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one Compliant: NoLicense: LGPLDescriptionThis project was aimed at providing people a simple, runnable, and easy-to-enhance MIPS CPU main architecture, along with well commented Verilog RTL source code, complete simulation test benches &amp; scripts, and detailed documentation. People can read the source code, make simulations to verify the result, and then make modifications to enhance it. I hope this project can help you learning the MIPS CPU architecture and enjoy constructing your own CPU core.This CPU design is based on Mr. Hu Weiwu&euro;&trade;s book &euro;?Computer Achitecture&euro;?, T</div>
                    <a href='cores/processor/educational_16-bit_mips_processor/index.html'>educational 16-bit mips processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_educational_16-bit_mips_processor'>code</a>
                </td>
                <td>Aug 18, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor Compliant: NoLicense:DescriptionAn implementable and enhancable RISC Core developed in Verilog HDL, tested on Xilinx IIE Spartan FPGA.Features- feature1- feature1.1-feature1.2-feature2Status-Currently present Verilog Module is implementable, and also enhancements could be made as desired- status2</div>
                    <a href='cores/processor/educational_risc_processor/index.html'>educational risc processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_educational_risc_processor'>code</a>
                </td>
                <td>Feb 26, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor oLicense: Others</div>
                    <a href='cores/processor/elm_embedded_processor/index.html'>elm embedded processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_elm_embedded_processor'>code</a>
                </td>
                <td>Feb 26, 2010</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor : NoLicense: LGPLDescriptionEncore intends to explain basic microprocessor principles. Starting at a the simplest micro sequencer based level, all the way up to pipelines, caches, mmu, multi-datapaths etc.</div>
                    <a href='cores/processor/encore/index.html'>encore</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_encore'>code</a>
                </td>
                <td>Feb 19, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor WishBone Compliant: NoLicense: LGPLDescriptionThe graphics processed by the GPU are defined as a set of vertices that contain spatial information, i.e. vectors with coordinates [x y z] in three-dimensional Cartesian space, and additional information of color or texture coordinates.The processing that is performed has 4 phases:1. A group of vertices is processed as a point list, a line list, a line strip, a triangle list, a triangle strip or a triangle fan.2. The given vertices are transformed three-dimensionally based on a 4x4 transformation matrix, being able to translate them, rotate them, s</div>
                    <a href='cores/processor/gpu/index.html'>gpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_gpu'>code</a>
                </td>
                <td>Feb 10, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ,Specification doneWishBone Compliant: NoLicense: LGPLGator Microprocessor (GuP) Overview- Motorola/Freescale 68xx Architecture- Source-code and machine-code compatible 68HC11 cpu core- Compatible with all HC11 C/C++ compilers including GNU GCC- Up to 100MHz operation in modern FPGAs- 2.5 times faster per clock cycle than a HC11 on averageVisit the official website at:www.mil.ufl.edu/projects/gupStatusVersion 0.9a: ReleasedVersion 1.0: ReleasedVersion 2.0: Coming Soon</div>
                    <a href='cores/processor/hc11_compatible-gator_uprocessor/index.html'>hc11 compatible-gator uprocessor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_hc11_compatible-gator_uprocessor'>code</a>
                </td>
                <td>Jul 5, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor hBone Compliant: NoLicense: LGPLDescriptionThis project provides a synthesizable IP core compatible with HITACHI HD63701 processors.</div>
                    <a href='cores/processor/hd63701_compatible_core/index.html'>hd63701 compatible core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_hd63701_compatible_core'>code</a>
                </td>
                <td>Feb 15, 2014</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ompliant: NoLicense: GPLHiCoVec - a configurable SIMD CPUThe HiCoVec processor is based on a simple 32 bit scalar unit and connected with a vector unit for SIMD operations.The amount of data simultaneously processed in the vector unit can be configured as well as the amount of vector registers to hold the data. It is also possible to activate/deactivate some functions (like hardware multiply) of the CPU to gain performance or decrease logic required.The processor has its own instruction set. One instruction word is divided into a scalar and a vector part. This makes it possible to execute two </div>
                    <a href='cores/processor/hicovec-a_configurable_simd_cpu/index.html'>hicovec-a configurable simd cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_hicovec-a_configurable_simd_cpu'>code</a>
                </td>
                <td>Feb 25, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor cation doneWishBone Compliant: NoLicense: OthersDescriptionQuick link to the Excel simulator v06.01:http://www.mediafire.com/download/4vy7d202xu7fdbs/HIVE_SIM_2014-10-08.xlsQuick link to the design document v06.01:http://www.mediafire.com/view/ghtn03wqe4a6k0z/Hive_Design_2014-07-15.pdfQuick link to the SystemVerilog code v06.01:http://www.mediafire.com/download/9iloxic8535cdt7/HIVE_SV_2014-07-13_v06.01.zipv06.01 - 2014-07-13- Major changes in hive_main_mem.sv to support 16 &amp; 32 bit aligned and unaligned access for literals and memory R/W.- Main memory BRAM now a dual entity to provide sepa</div>
                    <a href='cores/processor/hive-a_32_bit_8_thread_4_register-stack_hybrid_pip/index.html'>hive-a 32 bit 8 thread 4 register/stack hybrid pip</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_hive-a_32_bit_8_thread_4_register-stack_hybrid_pip'>code</a>
                </td>
                <td>Oct 10, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor mpliant: NoLicense: LGPLToDo- Isolate bus-controlling logic from Monolithic control-unit fsm- adding support for other SoC buses (atleast AMBA)- 2-pass assembler design (still pending).DescriptionSimple 16-bit microprocessor, 16-general purpose registers. custom instruction set, load-store RISC but current implementation "impl0" non piplined, control unit hardwired, 64K address space, total 16-interrupts (10 maskable), memory mapped i/o. Design wishbone (wb b.3) compatible bus cycles (currently single read/write), soon will add RMW. RTL (VHDL) completed &amp; posted working for Verilog, prelim</div>
                    <a href='cores/processor/hpc-16/index.html'>hpc-16</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_hpc-16'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor cense:DescriptionHyperMTA is a multithreaded processor capable of having up to 256 threads. In today's super computing/high end world more and more processors are going to multithreading to get a performance benefit. More and more applications are also becoming multithreaded and for that reason we are designing a super computing/high end computing processor and its chip sets. The system is organized in such a way that each processor will interface to one memory router. Each memory router connects to several other memory routers making it possible to access any of a number of memory banks insta</div>
                    <a href='cores/processor/hypermta/index.html'>hypermta</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_hypermta'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor t: NoLicense: LGPLDescriptionA Verilog RTL implementation of the venerable IBM 650 computer.The goal of this project is to use available source materials to recreate a 650 as accurately as possible.StatusUnder active development. Control is currently being implemented and debugged in simulation.About the IBM 650Announced in 1953, the IBM 650 was a decimal, digit-serial vacuum tube computer. Main memory was a magnetic drum storing 2000 10-digit signed-decimal numbers. Machine logic was implemented using crystal diodes and vacuum tubes. It was arguably the most popular vacuum tube machine, with </div>
                    <a href='cores/processor/i650/index.html'>i650</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_i650'>code</a>
                </td>
                <td>Mar 26, 2015</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor icense: LGPLWARNINGThis project is in the middle of a major refactor, being conducted ina new GitHub repository.     The refactor involves rewriting from scratch the most intractably messy parts of the RTL (the cache and memory controller and parts of the CPU), going to a 4-stage pipeline, implementing Wishbone as the main bus interface, implementing a generic COP2 interface and a few other changes. The aim is to make the core actually useable.     In particular, the CPU monitor in the TB is being rewritten from scratch, as the current version is just too unmaintainable.     Eventually the </div>
                    <a href='cores/processor/ion-mipstm_compatible_cpu/index.html'>ion-mipstm compatible cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ion-mipstm_compatible_cpu'>code</a>
                </td>
                <td>Jun 11, 2015</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor pliant: YesLicense: GPLStatus- VHDL files and and supporting tools for the design are available from OpenCores CVS.- Actual updates are now in a git repository, seehttp://www.jopwiki.com/Download- Further information can be found athttp://www.jopdesign.com- A wiki is available athttp://www.jopwiki.com/Features- Very small core:- about 2000 LCs - 3000 LCs (configurable)- fmax is 100 MHz in a Cyclone EP1C6- Real-time features:- architecture designed to simplify WCET analysis- cycle accurate time interrupt (not tick based)- real-time enhanced thread model- WISHBONE masterDescriptionJOP is the imp</div>
                    <a href='cores/processor/jop_a_java_optimized_processor/index.html'>jop a java optimized processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_jop_a_java_optimized_processor'>code</a>
                </td>
                <td>Sep 5, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor oLicense:DescriptionThe k68 is a 68k binary compatible CRISC processor. It supports all twelve (12) addressing modes and most of the instructions for a 68000. It has 32-bit external address and data busses. It has eight (8) data and eight (8) address registers where the last address register also acts as a Stack Pointer. It has only one mode of operation and  makes no distinction between user mode and supervisor mode.Features- Supports all twelve 68000 addressing modes.- Binary compatible with the standard 68000.- Capable of executing most 68000 instructions.- 32-bit external busses.- 8 Data a</div>
                    <a href='cores/processor/k68/index.html'>k68</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_k68'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nt: NoLicense: LGPLDescriptionKLC32 is a 32 bit non-pipelined processor. This project is in the first stage of it's evolution and has a long ways to go yet, hence descriptions are a bit lacking. Read the code. First coding was Oct 4, 2011.Programming ModelThere a 32 x 32 bit registers with register R0 always reads as zero.There are two processor modes, user and system, each with it's own stack pointer. Some instructions are restricted to system mode only.There is a group of eight condition code registers cr0 to cr7, each of which contains four status flags: carry,overflow,negative, and zero. T</div>
                    <a href='cores/processor/klc32/index.html'>klc32</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_klc32'>code</a>
                </td>
                <td>Oct 6, 2011</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ne Compliant: NoLicense: LGPLOverviewSummaryThis document describes my implementation of a 6502 microprocessor into a Lattice  LCMXO2280C FPGA.  The hardware is based on an existing PCB leftover from a controller for a soft X-ray generator.  It is anticipated that the design can be ported to other FPGA devices.  It is written in VHDL and used GNU ghdl for initial development and Lattice ispLeaver to implement the design into the FPGA.  The  GNU software was found to be significantly faster than Lattice.  Files and information is provided to implement the design into both Lattice parts and hope</div>
                    <a href='cores/processor/lattice_6502/index.html'>lattice 6502</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_lattice_6502'>code</a>
                </td>
                <td>Dec 17, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor proven,Specification doneWishBone Compliant: NoLicense: LGPLLEM1_9min documentationDescription:Extremely simple micro-controller allowing easy augmentation of the instruction set (e.g. a Hello World project for FPGA micros). Associated assembler written in C#. Example program displays a scrolling "Hello UJorld" on four digit/seven-segment display.Motivation* A Hello World for FPGAse.g. a simple microprocessor core for use in a FPGA/VHDL course* A Core that is easily extended with additional instructions, addressing modes,registers, etc.* Exploits single port distributed RAMs ability to do both</div>
                    <a href='cores/processor/lem1_9/index.html'>lem1_9</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_lem1_9'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor enWishBone Compliant: NoLicense: BSDDescriptionLeros is a 16-bit processor optimized for FPGAs. It consumes less than 200 logic cells and 1-2 on-chip memories.Leros is programmed in assembler and in a restricted subset of Java. Leros is a direct competitor to tiny processorcores, such as PicoBlaze.Comparison with PicoBlazeLeros targets the same application area as PicoBlaze andis about the same size. Following list gives the main differences:* Truly open source (BSD)* Compiles on Altera and Xilinx tools* Leros is a 16 bit architectures instead of 8 bit* Leros has no restrictions on code and da</div>
                    <a href='cores/processor/leros_a_tiny_microcontroller_for_fpgas/index.html'>leros a tiny microcontroller for fpgas</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_leros_a_tiny_microcontroller_for_fpgas'>code</a>
                </td>
                <td>Mar 6, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor en,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionYet another free 8051 FPGA core.     This is a 6-clocker-equivalent implementation of the MCS51 architecture, aiming at area performance.     A full description of the core features can be found inthe datasheet.     Though the core has already executed a Dhrystone benchmark in actual hardware (see below), it is still immature for actual use. A comprehensive test bench has yet to be developed, for starters.PerformanceSynthesisThese are the synthesis results for the Dhrystone demo:DeviceSynthesis OptionsClock RateCPUTimerUARTT</div>
                    <a href='cores/processor/lightweight_8051_compatible_cpu/index.html'>lightweight 8051 compatible cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_lightweight_8051_compatible_cpu'>code</a>
                </td>
                <td>Dec 6, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ign done,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionThis is a simple, small microprogrammed Intel 8080 CPU binary compatible core.There are already at least two other 8080-compatible cores in Opencores, both of them well proven. This one is different because it emphasizes area instead of cycle-count compatibility or speed.I have tried to minimize logic size and complexity as much as possible, at the expense of speed. At about the same size as a Picoblaze on a Spartan 3 (204 LUTs + 1 BRAM), this is perhaps amongst the smallest 8-bit CPU cores available. On the ot</div>
                    <a href='cores/processor/lightweight_8080_compatible_core/index.html'>lightweight 8080 compatible core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_lightweight_8080_compatible_core'>code</a>
                </td>
                <td>Sep 27, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ense:DescriptionThis is a design that mixes processor and memory on a single chip.  There are a bunch of operations surrounded by buffers.  A central unit tells the data where to go.  The operations work on data in certain buffers.  Operations are performed by moving the data into the proper buffer.  It described in much more detail in the specificaiton attatched at the bottom.  I'm working on a C++ model right now.Design Flow- Create preliminary spec.- Create C++ model- Create code to convert x86 commands to native commands- Simulate operation of chip- Optimize C++ model- Convert Model to Sys</div>
                    <a href='cores/processor/locationpu/index.html'>locationpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_locationpu'>code</a>
                </td>
                <td>Feb 6, 2002</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ication doneWishBone Compliant: YesLicense: GPLM1 Core briefly...The M1 Core is a 32-bit RISC CPU compatible with a popular GCC target.It's been designed for simplicity and it's been used for some didactical activities at the University of catania.The CPU is written in Verilog and it's been tested on FPGA (Xilinx Spartan-3E Starter Kit).The CVS tree includes sources from other two OpenCores projects:wb_ddrdeveloped by Joerg Bornscheinps2_interfacedeveloped by John Clayton</div>
                    <a href='cores/processor/m1_core/index.html'>m1 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_m1_core'>code</a>
                </td>
                <td>May 29, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThis project provides a microprogrammed synthesizable IP core compatible with the WDC and Rockwell 65C02 microprocessors.This project demonstrates the integration of the core, M65C02_Core, with several components, usually supplied by the core's integrator, so that a complete soft-processor is available. The core itself expects several external components to be supplied by the integrator: (1) interrupt controller, (2) memory, and (3) I/O interface buffers. This project integrates examples of those external components with th</div>
                    <a href='cores/processor/m65c02/index.html'>m65c02</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_m65c02'>code</a>
                </td>
                <td>Jun 15, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLIntroductionThe MB-Lite microprocessor is a ligth-weight implementation of the Microblaze Instruction Set Architecture. It is instruction and cycle compatible with the Microblaze EDK 10.1i. It is successfully tested on older and newer Xilinx platforms (EDK 9 and 11). The design has been successfully synthesized for an Altera board as well to show platform independence.FeaturesMB-Lite is a highly modular design and is therefore very simple to understand and modify. Features of the MicroBlaze architecture and MB-Lite implement</div>
                    <a href='cores/processor/mb-lite/index.html'>mb-lite</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mb-lite'>code</a>
                </td>
                <td>Jan 27, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ompliant: NoLicense: GPLDescriptionMcAdam's RISC Computer Architecture (marca) is a simple 16-bit microprocessor, implementing a load/store instruction set architecture and featuring a 4-stage pipeline.Features- 16 16-bit registers- Harvard architecture- all memories on-chip- 16KB instruction ROM- 8KB data RAM- 256 byte data ROM- load/store instruction set architecture- 75 instructions- 16 interrupt vectors- 4-stage pipelineStatus- running on an Altera Cyclone FPGA</div>
                    <a href='cores/processor/mcadams_risc_computer_architecture/index.html'>mcadams risc computer architecture</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mcadams_risc_computer_architecture'>code</a>
                </td>
                <td>Feb 2, 2007</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nWishBone Compliant: NoLicense: GPLMCPU - Minimal CPU for a 32 Macrocell CPLDMCPU is a minimal cpu aimed to fit into a 32 Macrocell CPLD - one of the smallest available programmable logic devices. While this CPU is not powerful enough for real world applications it has proven itself as a valuable educational tool. The source code is just a single page and easily understood. Both VHDL and Verilog versions are supplied. The package comes with assembler, emulator and extensive documentation.Please let me know if you find a good use for this CPU and put your project/publication/lecture notes on th</div>
                    <a href='cores/processor/mcpu-a_minimal_cpu_for_a_cpld/index.html'>mcpu-a minimal cpu for a cpld</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mcpu-a_minimal_cpu_for_a_cpld'>code</a>
                </td>
                <td>Jan 20, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor NoLicense:Description32 Bit RISC Processor, 5 Stage Pipeline. Developed for embedded control of devices. Optimized for the Xilinx SpartanII and Virtex line of FPGA's. Later optimizations will be made for Actel ProASIC(+) FPGA's. Uses the Harvard architecture for memory. It contains one interupt vector with a cause register.The 5 Stages:- Fetch- Decode/Register/Uncoditional Branch- Execute(ALU/Compare/etc.)- Memory/Conditional Branch- Write BackUnique Instructions:- Population Count(Ones,Zeros,Bit Changes)- Random Number GeneratorStatusSVN Contains: AU, LU, Compare Unit, Register File, IF, EX, </div>
                    <a href='cores/processor/microrisc_ii/index.html'>microrisc ii</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_microrisc_ii'>code</a>
                </td>
                <td>Apr 1, 2002</td>
                <td>Unknow</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor rovenWishBone Compliant: NoLicense: LGPLDescriptionThis project is developed at Reconfigurable Computer Laboratory - FRM - UTN, and allowssimulate and synthetize the Simplez processor. It is a didactic processor created byGregorio Fernndez in his book "Conceptos Bsicos de Arquitectura y Sistemas Operativos",2003 Edition.This theoretical processor has a von Neuman architecture, with a set of eight instructionsand 512 memory words. Each twelve bits word, contains two fields: operation code anddata address. Basically, Simplez repeats cyclically the next three steps:- Reads the instruction stored </div>
                    <a href='cores/processor/microsimplez/index.html'>microsimplez</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_microsimplez'>code</a>
                </td>
                <td>Nov 11, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ant: NoLicense:DescriptionThis is a Mini-RISC CPU/Microcontroller that is compatible with the PIC 16C57 from Microchip. Additional information about the instruction set and capabilities can be found at: www.microchip.com.Legal noticePIC, Microchip, etc. are Trademarks of Microchip Technology Inc. I have no idea if implementing this core will or will not violate patents, copyrights or cause any other type of lawsuits. I provide this core AS IS, without any warranties. If you decide to build this core, you are responsible for any legal resolutions, such as patents and copyrights, and perhaps oth</div>
                    <a href='cores/processor/mini-risc_core/index.html'>mini-risc core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mini-risc_core'>code</a>
                </td>
                <td>Feb 6, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor pliant: NoLicense: LGPLDescriptionThis is an implementation of a Digital (DEC) PDP8/L processor with 4k memory, a single DF32 disk and serial interface. The project target is the ALTERA NEEK (Cyclone III EP3C25F324C6N). Run the 4K Disk Monitor System using only the FPGA chip. Download contains the complete Altera Quartus II (11.0) project directories with simulation files.</div>
                    <a href='cores/processor/minimal_pdp8-l_implementation_with_4k_disk_monitor/index.html'>minimal pdp8/l implementation with 4k disk monitor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_minimal_pdp8-l_implementation_with_4k_disk_monitor'>code</a>
                </td>
                <td>May 28, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor e Compliant: NoLicense: LGPLMain aspects- The miniMIPS is a 32 bits core and has a Von Neumann architecture.- The miniMIPS is 5-stage pipeline :- Instruction extraction- Instruction decoding- Execution- Memory access- Update registers- Only two instructions can access the memory. The others work on registers which are 32 bits large. The processor contains 32 registers.- Data hazards are resolved thanks to a bypass unit.- Branch hazards are resolved by predicting the address results.- Interruptions and exceptions are taken in account thanks to a system coprocessor.AssembleeAn assembly gasm is p</div>
                    <a href='cores/processor/minimips/index.html'>minimips</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_minimips'>code</a>
                </td>
                <td>Mar 24, 2006</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionA fault tolerant for processorThe mips &euro;&ldquo; fault tolerant is mips 32 bits processor with error detection ( Fault Tolerant ). The processor implementation was designed by Lazaridis Dimitris.Main aspectsThe core is in 5 stages:- Instruction extraction- Instruction decoding- Execution- Memory access- Update registersIt supports almost all instructions of mips technology, R type, I type, Branch, Jump and multiply packet instructions.The multiply result is stored until is needed regardless if others instructions follows.There i</div>
                    <a href='cores/processor/mips-faulttolerant/index.html'>mips-faulttolerant</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mips-faulttolerant'>code</a>
                </td>
                <td>May 14, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor cification doneWishBone Compliant: NoLicense: LGPLDescriptionUPDATE 1-Jan-2014: This project has moved to GitHub. Please visithttps://github.com/grantea/mips32r1for the latest code. No further changes will be committed to this repository.A 32-bit MIPS processor which aims for conformance to the MIPS32 Release 1 ISA. This processor implementation was designed and built by Grant Ayers as part of the eXtensible Utah Multicore (XUM) project at the University of Utah, 2011-2012. Feel free to send questions or feedback to grant DOT ayers AT stanford.edu.Details- Single-issue in-order 5-stage pipelin</div>
                    <a href='cores/processor/mips32_release_1/index.html'>mips32 release 1</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mips32_release_1'>code</a>
                </td>
                <td>Apr 12, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one Compliant: NoLicense:DescriptionThis is a soft processor core written in verilog-2001 with five pipeline stages which supports almost MIPSI instructions. MIPS789 supports gcc-elf-mips tools provided by Steve Rhords, author of plasma.In fact, this core is designed based on this complier. I&euro;&trade;ve tested it by using a lot of C programs in a CYCLONE device EP1C6Q240  at 50MHZ frequence and it worked so well. By calculation, its CPI (cycle per instruction) is about 1.1 when run common programs.Features- Five stage- IF&amp;ID: instructions fetch /decode.- RF: register fetch /generate ne</div>
                    <a href='cores/processor/mips789/index.html'>mips789</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mips789'>code</a>
                </td>
                <td>Oct 2, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor provenWishBone Compliant: NoLicense: LGPLDescriptionThe mipsr2000 is mips 32 bits processor. The processor implementation was designed by Lazaridis Dimitris.Main aspectsThe core is in 5 stages:- Instruction extraction- Instruction decoding- Execution- Memory access- Update registersIt supports almost all instructions of mips technology, R type, I type, Branch, Jump and multiply packet instructions.The multiply result is stored until is needed regardless if others instructions follows.There is a separate memory for instructions and another for data read &euro;&ldquo; write which can be changed.</div>
                    <a href='cores/processor/mipsr2000/index.html'>mipsr2000</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mipsr2000'>code</a>
                </td>
                <td>Feb 6, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor :WishBone Compliant: NoLicense: LGPLDescriptionThis project is based on MIPS789 opencores project.We used MIPS789 core and added the cache infrastracture and AMBA bus from LEON3.The final core executes MIPS I instructions.It is downloaded on a Spartan3 fpga(gr-xc3s-1500).In order to test it we used the Leon3 Testbench.</div>
                    <a href='cores/processor/mips_enhanced/index.html'>mips_enhanced</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mips_enhanced'>code</a>
                </td>
                <td>Apr 10, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor : NoLicense: BSDDescriptionmmu180 is a MMU (memory mananagement unit) designed per original specifications of Zilog's Z180 family of processors (including Hitachi HD64180), which can be used to enhance any Z80-compatible core or physical processor to address up to 1 MiB of memory, per the original MMU specification. It allows most software written for Z180 devices to run on either a Z80-compatible core with mmu180, or on an actual Z80 or eZ80-family processor interfaced to mmu180 (e.g. in CPLD).StatusAt present, has been simulated with Icarus Verilog and also from within Xilinx ISE WebPACK, an</div>
                    <a href='cores/processor/mmu_for_z80_and_ez80/index.html'>mmu for z80 and ez80</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mmu_for_z80_and_ez80'>code</a>
                </td>
                <td>Oct 5, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor NoLicense: LGPL</div>
                    <a href='cores/processor/mpx_32-bit_cpu/index.html'>mpx 32-bit cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_mpx_32-bit_cpu'>code</a>
                </td>
                <td>Sep 22, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor : NoLicense: LGPLDescriptionmyBlaze is a synthesizable clone of the MicroBlaze Soft Processor written in myHDL (http://www.myhdl.org). It started as a translation of MB-Lite from VHDL to myHDL, along with a simple emulator. Its minimal configuration was tested on the Spartan-3E Starter Kit.Todos:1. Wishbone compliant2. Interrupt Controller3. Porting U-Boot</div>
                    <a href='cores/processor/myblaze/index.html'>myblaze</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_myblaze'>code</a>
                </td>
                <td>Nov 21, 2010</td>
                <td>Other</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  NoLicense: LGPLDescriptionThe NanoBlaze is a grow-up of the Xilinx Picoblaze microcontroller (http://www.xilinx.com/picoblaze.html),hence the name.Various sizes can be defined with the help of generic parameters:- registerBitNb defines the data bit width- programCounterBitNb allows to cope with different program lengths- stackPointerBitNb adapts to various nesting depths of the subroutines- registerAddressBitNb allows to choose the number of internal registers- scratchPadAddressBitNb allows to manage the size of the scratchpad- addressBitNb defines the size of the I/O spaceIt features an asse</div>
                    <a href='cores/processor/nanoblaze_the_expandable_processor/index.html'>nanoblaze the expandable processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_nanoblaze_the_expandable_processor'>code</a>
                </td>
                <td>Apr 9, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ovenWishBone Compliant: NoLicense: LGPLDescriptionNatalius is a compact, capable and fully embedded 8 bit RISC processor core described 100% in Verilog. It occupies about 268 Slices, 124 FFs, 503 LUTs (4 input) in Xilinx Spartan3E1600 (around 1.67% slices).  Natalius offers an assembler that can run on any python console.The instruction memory is implemented in two Xilinx BlockRAM Memories, it stores 2048 instructions, each instruction has a width of 16 bits (2048x16). Each instruction takes 3 clock cycles to be executed.DocumentationClick here to read the documentation:DocFeatures1.	8 Bit ALU</div>
                    <a href='cores/processor/natalius_8_bit_risc/index.html'>natalius 8 bit risc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_natalius_8_bit_risc'>code</a>
                </td>
                <td>Jun 8, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor roven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionNavr is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.Atmel AVR compatibleAllClassic Coreinstructions implemented, except conditional branches on I/O registersNo interrupt supportInterrupt related instructions behave as if the I (interrupt enable) bit is hardwired to 0Verilog-2001Used to control theSoftUSBOHCI USB hostFully synchronous2-stage pipelineAlmost cycle accurate with the original AVR. Most instructions execute in 1 cycle.Synthesis results (ISE 12.2 def</div>
                    <a href='cores/processor/navr_avr_clone_8-bit_risc/index.html'>navr avr clone 8-bit risc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_navr_avr_clone_8-bit_risc'>code</a>
                </td>
                <td>Apr 19, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  NoLicense: GPLDescriptionThis is a little-little processor core. It has 16 instructions. It is under developement again, since the latest version is deleted... It is not yet verified, tested, etc.It's written in Verilog, generaly for Spartan.Features-It's very little.-Easy to understand.-Easy to convert.-Easy to compile the RISC or CISC instructions into this small set of commands.StatusVer 0.1"post-alfa"Ver 0.2There was many errors of syntax...So now there are corrected, it's ready to synthesize.Not yet wholly tested.New in downloads:asm compiler C and Yacc/Lex versions (Alpha)simple simulat</div>
                    <a href='cores/processor/ncore/index.html'>ncore</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ncore'>code</a>
                </td>
                <td>Oct 28, 2007</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ification doneWishBone Compliant: NoLicense: LGPLDescription80186 instruction compatible, high performance processor, able to execute up to 40MIPS on a Spartan3AN FPGA. It requires ~1500 slices (25%) on a Spartan3AN. The speed performance is comparable with a 486 in 16bit real mode.FeaturesNext186 CPU features:- All 80186 intstructions are implemented according with the 80186 specifications (excepting ENTER instruction, which uses always 0 as the second parameter - level).- all 80186 exceptions implemented (divide error - INT0, Trace - INT1, Overflow - INT4, Bounds - INT5, Invalid opcode - INT</div>
                    <a href='cores/processor/next_80186_processor/index.html'>next 80186 processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_next_80186_processor'>code</a>
                </td>
                <td>May 31, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  proven,Specification doneWishBone Compliant: NoLicense: LGPLDescription- Z80 compatible processor.- All documented / un-documented intstructions are implemented.- All documented / un-documented flags are implemented.- All (doc / un-doc) flags are changed accordingly by all (doc / un-doc)instructions. The block instructions (LDx, CPx, INx, OUTx) have only the documented effects on flags. The Bit n,(IX/IY+d) and BIT n,(HL) un-documented flags XF and YF are implemented like the BIT n,r XF and YF, not actually like on the real Z80 CPU.- All interrupt modes implemented: NMI, IM0, IM1, IM2.- R regi</div>
                    <a href='cores/processor/nextz80/index.html'>nextz80</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_nextz80'>code</a>
                </td>
                <td>Jul 3, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor YesLicense: GPLDescriptionThe oks8 project is intended to provide a microcontroller in Verilog that likethe KS86C4204/C4208/P4208 microcontroller (Samsung Inc.). It is compatiblewith the SAM87RI instruction set and has some changes to support uC/OS.Two different top levels:- Less cycles of each instruction- 16bits program memory and data memorySAM87RI, KS86C4208, etc. are Trademarks of Samsung Inc. I have no idea ifimplementing this core will or will not violate patents, copyrights or causeany other type of lawsuits. I provide this core AS IS, without any warranties.Features- Capable of execut</div>
                    <a href='cores/processor/oks8/index.html'>oks8</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_oks8'>code</a>
                </td>
                <td>Jan 24, 2006</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor t: NoLicense: LGPLDescriptionOoOPs is intended to be a higher-performance alternative to other MIPS(TM)-compatible projects on OpenCores.  Many of the other CPU cores are targeted for low resource utilization and/or higher energy efficiency.  OoOPs will instead target higher performance (both frequency and IPC) through more aggressive pipelining and out-of-order execution.  This means that OoOPs will be more resource intensive, especially due to the nature of out-of-order architectures.  To help find better performance/area operating points for the user, many structure sizes and optional featu</div>
                    <a href='cores/processor/ooops-out-of-order_mips_tm_processor/index.html'>ooops-out-of-order mips tm processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ooops-out-of-order_mips_tm_processor'>code</a>
                </td>
                <td>Apr 3, 2012</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor A proven,Specification doneWishBone Compliant: NoLicense: BSD8-bit RISC processor core based on the Vautomation uRISCThis is a "clean" reimplementation of the Vautomation uRISC processor core (aka the "V8", also named the Arclite core) based on ISA documentation only.It implements the full v8 architecture with a few additions, most of which are optional:* Thirty-six basic instructions (and four new instructions)* 8-bit PSR(Program Status Register) with Zero, Carry, Negative, and Interrupt status bits, and 4 general purpose status bits.* Eight 8-bit registers, R0 though R7.* Accumulator registe</div>
                    <a href='cores/processor/open8_urisc/index.html'>open8 urisc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_open8_urisc'>code</a>
                </td>
                <td>Sep 23, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nse:DescriptionThe OpenCores54x (OC54x) DSP core is a cleanroom implementation of a popular family of DSPs designed by the No.1 DSP supplier from the southern part of the US.The core is designed to be software compliant with the original Texas Instruments C54x DSP. However, the core is not designed to be 100% compatible with the TI's C54x chips. The core features some extension and improvements over the original design, which make it not-compatible. Also, partially caused by the structure choosen, partially to not completely compete with TI, some operating modes and hence opcodes are not suppo</div>
                    <a href='cores/processor/opencores54x_dsp/index.html'>opencores54x dsp</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_opencores54x_dsp'>code</a>
                </td>
                <td>Jan 20, 2004</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/processor/opencpu32/index.html'>opencpu32</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_opencpu32'>code</a>
                </td>
                <td>Mar 31, 2012</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor WishBone Compliant: NoLicense:DescriptionThe OpenFire Processor Core is an open-source, binary-compatible MicroBlaze clone written in Verilog.  Binary-compatible means exactly that - a binary compiled for a MicroBlaze embedded system will run on an OpenFire that is placed in the same embedded system.  The OpenFire was designed for use in SCMP (Single Chip, Multiple Processor) and ASIP (Application Specific Instruction-set Processor) research.  The OpenFire has an advantage in these areas as the entire HDL source is available, creating ultimate flexibility.The OpenFire Processor Core was writte</div>
                    <a href='cores/processor/openfire_processor_core/index.html'>openfire processor core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_openfire_processor_core'>code</a>
                </td>
                <td>Dec 13, 2007</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor esign done,FPGA proven,Specification doneWishBone Compliant: NoLicense: BSDThe openMSP430 is a synthesizable 16bit microcontroller core written in Verilog. It is         compatible with Texas Instruments'MSP430 microcontroller         familyand can execute the code generated by any MSP430 toolchain in a near cycle accurate way.The core comes with some peripherals (16x16 Hardware Multiplier,Watchdog,         GPIO, TimerA, generic templates) and most notably with a two-wireSerial         Debug Interfacesupporting theMSPGCCGNU Debugger(GDB) for in-system         software debugging.While</div>
                    <a href='cores/processor/openmsp430/index.html'>openmsp430</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_openmsp430'>code</a>
                </td>
                <td>Jun 15, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor hBone Compliant: NoLicense: LGPLDescriptionThe project is based on OpenCores' OR1200 project.The core is now hyper pipelined. It is a technique to multiply the functionalityof a design by adding registers (called pipeline stage registers) to the core logicin order to multiply its functionality. If you are interested in the technology, go to www.cloudx.ccThe functional behavior of the OR1200 remains the same, the hyper pipelinedversion is used when multiple OR1200 cores (2, 3, ...) are instantiated in thesame design (multicores).The main benefit is the multiplication of the core's functionality</div>
                    <a href='cores/processor/openrisc_1200_hp_hyper_pipelined_or1200_core/index.html'>openrisc 1200 hp hyper pipelined or1200 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_openrisc_1200_hp_hyper_pipelined_or1200_core'>code</a>
                </td>
                <td>Aug 6, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  Updated: Jul 26, 2010SVN:BrowseLatest version:downloadStatistics:ViewOther project propertiesCategory:ProcessorLanguage:VerilogDevelopment status:PlanningAdditional info:WishBone Compliant: NoLicense: LGPLthank you very much!Retrieved from "http://opencores.org/or2k/Main_Page"This page was last modified on 18 July 2011, at 09:06.This page has been accessed 29,870 times.Privacy policyAbout OR2KDisclaimers</div>
                    <a href='cores/processor/openrisc_2000/index.html'>openrisc 2000</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_openrisc_2000'>code</a>
                </td>
                <td>Jul 14, 2010</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor provenWishBone Compliant: NoLicense: LGPLDescriptionThis project implements a single cycle core for the emulation of PIC16C5x microcomputers. The core requires the integrator to implement the I/O registers and program memory. The core provides these standard base architecture peripherals: timer, pre-scaler and clock multiplexer, and watchdog timer. The core provides selects and read/write strobes for the three I/O ports and the corresponding TRIS registers.The timer peripheral supports all normal functions of the timer 0 in the PIC16C5x family of 12-bit instruction processors. A fully synchron</div>
                    <a href='cores/processor/p16c5x/index.html'>p16c5x</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_p16c5x'>code</a>
                </td>
                <td>Apr 20, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor se:DescriptionThis project implements an 8 bit controller that is compatible with Atmel's AVR architecture, using VHDL (Very High speed integrated circuits Hardware Description Language).pAVR is not a specific controller of the AVR family, but rather a maximally featured AVR. It is configurable enough to be able to simulate most AVR family controllers.The goal was to obtain an AVR processor that is as powerful as possible (in terms of MIPS), with a work budget of about 6 months*man.pAVR is about 3x faster than the original core, if built with the same technology.The sources are modularized. Th</div>
                    <a href='cores/processor/pavr/index.html'>pavr</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_pavr'>code</a>
                </td>
                <td>Jul 1, 2009</td>
                <td>Unknow</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor shBone Compliant: NoLicense: GPLDescriptionFig D-1: A PDP-11/70 Console. These display and switch consoles were the  hallmark of the PDP-11 computers in the 70ties.  Picture courtesy of Henk Gooijen, see alsoHenk's PDP-11 collection.The project contains a completeDECPDP-11system: aPDP-11/70CPU with memory management unit, but without floating pointunit, a complete set of mass storage peripherals (RK11/RK05,RL11/RL02, RK70/RP06, TM11/TU10) and a basic set ofUNIBUSperipherals (DL11, LP11, PC11), and last but not least a cache andmemory controllers for SRAM and PSRAM. The design isFPG</div>
                    <a href='cores/processor/pdp-11-70_cpu_core_and_soc/index.html'>pdp-11/70 cpu core and soc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_pdp-11-70_cpu_core_and_soc'>code</a>
                </td>
                <td>Jun 21, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor icense: GPLDescriptionThe PDP-8 was one of the earliest minicomputers and was in use from the mid 1960s into the 1980s.Because the PDP-8 was relatively inexpensive and was available in various forms for many years, the PDP-8is remembered fondly by many programmers and engineersThis project implements a complete PDP-8 system.The system includes the many of the basic PDP-8 peripherals including:Configurable PDP-8 CPUMS8C 32K-word memoryKC8E Front PanelKE8 Extended Arithmetic ElementKM8E Extended MemoryKM8E Time SharingDK8EA/DK8EC/DK8EP Real Time ClockKL8E Asynchronous Serial Interface (x2)LS</div>
                    <a href='cores/processor/pdp-8_processor_core_and_system/index.html'>pdp-8 processor core and system</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_pdp-8_processor_core_and_system'>code</a>
                </td>
                <td>May 18, 2013</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  Compliant: NoLicense: LGPLBuilding team. If any beginner became inetersted in it, email me.AboutPepelatz MISC is a very small 16-bite processor written on Verilog.It can be used for learning Verilog HDL and computer low-level architecture.</div>
                    <a href='cores/processor/pepelatz_misc/index.html'>pepelatz misc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_pepelatz_misc'>code</a>
                </td>
                <td>May 25, 2011</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor venWishBone Compliant: NoLicense: OthersDescriptionThe Plasma CPU is a small synthesizable 32-bit RISC microprocessor.  It is currently running a live web server with an interrupt controller, UART, SRAM or DDR SDRAM controller, and Ethernet controller.  The Plasma CPU executes all MIPS I(TM) user mode instructions except unaligned load and store operations (see "Avoiding Limitations" below).This "clean room" CPU core is implemented in VHDL with either a two or three-stage pipeline.  It is running at 25 MHz on a Xilinx FPGA and also verified on an Altera FPGA.Success StoriesThe Plasma CPU along</div>
                    <a href='cores/processor/plasma-most_mips_itm_opcodes/index.html'>plasma-most mips itm opcodes</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_plasma-most_mips_itm_opcodes'>code</a>
                </td>
                <td>Jun 1, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor enWishBone Compliant: YesLicense: BSDThe Potato ProcessorThe Potato Processor is an implementation of the 32-bit integer subset of the RISC-V ISA.Notable features are:Supports the full RV32I subset of the RISC-V ISA, version 2.0.Supports the csrr\* and sret instructions from the RISC-V supervisor extensions draft, version 1.0.Includes a simple, direct-mapped instruction cache for high-speed performance.Includes a HTIF interface that can be used with the FROMHOST/TOHOST registers.Includes a Wishbone interface for integration into Wishbone-based systems.The processor has been tested on a Nexys 4</div>
                    <a href='cores/processor/potato_processor/index.html'>potato processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_potato_processor'>code</a>
                </td>
                <td>Jun 18, 2015</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ense:DescriptionMicrocontroller core compatible with 16C55 and 16F84.Single cycle VHDL implementations of 16C55 and 16F84. Four times faster than the original MCUs, otherwise timing compatible. Watchdog and EEPROM are not implemented. Both implementations use the configurable PPX16 12/14 bit instruction width core, other MCUs using the same instruction set can easily be implemented by creating a new top level.There are utilities included that can create VHDL ROMs for simulation and synthesis. The utilites create generic ROMs that can be used for simulation and for synthesis with Leonar</div>
                    <a href='cores/processor/ppx16_mcu/index.html'>ppx16 mcu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ppx16_mcu'>code</a>
                </td>
                <td>Jan 19, 2007</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor eWishBone Compliant: NoLicense: LGPLDescriptionProject Qrisc32 is academic research and implementation of 4 stages risc cpu. Testbench runs 3 different sorting algorithms on qrisc32 and shows cycles for each turn. For observing instruction set, please refer to "risc_report.pdf" file. For running simulation you can use Modelsim with run_sim.tcl file.Qrisc32 is implemented by using SystemVerilog.</div>
                    <a href='cores/processor/qrisc32_wishbone_compatible_risc_core/index.html'>qrisc32 wishbone compatible risc core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_qrisc32_wishbone_compatible_risc_core'>code</a>
                </td>
                <td>Dec 5, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  YesLicense: LGPL</div>
                    <a href='cores/processor/r2000_soc/index.html'>r2000 soc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_r2000_soc'>code</a>
                </td>
                <td>Nov 24, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor liant: NoLicense: LGPLDescriptionRaptor64 is a 64-bit multi-context RISC cpu that supports hyper-threading. There are 16 register sets that the processor automatically switches between at high speed. The processor is fully pipelined with a nine-stage pipeline. Stages: IF/RF/EX/M1/M2/M3/M4/WB/TR. Communication with memory is via a 32 bit MIG bus. The processor has a 8kB instruction cache and 16kB data cache. Also included is a 16 entry TLB for memory management. The processor uses 32 bit instructions.I've created two versions of the processor a non-hyper-threaded version (sc) in addition to the</div>
                    <a href='cores/processor/raptor64/index.html'>raptor64</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_raptor64'>code</a>
                </td>
                <td>Feb 16, 2013</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor oLicense: LGPLDescriptionThis CPU project does not implement fully AVR compatible core.Instead it realizes very minimal functionality.Task was to make kind of CPU that can fit into very small CPLD (Altera's EPM240T100C5) and still leave some space for other logic.Development platform was choosed opensource "Marsohod" board. About this board You can read more onhttp://www.marsohod.org/index.php/howtostart/platabut it is Russian idea and pages. This board is dedicated for education, hobbies, creating electronic toys etc.Board has 4 buttons, 8 LEDs, 2 step motor control sockets.In AVR8 project we</div>
                    <a href='cores/processor/reduced_avr_core_for_cpld/index.html'>reduced avr core for cpld</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_reduced_avr_core_for_cpld'>code</a>
                </td>
                <td>Aug 29, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor GA provenWishBone Compliant: NoLicense: OthersDescriptionThe risc16f84 project is intended to provide a small, easy to use microcontroller in Verilog.  The original code was VHDL, but I have done a wonderful translation of it into good clean Verilog code. (Well, I think it is wonderful, anyway.)  The VHDL code was called "CQPIC" and it was published in 1999 by Sumio Morioka of Japan, in the December 1999 issue of "Transistor Gijutsu Magazine."  I did the translation by hand, and then tested the design in actual hardware by running C code on it, and looking for correct behavior.  I realize that</div>
                    <a href='cores/processor/risc16f84/index.html'>risc16f84</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_risc16f84'>code</a>
                </td>
                <td>Jun 29, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor venWishBone Compliant: NoLicense: LGPLDescriptionA small RISC CPU (written in VHDL) that is compatible with the 12 bit opcode PIC family. Single cycle operation normally, two cycles when the program counter is modified. Clock speeds of over 40Mhz are possible when using the Xilinx Virtex optimizations.Licensed under LGPL.Legal StuffThis core is distributed in the hope that it will be useful, butWITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.You are responsible for any legal issues arising from the use of this core.PIC is a trademar</div>
                    <a href='cores/processor/risc5x/index.html'>risc5x</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_risc5x'>code</a>
                </td>
                <td>Sep 9, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ant: NoLicense: LGPLDescriptionThis project is an implementation of a processor compatible with the instruction set of the RISCO architecture.A description of the original RISCO ISA is available onhttp://hdl.handle.net/10183/21530.An assembler and a compiler are available onhttps://code.google.com/p/risco-llvm/.</div>
                    <a href='cores/processor/riscompatible/index.html'>riscompatible</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_riscompatible'>code</a>
                </td>
                <td>Aug 29, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor t: NoLicense:motivationThis project is my diploma paper i have written to gratuate at the University of Applied Sciences St.Gallen (Switzerland).DescriptionThis is a 4 stage 16-Bit RISC processor system on chip designed for a Xilinx Virtex FPGA. RAM and ROM both are blockRAM based.Additionally, it is equiped with a parallel multiplier, a 8-Bit input and a 8-Bit output port.This core wasn't designed for commercial but for educational use. RAM, ROM and the ports are designed with the schematic editor from Xilinx ISE. RAM and ROM are dual ported for an additional access over a pci bridge. The CPU</div>
                    <a href='cores/processor/risc_core_i/index.html'>risc_core_i</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_risc_core_i'>code</a>
                </td>
                <td>Jan 17, 2002</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor cense:DescriptionRISE (Rarest Instruction Set Ever) is a pipelined 16-bit RISC processor with a simple instruction set. One outstanding feature of the instruction set is that all instructions are conditional, i.e. the execution of a instruction may depend on flags in the status register. The processor is equipped with 16 registers: 12 general purpose registers and 4 registers that have are reserved for specific functions (e.g. program counter). The HDL used for this project is VHDL. For further information on the instruction set architecture have a look at this page:http://en.wikiversity.org/w</div>
                    <a href='cores/processor/rise_microprocessor/index.html'>rise microprocessor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_rise_microprocessor'>code</a>
                </td>
                <td>Jan 26, 2007</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one Compliant: YesLicense: LGPLDescriptionThe RTF65002 is a 32 bit processor with an instruction set influenced by the 6502 instruction set. It is a 16 register 32 bit word oriented design. The RTF65002 includes 65C816/65C02 emulation modes allowing it to run existing code. In native 32 bit mode the opcodes are redefined in a fashion suitable for 32 bit mode. An attempt has been made to follow the same pattern as the 6502 for opcodes. For instance opcode 69h is an add instruction on the 6502; it's an add instruction on the RTF65002 as well.Features- 32 bit WISHBONE burst mode compatible bus in</div>
                    <a href='cores/processor/rtf65002/index.html'>rtf65002</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_rtf65002'>code</a>
                </td>
                <td>May 4, 2014</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor iant: NoLicense: LGPLDescriptionrtf8088 is a core capable of executing the 8088 instruction set. The core uses a hard-wired state machine approach.</div>
                    <a href='cores/processor/rtf8088/index.html'>rtf8088</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_rtf8088'>code</a>
                </td>
                <td>Dec 30, 2012</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one Compliant: YesLicense: GPLS1 Core briefly...The S1 Core is a reduced version of the OpenSPARC T1 released by Sun Microsystems. While the T1 is a complete microprocessor with 8 cores (capable of running up to 32 concurrent threads) and includes a crossbar switch, L2 Caches and several other interfaces, the S1 takes only one 64-bit SPARC v9 core (capable of running from 1 up to 4 concurrent threads) and includes a Wishbone Master Interface to connect to the cores available on OpenCores.For more details please refer to theSimply RISC website, or to the newOpenSPARC SoC projectthat contains se</div>
                    <a href='cores/processor/s1_core/index.html'>s1 core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_s1_core'>code</a>
                </td>
                <td>Oct 1, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor venWishBone Compliant: NoLicense: LGPLDescriptionThe SAYEH processor (Simple Architecture,Yet Enough Hardware) has been designed for educational and benchmarking purpose. Relying on the material of the computer architecture course provide the necessary background for understanding details of the hardware of SAYEH, so it could be useful IP core for graduate or last year undergraduate students to implement computer architecture materials in a real processor design.Originally SAYEH has been developed in ECE at university of Tehran, IRAN.FeaturesSAYEH has a register file that is used for data proc</div>
                    <a href='cores/processor/sayeh_educational_processor/index.html'>sayeh educational processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_sayeh_educational_processor'>code</a>
                </td>
                <td>Jul 17, 2008</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor License: LGPLDescriptionThe SCARTS processor is small and flexible processor, which has been specifically designed for embedded systems with real-time requirements. The deterministic architecture (all instructions execute in a single cycle) and the support of conditional instructions significantly simplify the task of WCET analysis. For SW development there is a toolchain based on the GNU Binutils/GCC/GDB. Furthermore there is a port of the Red Hat Newlib, a C standard library for embedded systems.FeaturesRISC processor122 instructions, all single cycleMost instructions conditional4 stage pipe</div>
                    <a href='cores/processor/scarts_processor/index.html'>scarts processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_scarts_processor'>code</a>
                </td>
                <td>Apr 4, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor rovenWishBone Compliant: NoLicense: OthersDescriptionSSBCC.9x8 is a free Small Stack-Based Computer Compiler with a 9-bit opcode, 8-bit data core.  It creates vendor-independent, high-speed, low fabric utilization micro controllers for FPGAs.  It has been used in Spartan-3A, Spartan-6, Virtex-6, and Artix-7 FPGAs and has been built for Altera, Lattice, and other Xilinx devices.  It is faster and usually smaller than vendor provided processors.The compiler takes an architecture file that describes the micro controller memory spaces, inputs and outputs, and peripherals and which specifies the HD</div>
                    <a href='cores/processor/small_stack_based_computer_compiler/index.html'>small stack based computer compiler</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_small_stack_based_computer_compiler'>code</a>
                </td>
                <td>Feb 5, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  NoLicense: LGPLDescriptionsub86 is a frugal 32bits cpu that executes a small subset of the legacy x86-32 instructions.The core has been designed with a C compiler back end code generator with three focus :- limit the number of opcode and instructions as much as possible.- the resulting binary code must run functionally equivalent on real PC and on sub86 core.- make the core as small as possible, by limiting the number of required hardware ressources ( alu , multiplier , number of registers : only EAX/EBX/ECX/EDX/ESP/EBP/PC/flags registers are implemented).The status of the development (in Dec</div>
                    <a href='cores/processor/small_x86_subset_core/index.html'>small x86 subset core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_small_x86_subset_core'>code</a>
                </td>
                <td>Dec 18, 2012</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor e Compliant: YesLicense: GPL</div>
                    <a href='cores/processor/storm_core_arm7_compatible/index.html'>storm core arm7 compatible</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_storm_core_arm7_compatible'>code</a>
                </td>
                <td>Mar 8, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor fication doneWishBone Compliant: NoLicense: LGPLDescriptionSweet32 is best described as a &euro;&tilde;no-frills&euro;&trade; Minimal-RISC 32bit microprocessor, created by Valentin Angelovski in Melbourne Australia.Designed with low gate-count in mind, typical Sweet32 logic utilization on theLattice MachXO2 FPGA (for example), is 842 LUT4 elements in a standard configurationand area-optimized form. Further details can be found in theSweet32 RISC CPU overview 0v80. HDL sources can be found in the SVN link given aboveSweet32 Architecture Summary:16x32-bit General Purpose CPU registers27 In</div>
                    <a href='cores/processor/sweet32_cpu/index.html'>sweet32 cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_sweet32_cpu'>code</a>
                </td>
                <td>Nov 21, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor :Description32 bit pipelined processor.Instruction set is non conventional in that it does not use a conventional decoder for instructions. The instruction set is made by collecting together "atomic" control signals together to form the instruction.  This was done to eliminate the need for the decoder and save an extra pipeline stage.  As a consequence latency is reduced and recovery from pipeline flushes do not degrade performance as badly.The design goals for the processor were speed, small size and flexibility.An extensible bus architecture is supported so that extra functions and bus archi</div>
                    <a href='cores/processor/sxp_simple_extensible_pipeline__processor/index.html'>sxp simple extensible pipeline  processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_sxp_simple_extensible_pipeline__processor'>code</a>
                </td>
                <td>Dec 12, 2001</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nWishBone Compliant: NoLicense: GPLDescriptionThe T400 Controller is an implementation of National's 4-bit COP400 microcontroller family architecture. It is intended to be used as a replacement for the original chip in SOCs recreating legacy systems.Its final target is to provide design variants that are compatible with the COP420/421 and COP410L/411L family members. All of them derived from the common t400_core design. Such a sample system has been implemented in several FPGA families.COP421-like features64 bytes internal RAM1024 bytes internal ROM (only small part used for program)4 MHz requ</div>
                    <a href='cores/processor/t400_controller/index.html'>t400 controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_t400_controller'>code</a>
                </td>
                <td>Aug 19, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor WishBone Compliant: NoLicense: GPLDescriptionThe T48 Controller core is an implementation of the MCS-48 microcontroller family architecture. While being a controller core for SoC, it also aims for code-compatability and cycle-accuracy so that it can be used as a drop-in replacement for any MCS-48 controller.It can be configured to better suit the requirements and characteristics of the integrating system. On the other hand, nearly the full functionality of a stock 8048/8049 is available.Such a sample system has been implemented in several FPGA families.8048-like features64 bytes internal RAM10</div>
                    <a href='cores/processor/t48_controller/index.html'>t48 controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_t48_controller'>code</a>
                </td>
                <td>Aug 19, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor pliant: YesLicense: LGPLDescription8052 compatible microcontroller core.Two different top levels:T8052:- Single cycle synchronous RAM/ROM- Wishbone bus interface for memory mapped peripheralsT8032:- Wishbone bus interfaceA utility to create VHDL ROMs is also included.To create a ROM compatible with the 8052 core type:hex2rom [-b] inputfile.hex ROM52 13b8s &gt; ROM52.vhdLeonardo Spectrum can infer the ROMs created with hex2rom to Xilinx block RAM.I have also modified the baud rate recognition of the BASIC-52 ROM to support the faster instruction timing. The modified </div>
                    <a href='cores/processor/t51_mcu/index.html'>t51 mcu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_t51_mcu'>code</a>
                </td>
                <td>Apr 1, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor pliant: NoLicense:DescriptionConfigurable cpu core that supports 6502, 65C02 and 65C816 instruction sets.A SoC debug system with ROM, RAM and two 16450 UARTs is included in the distribution. It is possible to run the NoICE debugger on this system.Batch files for runnning XST and Leonardo synthesis can be found insyn/xilinx/run/. Check these scripts to see how to use the included VHDL ROM generators.Before you can run the scripts you need to compile hex2rom and xrom or download binaries fromhere. You must also replace one of the hex files in sw/ or change the batch files to use anot</div>
                    <a href='cores/processor/t65_cpu/index.html'>t65 cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_t65_cpu'>code</a>
                </td>
                <td>Mar 31, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ication doneWishBone Compliant: NoLicense: GPLDescriptionA 6507-compatible microprocessor was developed. It will be used in a SoC that targets the ATARI 2600 system. RIOT(MOS 6532) and TIA chips will be developed to complete the entire system.Features- Cycle accuracy with original 6507.Status- July 2009. Project ended.- April 28, 2009 - ALU 100% covered. FSM still undergoing verification.- March 26, 2009 - Verification started.- March 25, 2009 - Simulation ended. ALU and FSM are coded.- March 18, 2009 - Simulation started.- March 06, 2009 - ALU and FSM started to be coded. No support for undoc</div>
                    <a href='cores/processor/t6507lp/index.html'>t6507lp</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_t6507lp'>code</a>
                </td>
                <td>Dec 6, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor se:DescriptionConfigurable cpu core that supports Z80, 8080 and gameboy instruction sets.Z80 and 8080 compability have been proven by numerous implementations of old computer and arcade systems.It is used in thezxgateproject, a zx81, zx spectrum, trs80 and Jupiter ACE clone project.And also in theFPGA Arcadeproject.A Z80 SoC debug system with ROM, RAM and two 16450 UARTs is included in the distribution. It is possible to run the NoICE debugger on this system.Batch files for runnning XST and Leonardo synthesis can be found insyn/xilinx/run/. Check these scripts to see how to use</div>
                    <a href='cores/processor/t80_cpu/index.html'>t80 cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_t80_cpu'>code</a>
                </td>
                <td>Jun 9, 2015</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nWishBone Compliant: NoLicense: LGPLATTENTION!Only the SVN was updated.I don't know how I can update the latest version download.DescriptionThis is a stable Version of a 68000 compatible CPU.It is an adapted Version to use with the Minimig Core."compatible" means that most of byte and word Instructions are cycle exact but many other Instructions are faster."adapted" means that the synchronous Mode, some bus control signals and the FC Out are missing. They are not needed for the minimig.Featurescirca 3600 LC's on a ALTERA Cyclone II,circa 2700 Slices an a XILINX Spartan 3,StatusTested with the </div>
                    <a href='cores/processor/tg68-execute_68000_code/index.html'>tg68-execute 68000 code</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_tg68-execute_68000_code'>code</a>
                </td>
                <td>Jun 13, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nt: NoLicense:The Neptune coreNeptune is an attempt to create a new, next-generation processor architecture.IMAGE: triton-block.pngFILE: triton-block.pngDESCRIPTION: This 8008 block diagram is filler until a new one is designed.</div>
                    <a href='cores/processor/the_neptune_core/index.html'>the neptune core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_the_neptune_core'>code</a>
                </td>
                <td>Feb 19, 2006</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nt: YesLicense: GPLOverviewTheia GPU OverviewTheia is a fully programmable Graphic Processing Unit written in structural VerilogTheia features a multi-core architecture.Theia uses a Ray-Cast approach to perform the RENDER. The Multi-core architectue benefits fromthe parallel nature of Ray casting.Each core has a pipe-lined SIMD ALU, capable of performing Fixed Point arithmetic on 3D vectors.Theia's instruction set includes logic, arithmetic and flow control instructions.Theia features a default code written into each core's ROM.The default code allows a fully functional RENDER including textur</div>
                    <a href='cores/processor/theia_ray_graphic_processing_unit/index.html'>theia ray graphic processing unit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_theia_ray_graphic_processing_unit'>code</a>
                </td>
                <td>Aug 16, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor cense:DescriptionSimple minimal VHDL RISC processor.Heavily inspired by Tim Bscke and his MCPU project (Avaiable here on opencores), the processor is an accumulator based machine with an index register.The processor, like Tim's, was designed to fit in small FPGA or large CPLD.License is free - do with it what you will.  It would be nice if you credited me, however - we all have to work.I have no idea if implementing this core will or will not violate patents, copyrights or cause any other type of lawsuits. I provide this core AS IS, without any warranties.Features- Accumulator based machine- 8</div>
                    <a href='cores/processor/tiny_instruction_set_computer/index.html'>tiny instruction set computer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_tiny_instruction_set_computer'>code</a>
                </td>
                <td>Feb 27, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor NoLicense:Description Tiny64A 64-Bit RISC CPU with minial resource usage. Every opcode is executed in 2 clock cycles.The word size is configurable via XLEN from 32 up to the FPGA limit. The assembler supports alsodiffernet word sizes.Due simplicity TinyX supports no interrupts, cache, MMU, FPU.Interrupts may supported in the future.The assembler syntax is unusual. because jump instructions are codedas MOV to the R7 register.At March 2004 is was tested 32-Bit and 64-Bit in the Xilinx XC2S200 SpartanII.Features Tiny642 clock cycles on all op-codesR7, the PC is equal handled like a normal registe</div>
                    <a href='cores/processor/tiny64/index.html'>tiny64</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_tiny64'>code</a>
                </td>
                <td>May 7, 2007</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor oLicense:DescriptionTiny8 a simple 8 bit microprocessor with classic CISC architecture.The registers resides in RAM addressed via a base pointer in the WPregister (like the TMS9900). So it has 256 8-bit registers that can be combined to 128 16-bit address registers (the registers pairing is free, no adjacend register numbers needed).This project contains also a simple assembler.FeaturesUses an ALTERA 10k10 device, only 60% of its resources needed.256 8-bit registers or 128 16-bit address registers.Statusready to be used</div>
                    <a href='cores/processor/tiny8/index.html'>tiny8</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_tiny8'>code</a>
                </td>
                <td>Feb 11, 2007</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor shBone Compliant: NoLicense: BSDDescriptionThis is a tiny processor meant to be nice and simple. Here are a few of the technical goals of this processor:1. 8-bit processor (8 bit registers and operations)2. 16-bit address bus (capable through "segment registers" similar to the 80863. 1 instruction per clock cycle4. Hopefully simple to understand code</div>
                    <a href='cores/processor/tinycpu/index.html'>tinycpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_tinycpu'>code</a>
                </td>
                <td>May 17, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one Compliant: NoLicense:DescriptionTotalCPU is RISC core with 12-bit instruction width and variable data width (from 12 to 64 bits). It is completely realized on Verilog-2001 and has two variants of implementation - with program counter placed in register block or defined as a standalone register. The first variant requires less hardware resources but it is almost 2 times slower then the second variant. It has its own instruction set that doesn&euro;&trade;t depend upon data path width.the description and sources of TotalCPU arehttp://www.opencores.org/cvsweb.shtml/totalcpu/(here)Status- Desi</div>
                    <a href='cores/processor/totalcpu/index.html'>totalcpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_totalcpu'>code</a>
                </td>
                <td>Jun 16, 2007</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor nt: YesLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).Functional Block Diagram</div>
                    <a href='cores/processor/turbo_8051/index.html'>turbo 8051</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_turbo_8051'>code</a>
                </td>
                <td>Feb 14, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ovenWishBone Compliant: NoLicense: BSDDescriptionThe TV80 is an 8-bit Z80-compatible microprocessor core, written in Verilog.  It is based on Daniel Wallner's VHDL T80 core.Features- executes 8080/Z80 instruction set- cycle timing is similar to original Z80- small die area- sample peripheral with GMII interface- Optional Wishbone wrapper for TV80 core now availableStatus- taped out in TSMC 130nm (250 Mhz, ~20k gates)- taped out in TSMC 65nm process (125 Mhz)- Microprocessor-controlled verification environment</div>
                    <a href='cores/processor/tv80/index.html'>tv80</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_tv80'>code</a>
                </td>
                <td>Oct 17, 2012</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor e Compliant: YesLicense:DescriptionUCore is a RISC microprocessor compatible of the MIPS32R2 Instruction Set. It can run all the MIPS32R2 instructions except the branch likely instructions. For these instructions are not recommended in the specification.The processor has 6 pipeline stages: Instruction Fetch (IF), Instruction Decode (ID), Register Fetch (RF), Execution (EX), Memory Access (MEM) and Write Back (WB).The processor uses synchronous ram as its Register file, data RAM and instruction RAM, which makes it be easily implemented in both FPGA and ASIC, especially in FPGA.The processor fs </div>
                    <a href='cores/processor/ucore/index.html'>ucore</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_ucore'>code</a>
                </td>
                <td>Aug 4, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ompliant: YesLicense: BSDDescriptionThis project is a soft processor core compatible with 586 instruction set.It has been developped on Nexys4 board, with Artix7-100 FPGA with external SRAM and SPI flash.The project contains the core and also a platform to demonstrate the core with interfaces forexternal 16MB SRAM and 128Mbit SPI Flash.The platform boots linux kernel with a ramdisk contained in the SPI flash.The processor core has wishbone interface.** CORE DETAILS:* Features:- 586 instruction set implementation, conditional mov added.- MMU with protected and paged mode supported with 4KB page</div>
                    <a href='cores/processor/v586/index.html'>v586</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_v586'>code</a>
                </td>
                <td>May 31, 2015</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor mpliant: NoLicense: GPLemulating the IC6821One day my partern says lets make this old board smaller. But a lot of IC6821. So emulate them into an FPGA. So i developed the code in VHDL. The 6821 is a peripheral from MOTOROLA. It has two bidir ports PA,PB and four interrupt inputs, two of them also can be configured for handshake.Not time to write yet.- feature1- feature1.1-feature1.2-feature2Status early yet-- On 16 december 2005 i finished the coding and some basing simulation using the QUARTUS web edition.FILE: VHDL6821.vhdFILE: VHDL6821.vhdDESCRIPTION:</div>
                    <a href='cores/processor/vhdl_core_of_ic6821/index.html'>vhdl core of ic6821</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_vhdl_core_of_ic6821'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor : NoLicense: LGPLDescriptionVerilog implementation of the old CARDIAC teaching computer from Bell (the one made out of cardboard). This version runs on a Spartan 3 board from Digilent and it is pretty faithful to the original.Documentation about the project:http://www.drdobbs.com/embedded-systems/the-heart-of-a-cpu/240153772http://www.drdobbs.com/embedded-systems/expanding-vtach/240155198http://www.drdobbs.com/embedded-systems/cardiac-to-fpga/240155599http://www.drdobbs.com/embedded-systems/paper-to-fpga/240155922</div>
                    <a href='cores/processor/vtach-bell_labs_cardiac_reimagined_in_verilog/index.html'>vtach-bell labs cardiac reimagined in verilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_vtach-bell_labs_cardiac_reimagined_in_verilog'>code</a>
                </td>
                <td>Mar 30, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor one Compliant: YesLicense: LGPLDescriptionVHDL reads a file of instructions to perform Wishbone access, as if it's a wishbone master.Used in testing a Wishbone peripheral with out having to instantiate and program a 'CPU' functionThe aim is to have a text file with commands in it, which is the only bit that needs to be modified for different tests.This test file is read in to the units, which runs the test.Features- tested out with Modelsim 6.2g and Xilinx ISE 9.2 sp4StatusFirst bits of VHDL put into CVS.Have in package commandsW32 and R32 for 32 bit reads and writes.BKW32 and BKR32 for block </div>
                    <a href='cores/processor/wishbone_bfm/index.html'>wishbone bfm</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_wishbone_bfm'>code</a>
                </td>
                <td>Feb 21, 2008</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor ne Compliant: YesLicense:notesWhile the greatest percentage of the logic for this processor has been verified, there are still a copule of areas of concern.1) Interrupt testing should be better2) hazard testing should be better.3) There is at present not a written verification plan.Guy Hutchison (see TV80 project) has synthesized an early version of the core in a 130nm TSMC process.  He determined the design to contain about 20k gates and run at about 240 Mhz.   While the speed is somewhat less than "target", optomizations of the logic should increase this somewhat.I have synthesized the prese</div>
                    <a href='cores/processor/wishbone_high_performance_z80/index.html'>wishbone high performance z80</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_wishbone_high_performance_z80'>code</a>
                </td>
                <td>Jun 25, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  Compliant: NoLicense: BSDDescriptionZ80/Z180 compatible processor softcore. Based on Y80 project described in the book 'Microprocessor Design Using Verilog HDL' of Monte Dalryple from Systemyde. If you want to understand internals of CPU then this book may greately help you to do it.This CPU supports commonly used Z80 undocumented instructions: operations with halfs of index registers and SLI/SLL (Shift Left Logical). Optionally it supports emulation of R register.Additionally CPU is Z180 compatible. Supported all IO, MLT (implemented via standard Verilog multiplication) and TST instructions.</div>
                    <a href='cores/processor/y80e-z80-z180_compatible_processor_extended_by_ez8/index.html'>y80e-z80/z180 compatible processor extended by ez8</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_y80e-z80-z180_compatible_processor_extended_by_ez8'>code</a>
                </td>
                <td>May 29, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  Compliant: NoLicense:DescriptionYACC (Yet Another CPU CPU) is MIPS I (TM) subset cpu written in Verilog-2001 HDL. YACC has 5 pipeline and shows 110 DMIPS in stratix2 with synthesized allowable clock of 165MHz. It is independent design of plasma, although YACC uses gcc-elf-mips tools provided by Steve Rhords, author of plasma (Most mips written in VHDL).The core was developed by using my Simulator, with post layout gate simulation, and tested by actual FPGAs, using Xilinx spartan3 starter kit and Cyclone by Altera,running 800 digits of pi calculation ,(255,223) Reed Solomon Error Correction ,a</div>
                    <a href='cores/processor/yacc-yet_another_cpu_cpu/index.html'>yacc-yet another cpu cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_yacc-yet_another_cpu_cpu'>code</a>
                </td>
                <td>Apr 25, 2005</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor NoLicense:IMAGE: ys_logo.jpgFILE: ys_logo.jpgDESCRIPTION: Yellow Star LogoDescriptionIt is capable of executing 32bit instructions based on the MIPS R3000 microprocessor instruction set and has been tested running large blocks of compiled C code.Fully functional and compatible interrupt system. Can handle all exceptions cleanly and correctly.Two 2Kbyte (Data and Instruction) direct mapped caches with coherency.Memory management unit with 64 Entry TLB fully compatible to original design.Designed in Powerview package but can be distributed in hierarchical schematic EDIFWarning: The manual stated</div>
                    <a href='cores/processor/yellow_star/index.html'>yellow star</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_yellow_star'>code</a>
                </td>
                <td>Jul 8, 2013</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor oLicense: BSDDescriptionA Verilog implementation of the Infocom Z-Machine V3. The spec the Z3 follows ishttp://inform-fiction.org/zmachine/standards/z1point0/index.html.Specifically version 3, the so called "Standard" games. These were released between 1982 and 1987 and covers most Infocom games. Z3 passes the "CZECH - Comprehensive Z-machine Emulation CHecker" by Amir Karger. And is known to run at least Zork I, Hitchhiker's Guide to the Galaxy, Planetfall and Curses (by Graham Nelson).The following YouTube video shows it in action:http://www.youtube.com/watch?v=HuQZq6DQQDYTo provide the inpu</div>
                    <a href='cores/processor/z3-the_zork_cpu/index.html'>z3-the zork cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_z3-the_zork_cpu'>code</a>
                </td>
                <td>Nov 30, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor t: NoLicense: GPLDescriptionMicroprocessor targeting embedded industrial control systems.  Uses a z80 core available at opencores as T80.  It is in early development stages.  It is currently being developed with a Altera Cyclone II FPGA Starter Board (DE1).  The idea is to have a system that will communicate to a PLC and a PC via serial interface.  This allows the ability to expand peripherials on a PLC while giving the user PC control from a visual enviroment using custom software.</div>
                    <a href='cores/processor/z80control/index.html'>z80control</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_z80control'>code</a>
                </td>
                <td>Dec 1, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor  Compliant: YesLicense: GPLDescriptionTheZet SoC PC platformandprocessoris an open implementation of the so widely usedx86architecture. This project is being developed using four different FPGA boards:Xilinx ML-403,Altera DE0,Altera DE1andAltera DE2-115boards. Currently it's in a very early stage of development and only the 16 bit part is supported. The official website for the project is:zet.aluzina.org.Some features of theZet SoC PC systeminclude:16 bitZet processorequivalent to an Intel 80186, running at 25 Mhz (Wishbone compatible)WishboneZBT SRAM memory controlleraddressing 1 Mb of lo</div>
                    <a href='cores/processor/zet-the_x86_ia-32_open_implementation/index.html'>zet-the x86 ia-32 open implementation</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_zet-the_x86_ia-32_open_implementation'>code</a>
                </td>
                <td>Nov 4, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>processor n,Specification doneWishBone Compliant: YesLicense:The worlds smallest 32 bit CPU with GCC toolchainRead about some of the professional uses of the ZPU:http://www.zylin.com/zpuexpertise.htmlThe ZPU is a small, portable CPU core with a GCC toolchain and eCos RTOS support.The ZPU has a FreeBSD license for the HDL and GPL for the rest. This allows deployments to implement any version of the ZPU they want without running into commercial problems, but if improvements are done to the architecture as such, then they need to be contributed back.One strength of the ZPU is that it is tiny and therefore </div>
                    <a href='cores/processor/zpu-the_worlds_smallest_32_bit_cpu_with_gcc_toolch/index.html'>zpu-the worlds smallest 32 bit cpu with gcc toolch</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/processor_zpu-the_worlds_smallest_32_bit_cpu_with_gcc_toolch'>code</a>
                </td>
                <td>Sep 14, 2009</td>
                <td>Other</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <td>
                    <b>SYSTEM ON CHIP</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip mpliant: NoLicense: LGPLDescriptionSingle channel 32 or 64 bit AHB master DMA core. Supports simultaneous read and write, command lists, peripheral control, timeouts and endianess swapping. Based on Provartec PR201http://www.provartec.com/ipproductsRelated projectsGeneric AHB matrixhttp://opencores.org/project,robust_ahb_matrix</div>
                    <a href='cores/system_on_chip/ahb_dma_32-64_bits/index.html'>ahb dma 32/64 bits</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_ahb_dma_32-64_bits'>code</a>
                </td>
                <td>Jun 25, 2013</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip esign doneWishBone Compliant: NoLicense: LGPLOther project propertiesCategory :: SoCLanguage :: VHDLLicense :: LGPLDevelopment status :: Production/StableFeatures- AMBAtm specification compliant (rev 2.0)- unified approach to multi-layer, lite and full amba systems- programmable arbiter- "template" master with programmable internal fifo and read/write latencies- "template" slave with simple default behaviour (i.e. no "split/retry" responses)- GUI for start-up- testbench generation specific to the created system- check of connection correctnessDescriptionThe intention is to provide an easy way </div>
                    <a href='cores/system_on_chip/ahb_system_generator/index.html'>ahb system generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_ahb_system_generator'>code</a>
                </td>
                <td>Mar 31, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip  done,FPGA proven,Specification doneWishBone Compliant: YesLicense:DescriptionAHB Protocol to Wishbone Protocol Bridge.Features- AHB 2.0 compliant- Wishbone B.3 compliant- AHB Burst NOT SUPPORTED- Fully synthesisable- Synchronous- Verilog RTL- Includes a Verilog Testbench with 10 TestcasesStatus- RTL : Complete- Testbench : Complete- Document : Complete</div>
                    <a href='cores/system_on_chip/ahb_to_wishbone_bridge/index.html'>ahb to wishbone bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_ahb_to_wishbone_bridge'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip Bone Compliant: YesLicense: BSDDescriptionThe OpenCores aoOCS SoC is a Wishbone compatible implementation of most of the Amiga Original Chip Set (OCS) and computer functionality.aoOCS is not related in any way with Minimig - it is a new and independent Amiga OCS implementation.IntroductionJuly 2011: Project copied to (https://github.com/alfikpl/aoOCS). Further development of aoOCS will continue on github.FeaturesThe aoOCS SoC contains the following Amiga/OCS components:blittercoppersystem control (interrupts)video: bitplains, sprites, collision detectionaudio: 4 channels, low-pass filteruser i</div>
                    <a href='cores/system_on_chip/aoocs-wishbone_amiga_ocs_soc/index.html'>aoocs-wishbone amiga ocs soc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_aoocs-wishbone_amiga_ocs_soc'>code</a>
                </td>
                <td>Aug 4, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ant: NoLicense:DescriptionA open source ARM vhdl model.The annotated vhdl source can be browsed here:http://cfw.sourceforge.net/build_html/vhdl/index.htmFeaturesNote: This version (0.8) is still beta. Until we switch to release the arm iu will not be fully functional. Until then you are welcome to join development. Testers, coders, moderators, freaks, jobless and nerds are welcome (professionals are tolerated).- ARM instruction set- Processor frameworkStatus- Version 0.8 Beta</div>
                    <a href='cores/system_on_chip/arm_core/index.html'>arm core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_arm_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip cation doneWishBone Compliant: NoLicense: LGPLDescriptionHere is proposed a method to implement short structured programs inside an FPGA. The novelty of the proposed method resides in that the commands that constitute the executable program are defined directly by the user in VDHL code. Applying this method, the resolution of a problem can be partitioned in two: on the one hand, the  complex hardware functions can be implemented by the VHDL definitions, while, on the other hand, the higher level take of decisions, loops, iterations and conditional branching or testing can be assumed by the exe</div>
                    <a href='cores/system_on_chip/assembler_with_vhdl_user-defined_commands_avuc/index.html'>assembler with vhdl user-defined commands avuc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_assembler_with_vhdl_user-defined_commands_avuc'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip proven,Design done,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionAsynchronous Spatial Division Multiplexing Router for On-Chip NetworksVersion: 0.2On-chip networks or networks-on-chip (NoCs) are the on-chip communication fabric forcurrent and future multiprocessor SoCs (MPSoCs) and chip multiprocessors (CMPs).Compared with synchronous NoCs, asynchronous NoCs have following benefits:* Tolerance to all kinds of delay variations caused by process, power and temperaturevariations.* Low transmission latency.* Zero dynamic power when idle.* Unified sync/async interface and easy clo</div>
                    <a href='cores/system_on_chip/async-sdm-noc/index.html'>async-sdm-noc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_async-sdm-noc'>code</a>
                </td>
                <td>Jun 8, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip mpliant: NoLicense: LGPLDescriptionSingle channel 32 or 64 bit AXI master DMA core. Supports simultaneous read and write, outstanding AXI commands, command lists, peripheral control, timeouts and endianess swapping. Based on Provartec PR200http://www.provartec.com/ipproductsRelated projectsGeneric AXI interconnect fabrichttp://opencores.org/project,robust_axi_fabric</div>
                    <a href='cores/system_on_chip/axi_dma_32-64_bits/index.html'>axi dma 32/64 bits</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_axi_dma_32-64_bits'>code</a>
                </td>
                <td>Apr 29, 2011</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ,FPGA provenWishBone Compliant: NoLicense: LGPLDevelopment StatusThis core has been verified with ModelSim and Quartus SignalTap II, using basic directed testcases as well as coverage-driven constrained random verification techniques. I would like to increase the test coverage in future. I also plan to add hardware results from Xilinx ChipScope, as well as simulation results from other simulators as well. If you have simulated or verified this core, please let me know how this core works with your toolchain. I believe Aldec ActiveHDL/Riviera Pro and Synopsys Synplify should have no problems, b</div>
                    <a href='cores/system_on_chip/axi4_transactor_and_bus_functional_model/index.html'>axi4 transactor and bus functional model</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_axi4_transactor_and_bus_functional_model'>code</a>
                </td>
                <td>Apr 19, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ompliant: NoLicense: GPLOverviewThis is a lecture about designing a SoC in VHDL.Everything runs under Linux - no more Windows!Check it out and then start at the file named index.html.Enjoy!</div>
                    <a href='cores/system_on_chip/cpu_lecture/index.html'>cpu lecture</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_cpu_lecture'>code</a>
                </td>
                <td>Apr 13, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip hBone Compliant: NoLicense: BSDCurrent stable version/eco32/tags/eco32-0.26DescriptionThe ECO32 system is a microprocessor system-on-chip, consisting ofa 32-bit CPU and several controllers for peripheral devices (keyboard,character display, timer, serial line, SDRAM, Flash-ROM, IDE disk).The ECO32 CPU is a simple 32-bit RISC processor with an instructionset loosely modelled after MIPS, currently without floating pointinstructions. We want to execute some flavour of UNIX on it, so ithas got two operating modes (kernel/user) and a memory managementunit (paging with TLB support). The processor wa</div>
                    <a href='cores/system_on_chip/eco32/index.html'>eco32</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_eco32'>code</a>
                </td>
                <td>Mar 19, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ompliant: NoLicense:DescriptionEmbedded 32-bit mini RISC uProcessor project with SDRAM controller will develope a basic block IP (Intellectual Properties) for designing a complete SOC (System On a Chip) system. Today almost in every Advanced Digital products you will find a few uController or uProcessor. Both of these cathegories needs a processing power to recieve some sord of input or data and needs to process it for the end application or perhaps to store the input/data. In order for the system to process or perhaps store the incoming data it needs to distinguish between the incoming comman</div>
                    <a href='cores/system_on_chip/embedded_32-bit_risc_uprocessor_with_sdram_control/index.html'>embedded 32-bit risc uprocessor with sdram control</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_embedded_32-bit_risc_uprocessor_with_sdram_control'>code</a>
                </td>
                <td>Mar 13, 2011</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip  NoLicense:Architecture DescriptionField-Programmable Gate Arrays (FPGAs) are flexible and reusable high-density circuits that can be (re)configured by the designer, enabling the VLSI design/validation/ simulation cycle to be performed more quickly and cheaply.The flexibility provided by FPGAs cause a substantial performance penalty due to non-specialized circuit design and signal delay through the programmable routing resources, compared do ASIC designs but FPGAs are still 1000 times faster than circuit simulators.This core provides plural of high-speed reprogrammable logic. This FPGA</div>
                    <a href='cores/system_on_chip/embedded_fpga_core/index.html'>embedded fpga core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_embedded_fpga_core'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Planning</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip shBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/system_on_chip/epc_rfid_transponder/index.html'>epc rfid transponder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_epc_rfid_transponder'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip fication doneWishBone Compliant: NoLicense: LGPLDescriptionA simple 16-bit microprocessor together with a simple bus system. It utilises the Xilinx dual port ram features to be able to fetch instructions and use data memory at the same time. It is defined using RISC principles, featuring a small instruction set and overlapping execution. It is not completely pipelined. A first estimate gives a CPI of 2.2. Using a small memory a clock speed of 160 MHz is achievable on a Spartan-6 device with speed grade 2. Using larger memory will slow down the system due to net delays. The goal is to always re</div>
                    <a href='cores/system_on_chip/experimental_unstable_cpu/index.html'>experimental unstable cpu</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_experimental_unstable_cpu'>code</a>
                </td>
                <td>Jan 25, 2015</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip A provenWishBone Compliant: YesLicense: OthersDescriptionThe GECKO system is a general purpose hardware/software co-design environment for real-time information processing and/or system-on-chip (SoC) solutions. The GECKO system supports a new design methodology for system-on-chips, which necessitates co-design of software, fast hardware and dedicated real-time signal processing hardware.This is now the third generation of these boards, so the current project is called GECKO3.All GECKO3 system components can be stacked together, as they all have a common backbone bus connector and all have the </div>
                    <a href='cores/system_on_chip/gecko3_soc_co-design_environment/index.html'>gecko3 soc co-design environment</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_gecko3_soc_co-design_environment'>code</a>
                </td>
                <td>Mar 16, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip liant: NoLicense: OthersDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/system_on_chip/gecko4_soc_co-design_environment/index.html'>gecko4 soc co-design environment</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_gecko4_soc_co-design_environment'>code</a>
                </td>
                <td>Apr 7, 2011</td>
                <td>VHDL</td>
                <td>Planning</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip shBone Compliant: NoLicense: LGPLDescriptionGeneric AHB matrix. It is a multi-master, multi-slave non-blocking AHB matrix with round-robin arbitration. Builds Verilog AHB matrices according to input parameters: master number, slave number, data bits, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatoolsRelated projectsGeneric AHB master stubhttp://opencores.org/project,ahb_masterGeneric AHB slave stubhttp://opencores.org/project,ahb_slave</div>
                    <a href='cores/system_on_chip/generic_ahb_matrix/index.html'>generic ahb matrix</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_generic_ahb_matrix'>code</a>
                </td>
                <td>Sep 21, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip  Compliant: NoLicense: LGPLDescriptionGeneric APB register file generator. Creates Verilog source, C header file and HTML documentation, from an Excel worksheet. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatoolsRelated projectsGeneric APB master stubhttp://opencores.org/project,apb_mstrGeneric AXI2APB bridgehttp://opencores.org/project,robust_axi2apb</div>
                    <a href='cores/system_on_chip/generic_apb_register_file/index.html'>generic apb register file</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_generic_apb_register_file'>code</a>
                </td>
                <td>Mar 16, 2015</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ishBone Compliant: NoLicense: LGPLDescriptionGeneric AXI interconnect fabric. It is a multi-master, multi-slave non-blocking AXI fabric with round-robin arbitration. Builds Verilog AXI interconnects according to input parameters: master number, slave number, AXI IDs, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatoolsRelated projectsGeneric AXI master stubhttp://opencores.org/project,axi_masterGeneric AXI slave stubhttp://opencores.org/project,axi_slave</div>
                    <a href='cores/system_on_chip/generic_axi_interconnect_fabric/index.html'>generic axi interconnect fabric</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_generic_axi_interconnect_fabric'>code</a>
                </td>
                <td>Jun 12, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip one Compliant: NoLicense: LGPLDescriptionGeneric AXI to AHB bridge. Built according to input parameters: AXI command depth, data bits, etc. Supports error on illegal AHB bursts and AHB slave error. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/system_on_chip/generic_axi_to_ahb_bridge/index.html'>generic axi to ahb bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_generic_axi_to_ahb_bridge'>code</a>
                </td>
                <td>Jun 2, 2012</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip one Compliant: NoLicense: LGPLDescriptionGeneric AXI to APB bridge. Builds design according to required number of slaves, address decoding, AXI command depth, etc. Supports decode error, APB response delay and slave error. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/system_on_chip/generic_axi_to_apb_bridge/index.html'>generic axi to apb bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_generic_axi_to_apb_bridge'>code</a>
                </td>
                <td>Apr 19, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ovenWishBone Compliant: YesLicense: LGPLDescriptionShort: virtually convert an I2C slave into a WISHBONE slaveThis is a wrapper for the I2C controller core by Richard Herveille (http://opencores.org/project,i2c)which transparently converts a WISHBONE transaction into an I2C operation.Example: a WB read/write of the WB address 09h of this core would schedule and execute the (long) list of commands needed to make an I2C read/write of reg 09h of an I2C device connected to the I2C controller core in OpenCores, and return the result transparently into the WB bus.IMPORTANT: The current wrapper is fo</div>
                    <a href='cores/system_on_chip/i2c_controller_wishbone_wrapper/index.html'>i2c controller wishbone wrapper</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_i2c_controller_wishbone_wrapper'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip proven,Specification doneWishBone Compliant: NoLicense: GPLlayer[2] SoCComponentsThe following components are implemented and tested on silicon:MIPS I(tm) CPU @ 50MHzIntel StratFlashPS/2 Keyboard100x37 8-Color Text-VGA19200/8N1 RS-232 Receiver/Transmitter512 MBit DDR RamThe picture to the left shows the start-up screen. With "void Bootloader" you can upload program images to the flash and run then on the DDR.An example program is "Tennmino" a tetris clone for layer[2].AcknowledgementGeneral NoticeEvery component consists of an implementation and an interface file i*.vhd where I credited (hopef</div>
                    <a href='cores/system_on_chip/layer2/index.html'>layer2</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_layer2'>code</a>
                </td>
                <td>Jul 16, 2012</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project demonstrates the use of the P16C5x soft-processor core, found elsewhere on opencores.org, in a system-on-chip. The project targets a small FPGA, the Xilinx XC3S50A-4VQ100I. The project integrates the P16C5x PIC-compatible processor core an SPI Master module, SPIxIF, a Synchronous Serial Peripheral (SSP) slave module, SSP_Slv, an SSP UART, SSP_UART, and an inferred 4096 x 12 Block RAM program memory. (The SPIxIF, SSP_Slv, and SSP_UART modules are all modules that can be found on opencores.org.)The P16C5x module is a PIC-compa</div>
                    <a href='cores/system_on_chip/m16c5x/index.html'>m16c5x</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_m16c5x'>code</a>
                </td>
                <td>Nov 10, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThe Minimal OpenRISC System on Chip is a system on chip (SoC) implementation with standard IP cores available at OpenCores. This implementation consists of a standard project comprehending the standard IP cores necessary for a SoC embedding the OpenRISC implementation OR1200.This project idea is to offer a synthesizable SoC which can be uploaded to every FPGA and be compatible with every FPGA board without the requirement of changing its code. In order to deliver such a project, the project has been based on a standar</div>
                    <a href='cores/system_on_chip/minsoc/index.html'>minsoc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_minsoc'>code</a>
                </td>
                <td>Apr 20, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip  NoLicense:DescriptionThis project is to implement an MP3 decoder in VHDL in terms of MPEG-1 layer3 standard. It is composed of all the components of MP3 decoding process. MP3 bitstreams can be fed into the input module of MP3 decoder and a decoded pcm output file will be produced when the MP3 decoding process is completed.Features- Code is written in VHDLStatus- Verified in simulation using Modelsim</div>
                    <a href='cores/system_on_chip/mp3_decoder/index.html'>mp3 decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_mp3_decoder'>code</a>
                </td>
                <td>Sep 23, 2010</td>
                <td>Unknow</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip gn done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionPC AT SoC based on Next186 core. CPU runs at 33 MHz (up to 33 MIPS), 64MB of dynamic RAM, DOS6.22.Able to run DOS 8086, 80186 applications (most of 80286 applications/games are running ok). May run real mode 32bit 386 applications with a 32bit software extender (see EMU386).Implementation done and tested on Xilinx Spartan3AN evaluation board (with Xilinx ISE 14.5), occupying ~50% FPGA resources.Video modes available: 80x25x256 text, 320x200x256 MCGA graphic, 640x480x256 VESA VBE mode 101h.PS2 8042 controller fo</div>
                    <a href='cores/system_on_chip/next186_soc_pc/index.html'>next186 soc pc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_next186_soc_pc'>code</a>
                </td>
                <td>Jan 7, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip  Compliant: NoLicense: LGPLDescriptionThis is an evolution of my previous project, Next186SoC PC, able to play MP3 files in real time (any bitrate).It is written in Verilog, and it contains all the features of Next186SoC PC, plus a few more.ContentsThis is a PC SoC able to run 16bit DOS. It features the following elements:- a 80186 compatible CPU, running at 40MIPS (Netx186)- 16KB of cache: 4-way set associative- SDRAM interface (up to 64MB of SDRAM supported, through EMM and XMM)- High Memory Area (HMA) useable in DOS- Text mode, EGA(320x200x16), VGA(640x480x16, 320x200x256, ModeX), VESA(640x</div>
                    <a href='cores/system_on_chip/next186mp3/index.html'>next186mp3</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_next186mp3'>code</a>
                </td>
                <td>Mar 10, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip pment status:MatureAdditional info:FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionThis project aims to present an open-source, platform independent MPSoC, targeting FPGA implementation.The NoC based MPSoC is generated by connecting the processing tiles via a low latency NoC network. A processing tile includes one aeMB processor, RAM, NoC interface adapter, and other optional peripheral devices such as GPIO, timer, external interrupts and interrupt controller. All components inside a tile are connected using wishbone bus. The processing tiles can have different number of peripheral d</div>
                    <a href='cores/system_on_chip/noc_based_mpsoc/index.html'>noc based mpsoc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_noc_based_mpsoc'>code</a>
                </td>
                <td>Apr 19, 2014</td>
                <td>Verilog</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip liant: NoLicense: LGPLNoC(Network-on-Chip)NoC(Network-on-Chip)Features-Maximum 4 by 4 Tiles-The synchronizing FIFO-Wormhole routing-Virtual channel(3 stage buffer)-User reconfigure PE(Processing element)'s program</div>
                    <a href='cores/system_on_chip/nocnetwork-on-chip_simulator/index.html'>nocnetwork-on-chip simulator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_nocnetwork-on-chip_simulator'>code</a>
                </td>
                <td>Nov 9, 2009</td>
                <td>SystemC</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip one Compliant: NoLicense: GPLDescriptionA Network on Chip Emulation Tool, NoCem is a body of VHDL code configurable by a toplevel package file that can create a variety of Network on Chips on parameters of datawidth, virtual channel implementations, topology, and in-network buffering lengths. Once parameterized, the resulting NoC is generated automatically with heavy use of VHDL generics and generate statements.author - Graham SchelleFeatures- synthesizable VHDL code for network on chip creation- FPGA implemented- tested/verified- virtual channel implementation option- processor bridge for Xil</div>
                    <a href='cores/system_on_chip/nocem_--_network_on_chip_emulator/index.html'>nocem -- network on chip emulator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_nocem_--_network_on_chip_emulator'>code</a>
                </td>
                <td>Feb 1, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip liant: NoLicense: LGPLDescriptionNoCmodel is a Python module for Network-on-Chip modeling, with add-ons for simulation (functional or RTL) and code generation (initially VHDL).Based on Python language, this module provides a framework for generic modeling of a NoC (IP Core nodes, routers, or channels), and provides some add-ons that extends the model to support design features like functional simulation, RTL simulation, VHDL code generation, etc.NoCmodel is based on NetworkX (http://networkx.lanl.gov) for graph modeling, and MyHDL (http://www.myhdl.org) for simulation support.</div>
                    <a href='cores/system_on_chip/nocmodel/index.html'>nocmodel</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_nocmodel'>code</a>
                </td>
                <td>Mar 4, 2011</td>
                <td>Other</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip WishBone Compliant: NoLicense:DescriptionThe OpenFire soft processor is an open source Verilog implementation of the Xilinx MicroBlaze. Like the MicroBlaze, the OpenFire is a 32-bit RISC processor based on the DLX architecture by Hennessy and Patterson. The OpenFire was developed by Stephen Craven specifically for configurable array research. As such, certain features of the MicroBlaze are not currently implemented. The OpenFire lacks interrupts, exceptions, debugging facilities, and Local Memory Bus and On-chip Peripheral Bus interfaces. These functions may be added in the future. The page of</div>
                    <a href='cores/system_on_chip/openfire/index.html'>openfire</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_openfire'>code</a>
                </td>
                <td>Jun 11, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip Compliant: NoLicense: GPLStatusProject is alive of 17th May 2010. Please try, find bugs, report and develop. We have enormous amount of TODO (see the bugtracker) so each developer is welcome.DescriptionOpenSPARC-based SoC is a project aimed to create a SoC based on OpenSPARC cores (T1 and T2) with OpenCores and other open-source peripherals added, and having Linux/OpenSolaris running on it.AchievementsMain success now is a OS2WB module that bridges the T1 core and FPU to Whishbone bus. With the other obvious components (DRAM, flash, UART) it is able to boot Ubuntu Linux 2.6.22 normally and 2.6</div>
                    <a href='cores/system_on_chip/opensparc-based_soc/index.html'>opensparc-based soc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_opensparc-based_soc'>code</a>
                </td>
                <td>Oct 13, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip nWishBone Compliant: YesLicense:OverviewThis project is an example of using OpenRISC on an Terasic DE1 development board. UBoot has been ported. The old ecos 2.0 has  been ported to ecos 3.0. The adv_debug_sys unit was integrated but not tested.</div>
                    <a href='cores/system_on_chip/or1200_soc/index.html'>or1200_soc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_or1200_soc'>code</a>
                </td>
                <td>Feb 27, 2010</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip : NoLicense: LGPLDescriptionPDP-1 reimplementation using an FPGA. The goal is to run old software like Spacewar!, the music compiler, and Expensive Typewriter on current FPGA hardware. Initial platform is a Spartan 3A starter kit.For more information on the original machine, seehttp://pdp-1.computerhistory.org/pdp-1/</div>
                    <a href='cores/system_on_chip/pdp-1_reimplementation/index.html'>pdp-1 reimplementation</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_pdp-1_reimplementation'>code</a>
                </td>
                <td>Feb 23, 2011</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip fication doneWishBone Compliant: YesLicense:DescriptionThis is is a bridge IP core to interface the Tensilica PIF bus protocol with the OpenCores WishBone. It currently supports single-cycle as well as burst transfer operations. The core has been tested in a master-PIF slave-WB configuration.Features- PIF master support- Wishbone slave support- Burst transfers support- VHDL RTL- Fully synthesisableStatus- RTL: Complete- Document: Complete</div>
                    <a href='cores/system_on_chip/pif2wb/index.html'>pif2wb</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_pif2wb'>code</a>
                </td>
                <td>Aug 7, 2007</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip  provenWishBone Compliant: YesLicense:PLBv46 to Wishbone BridgeThis is a simple CoreConnect PLBv46 to Wishbone bridge that can allow Wishbone peripherals to be used on Xilinx processor designs.  It conforms to the sub-set of the PLBv46 specification adopted by Xilinx in the EDK.Features- PLBv46 Slave Attachment (non bursting)- 32-bit interface to PLBv46 bus.- 32-bit interface to Wishbone bus.- Supports- Handling of Retries.- User can set the retry wait time.- User can set number of times to retry- Result of unsuccessful retry is a PLBv46 bus error ack.- Handling of Bus Errors- User can set how</div>
                    <a href='cores/system_on_chip/plbv46_to_wishbone_bridge/index.html'>plbv46 to wishbone bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_plbv46_to_wishbone_bridge'>code</a>
                </td>
                <td>Mar 5, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip tus:MatureAdditional info:WishBone Compliant: NoLicense: LGPLINFOThe project is RT level design of image component labeling and feature extraction. The design is captured in VHDL. The architecture is parallel and pipelined.The project is posted under LPGL license. User need to give reference to the publishes work when used in design.Hardware Architecture for Real-time Component Feature Descriptors on a FPGAAbdul Waheed Malik, Benny Thrnberg, Najeem Lawal, Muhammad Imranpublication in Internal Journal of Distributed Sensors, special issue onRecent advances in Wireless Visual Sensor Network (WVS</div>
                    <a href='cores/system_on_chip/real-time_image_processing/index.html'>real-time image processing</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_real-time_image_processing'>code</a>
                </td>
                <td>Sep 28, 2014</td>
                <td>VHDL</td>
                <td>Mature</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip nt: NoLicense: GPLrfid tag and readerVerilog models of RFID card / reader.Features- hash lock- blinded anticollisionStatus- implemented Stephen Weis RFID tag modelhttp://theory.lcs.mit.edu/~cis/theses/weis-masters.pdf- it's bad but no good reader model yet (need help)</div>
                    <a href='cores/system_on_chip/rfid_tag_and_reader/index.html'>rfid tag and reader</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_rfid_tag_and_reader'>code</a>
                </td>
                <td>Dec 27, 2011</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip :WishBone Compliant: YesLicense: LGPLDescriptionThis is a complete system-on-a-chip.Developed on a Diligent Spartan3e board, the SOC includes CPU (TG68), bitmap and text displays,  PSG, keyboard and more.Features52x31 text display416 x 262 bitmapped graphics displayline draw accelerator8 sprites4 channel ADSR PSG (not working at the moment)random number generatorPS2 compatible keyboard interfaceTG68 cpuRS232 interface UARTOverviewThe SOC make use of the TG68 cpu core available at OpenCores.org. This fine core implements the MC68000 instruction set.The Nexys Epp memory controller available on t</div>
                    <a href='cores/system_on_chip/rtf68ksys/index.html'>rtf68ksys</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_rtf68ksys'>code</a>
                </td>
                <td>Sep 25, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip liant: NoLicense: GPLEmbedded MIPS R2000It's a synthesizable parametric IP core of 32 bit RISC processor supporting full MIPS R2000 ISA, by using SystemC HDL. An optional CP0 coprocessor implementing full exception handling was also modelled. Also 64 bit pipeline multiplier supporting is optional, and pipeline depth is configurable.Features- feature1- feature1.1-feature1.2-feature2StatusSome bugs was fix.-&gt; correct bug when intterupt occur during MFLO and MFHI instruction.Now I'm working on the CP0status 2</div>
                    <a href='cores/system_on_chip/sardmips/index.html'>sardmips</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_sardmips'>code</a>
                </td>
                <td>Feb 9, 2006</td>
                <td>Other</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip e Compliant: NoLicense: LGPLDescriptionSimpCon is a specification for a simple and efficient system-on-chip (SoC) interconnect. SimpCon provides single cycle commands and provisions for pipelining of read and write connections. SimpCon is public domain and freely available.Translation to and from Wishbone, the opencores standard interface, are provided.Documentation is in the CVS athttp://www.opencores.org/cvsweb.cgi/~checkout~/simpcon/doc/simpcon.pdfA paper published at the Austrochip on SimpCon is available from:http://www.jopdesign.com/doc/simpcon_austrochip2007.pdfFeatures- Synchronous int</div>
                    <a href='cores/system_on_chip/simpcon-a_simple_soc_interconnect/index.html'>simpcon-a simple soc interconnect</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_simpcon-a_simple_soc_interconnect'>code</a>
                </td>
                <td>Nov 13, 2007</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip : NoLicense: GPLDescriptionSoft Multiprocessor on FPGA is becoming more attractive as the design cost and NRE soaring up in deep-submicron age, especially for high performance computing applications. However, it becomes time consuming and error prone to design multiprocessor as the number of processors grows quickly. To make it easier,  I am going to design a tool (BlazeCluster) to generate multiprocessor architecture on FPGA consisting of Xilinx microblaze, PowerPC and open source processor cores from a simple, top-level  script.The tool is written in Perl. On most of Linux installations, the</div>
                    <a href='cores/system_on_chip/soft_multiprocessor_on_fpga/index.html'>soft multiprocessor on fpga</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_soft_multiprocessor_on_fpga'>code</a>
                </td>
                <td>Mar 12, 2008</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip hBone Compliant: YesLicense: GPLDescriptionWelcome to theSTORM SoCproject!This is an FPGA/evaluation board-independent, complete system on chip implementation based on the STORM CORE processor.Most of the SoC's components were designed by myself, but the are also some IPs used, which are available here at oppencores.All components are connected via an 32-bit, pipelined Wishbone bus fabric.The boot ROM features a pre-installed bootloader, which allows easy program downloading to RAM or to an attached IC EEPROM.It is also capable of booting program files directly from the EEPROM.Compatible progr</div>
                    <a href='cores/system_on_chip/storm_soc/index.html'>storm soc</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_storm_soc'>code</a>
                </td>
                <td>Mar 14, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ification doneWishBone Compliant: NoLicense:System-on-Chip Wire (SoCWire)SoCWire has been developed by IDA, Technical University Braunschweig. It is a Network-on-Chip (NoC) approach based on the ESA SpaceWire interface standard to support dynamic reconfigurable System-on-Chip (SoC). SoCWire has been developed to provide a robust communication architecture for the harsh space environment and to support dynamic partial reconfiguration in future space applications.SoCWire provides:	Reconfigurable point-to-point communication	High speed data rate	Hot-plug ability to support dynamic reconfigurable </div>
                    <a href='cores/system_on_chip/system-on-chip_wire_socwire/index.html'>system-on-chip wire socwire</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_system-on-chip_wire_socwire'>code</a>
                </td>
                <td>Jun 25, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip Bone Compliant: NoLicense: GPLDescription6805 compatible CPU Core. Does not have any of the standard 6805 on chip peripherals at this stage other than the parallel I/O port.This was the first of the 68xx processors I attempted and have only just got around to completing it..The Home Page for the project isHereFeatures- 6805 compatible core- 4 x 8 bit Parallel I/O ports- Dual 8 bit Timer- MiniUART compatible with 6850 ACIA.- Runs with an E clock of 12.5MHz and system clock of 25MHzStatus- Prints out "Hello World" and waits for an input character- Implemented on B5-X300 Spartan 2e board-</div>
                    <a href='cores/system_on_chip/system05/index.html'>system05</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_system05'>code</a>
                </td>
                <td>Apr 7, 2008</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip rovenWishBone Compliant: YesLicense:wishbone_and_wishbone-&gt;opb_bus_interface_wrappers"&gt;OPB -&gt;WISHBONE and WISHBONE-&gt;OPB bus interface wrappersOPB Bus to WISHBONE bus and WISHBONE bus to OPB bus interface wrappers.The Interface wrappers are provided as a plug-in for Xilinx EDK. To install, untarr the dowloadable archive in $EDK_ROOT/hw/XilinxProcessorIPLib/pcores/.You have to restart XPS to see the new wrappers.this_ip_core_is_provided_by:       "&gt;This IP Core is provided by:www.ASICS.ws - Solutions for your ASIC/FPGA needs -StatusThis project is Done</div>
                    <a href='cores/system_on_chip/wb-opb_and_opb-wb_interface_wrapper/index.html'>wb/opb and opb/wb interface wrapper</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wb-opb_and_opb-wb_interface_wrapper'>code</a>
                </td>
                <td>Sep 12, 2004</td>
                <td>Other</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip  Compliant: YesLicense:To do- add verilog outputKnown errors- when data bus size is 8 bits the script generates wishbone sel signals which are of no useFeatures- GUI for easy startup- supports both shared bus and csorrbarswitch topologyStatus- design tested in HDL simulator and in FPGA (ALTERA C12)- current design only support VHDL outputDescriptionThe intention is to provide an easy way to create and change a system based on the WISHBONE bus. The user shall be able to try different configurations to achieve an area/performance optimized design.WISHBONE builder is a script which generates a wi</div>
                    <a href='cores/system_on_chip/wishbone_builder/index.html'>wishbone builder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbone_builder'>code</a>
                </td>
                <td>Oct 3, 2014</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip nt: YesLicense:DescriptionThis is a WISHBONE Interconnect ShareBus IP core.It can interconnect up to 8 Masters and 8 SlavesSome of the main features are:Up to 8 MastersUp to 8 SlavesOnly 1 priority level processed in a round robin wayFeatures- feature1- feature2Status- 4/19/2003 Initial Release</div>
                    <a href='cores/system_on_chip/wishbone_conbus_ip_core/index.html'>wishbone conbus ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbone_conbus_ip_core'>code</a>
                </td>
                <td>Aug 3, 2012</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip Compliant: YesLicense:DescriptionThis is a WISHBONE Interconnect Matrix IP core.It can interconnect up to 8 Masters and 16 SlavesSome of the main features are:- Up to 8 Masters- Up to 16 Slaves- 1, 2 or 4 priority levels- Fully configurableIMAGE: conmax.jpgFILE: conmax.jpgDESCRIPTION:Example SoC with the CONMAX IP CoreStatus- October 2002, Maintenance update: Fixed a typo in parameter passing and in the specification- May 2002. Several users of the core have reported that the core performs as specified. Project is now considered completed.- 10/19/2001 Initial Release.- I will post a message t</div>
                    <a href='cores/system_on_chip/wishbone_conmax_ip_core/index.html'>wishbone conmax ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbone_conmax_ip_core'>code</a>
                </td>
                <td>Feb 10, 2004</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip pliant: YesLicense:DescriptionThis is a simple DMA/Bridge IP core. It has two WISHBONE interface. It can perform DMA transfers between the two interfaces or on the same interfaces.Some of the main features are:- Up to 31 DMA Channels- 2, 4 or 8 priority levels- Linked List Descriptors support- Circular Buffer support- FIFO buffer support- Software &amp; Hardware handshake support- Automatic Channel Registers Reload support- Fully configurablePlease see the spec for more details !Status- 8/2/2001 Added another feature: Now you can backoff to the beginning of the current transfers (this is usefu</div>
                    <a href='cores/system_on_chip/wishbone_dma-bridge_ip_core/index.html'>wishbone dma/bridge ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbone_dma-bridge_ip_core'>code</a>
                </td>
                <td>May 22, 2007</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip gn doneWishBone Compliant: YesLicense: LGPLDescriptionAre you using Wishbone, do you need some simple 'slaves' to test your bus with ?Well, the Wishbone spec, appendix B3, has VHDL examples of Wishbone outports, and memories.This is the code from B3 ! saves one copying the PDF each time.Features- Can be simulated and can be synthesised.StatusSimulated in XST 9.2 sp 4Synthesised to Spartan FPGA.</div>
                    <a href='cores/system_on_chip/wishbone_out_port_from_b3_spec/index.html'>wishbone out port from b3 spec</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbone_out_port_from_b3_spec'>code</a>
                </td>
                <td>Jan 29, 2008</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip WishBone Compliant: YesLicense:DescriptionA Wishbone SoC of a 6800/01 CPU based projectFeatures- Motorola 6800/01 'instruction set' CPU CORE (Object code compatable)- RMCA01 - Relocatable Macro Cross Assembler included (Shareware by M. Hasenfratz)- Tested on Altera Apex20K, Cyclone and Stratix developement boards (NIOS Kits)- All system components have Wishbone Interfaces:- 6800/01 CPU (Core by John Kent)- miniUart/ACIA- miniUart/SCI- Timer / Counter- Programmable I/O (PIO)- 128byte RAM  [Note: uses Altera LPM_RAM encapsulated in WishBone I/F]- 2KB ROM with debug monitor [Note: uses Altera LPM</div>
                    <a href='cores/system_on_chip/wishbone_system6800-01/index.html'>wishbone system6800/01</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbone_system6800-01'>code</a>
                </td>
                <td>Mar 10, 2004</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip provenWishBone Compliant: YesLicense:WISHBONE Protocol to AHB Protocol Bridge.Features-  AHB 2.0 compliant-  Wishbone B.3 compliant-  WISHBONE Burst NOT SUPPORTED-  Fully synthesisable-  Synchronous-  Verilog RTL-  Includes a Verilog Testbench with 9 TestcasesStatus-  RTL : Complete-  Testbench : Complete-  Document : Complete</div>
                    <a href='cores/system_on_chip/wishbone_to_ahb_bridge/index.html'>wishbone to ahb bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbone_to_ahb_bridge'>code</a>
                </td>
                <td>Feb 17, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip sLicense:DescriptionWhisboneTK is a set of IP cores designed to be compatible with theWishbonebusspecification. The members of the tool-kit are general purpose building-blocks that (hopefuly) make designing Wishbone compatibledevices easier. The elements in the libarary are avaliable free for any kind of use .The parts in the library use anextended signal-setthan defined in the Wishbone interface.By moving all technology-specific code to a different, underlying package, the toolkit is fairly easy to port to other technologies.Currently Xilinx (XST) is the supported and tested platfor</div>
                    <a href='cores/system_on_chip/wishbonetk_toolkit/index.html'>wishbonetk toolkit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_wishbonetk_toolkit'>code</a>
                </td>
                <td>Jun 4, 2008</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip ant: NoLicense:Z80 System on ChipSystem on chip, based on T80 core.This project is a SOC designed for Altera DE1 development board and the Diligent Spartan 3E, and provide access to leds, switches, buttons, IO pins, SRAM, VGA, LCD and keyboard using Z80 assembly language.Comes with a reference ROM application that show how to access all resources on the board. Spartan 3E port provides easy access to the LCD (memory mapped, 32 bytes of ram).There are tools included in the project files to convert fonts (psf) to MIF and COE, and convert files containing hex codes in VHDL ROM files, what makes it</div>
                    <a href='cores/system_on_chip/z80_system_on_chip/index.html'>z80 system on chip</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_z80_system_on_chip'>code</a>
                </td>
                <td>Nov 23, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on chip al info:WishBone Compliant: YesLicense: LGPLStatusThis project is in the early planning stage. I am collecting documentation for both busses and beginning to understand them, and refining the specifications. I'm collecting tools for design and test and preparing a development environment on my computer. I'm currently taking a VHDL course at university, and thus will plan to have both Verilog and VHDL versions of this bridge. Progress on this design will hopefully pick up this summer 2012.I intend to use as many freely available tools as possible, and will have some learning curve to be product</div>
                    <a href='cores/system_on_chip/zorro_bus_to_wishbone_bridge/index.html'>zorro bus to wishbone bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_chip_zorro_bus_to_wishbone_bridge'>code</a>
                </td>
                <td>Mar 9, 2012</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>SYSTEM ON MODULE</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>system on module  info:WishBone Compliant: NoLicense: LGPLDescriptionSystem-on-Module based on an ARM SoC in combination with an ALTERA FPGA. Focus for this module is connectivity, flexibilityand a high performance/price ratio.Form factorThe form factor for this module is 200 pin SO-DIMM.ConnectivityModule has a rich flavor of connectivity available.The ARM SoC from Micrel contains a manageable 4+1 port 10/100 Mbpsswitch. The switch has built-in Fast Ethernet PHY for this. Two port can optionally support 100FX.The swicth can be used in scenarios with 1 WAN port and 4 LAN ports.Connected over the KSZ8095P PCI b</div>
                    <a href='cores/system_on_module/som-arm9-cycloneivgx/index.html'>som-arm9-cycloneivgx</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_on_module_som-arm9-cycloneivgx'>code</a>
                </td>
                <td>May 29, 2012</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>SYSTEM CONTROLLER</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller mpliant: YesLicense:DescriptionThis is a AC 97 Controller Core. It provides a an interface to an external AC 97 Audio Codec. This allows the implementation of CD quality Audio Input/Output.Features- AC97 Revision 2.2 Compliant- Variable and Fixed Sample Rate Support, up 48 kHz- 16, 18 and 20 bit Sample Size Support- 6 Channel Surround Sound Support- Stereo Input channel Support- Mono Microphone Channel Support- External DMA Engine Support- WISHBONE SoC host InterfaceStatus- 8/2/2001 New Directory Structure ! We have agreed on a common directory structure at OpenCores.- The AC97 Core is Done !-</div>
                    <a href='cores/system_controller/ac_97_controller_ip_core/index.html'>ac 97 controller ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_ac_97_controller_ip_core'>code</a>
                </td>
                <td>Jul 11, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller Specification doneWishBone Compliant: NoLicense: GPLDescriptionThis core is intended to be used as an interface between some functionality in an FPGA and an external microcontroller.The external microcontroller provides a simple 8bit interface to control some functions within the FPGA. These functions are communicating using a wishbone compatible bus within the FPGA.Features- 8 bit external interface to a simple parallel port of a regular microcontroller- two cycle external bus transfers: first address, then data- interrupt request flag- bidirectional external data port- wishbone compatible ma</div>
                    <a href='cores/system_controller/external_parallel_port_to_internal_wishbone_master/index.html'>external parallel port to internal wishbone master</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_external_parallel_port_to_internal_wishbone_master'>code</a>
                </td>
                <td>Jun 26, 2008</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller e Compliant: YesLicense:DescriptionThis is a advanced Memory Controller intended for embedded applications. Some of the features are:- SDRAM, SSRAM, FLASH, ROM and many other devices supported- 8 Chip selects, each uniquely programmable- Flexible timing to accommodate a variety of memory devices- Burst transfers and burst termination- Performance optimization by leaving active rows open- Default boot sequence support- Dynamic bus sizing for reading from Async. Devices- Byte parity Generation and Checking- Multi Master memory bus support- Industry standard WISHBONE SoC host interface- Up to 8 *</div>
                    <a href='cores/system_controller/memory_controller_ip_core/index.html'>memory controller ip core</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_memory_controller_ip_core'>code</a>
                </td>
                <td>Jan 11, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller  YesLicense:DescriptionATA (AT attachment) interface core, also known as the IDE (Integrated Drive Electronics) interface.The ATA interface provides a simple interface to (low cost) non-volatile memories, like harddisk drives, DVD players, CD(ROM) players/writers and CompactFlash and PC-CARD devices.Status- Three cores are available in VHDL and Verilog from OpenCores CVS via cvsweb or via cvsget.- ToDo:- Write documentation- Start development of OCIDEC-4, featuring UltraDMA supportDevelopment goalsThe development of a range of software and function backward compatible cores with a growing set </div>
                    <a href='cores/system_controller/ocidec_opencores_ide_controller/index.html'>ocidec opencores ide controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_ocidec_opencores_ide_controller'>code</a>
                </td>
                <td>May 6, 2015</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller pliant: YesLicense:</div>
                    <a href='cores/system_controller/pci_bridge/index.html'>pci bridge</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_pci_bridge'>code</a>
                </td>
                <td>Jul 4, 2006</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller WishBone Compliant: NoLicense:pcie_vera_tbFEATURES	16 bit PIPE Spec PCI Express Testbench	Link training	Initial Flow Control	Packet Classes for easy to build PHY,DLLP and TLP packets	DLLP 16 bit CRC and TLP LCRC generation	Sequence Number generation and checking	ACK TLP packets	Scrambling	MemRd MemWr CfgRd CfgWr TLPsFunctional Description and BackgroundThis testbench has been designed to resemble the TI XIO1100 X1 PHY which has a 16 bit 125 MHz PIPE spec interface.  This is a great PCI Express starter VERA testbench.  It can easily be added to, to get the desired results.  The testbench perfor</div>
                    <a href='cores/system_controller/pci_express_x1_16bit_vera_testbench/index.html'>pci express x1 16bit vera testbench</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_pci_express_x1_16bit_vera_testbench'>code</a>
                </td>
                <td>Jan 15, 2008</td>
                <td>Other</td>
                <td>Unknow</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller ompliant: NoLicense: LGPLMotivationThere are already a few cores that translate PCI bus into Wishbone bus, but none of them really worked in my project. So I took the code of the project "pci_mini" and built my own core out of it. Thanks to the original authors of pci_mini!I'm quite new to VHDL, and this is my first big project. So I cannot guarantee that everything runs 100% smooth, but I try my best. :-)DescriptionThis core implements a 16 MB DWord-addressable memory image in the Wishbone bus (so WB width is 32 bit). Its functionality is reduced to the minimum which is required by the PCI sp</div>
                    <a href='cores/system_controller/pci_slave_to_wb_master/index.html'>pci slave to wb master</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_pci_slave_to_wb_master'>code</a>
                </td>
                <td>Dec 6, 2011</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller n done,FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionThe PCI32tLite IP core provides the funtionality of a PCI TARGET. The core has been designed to permit interface between a PCI Master and simple WHISBONE Slaves, and fitting into smallest FPGA (about 200 LC's in ALTERA CYCLONE II FPGA).Whisbone databus size and endianess configurable: "BIG"/"LITTLE",32/16/8 bits.PCI memory or I/O map configurable.Uses BAR0 register; occupies 32Mbytes on PCI memory map or 512Bytes on PCI I/O map.StatusTested on HW:- ALTERA MAXII Kit.- XILINX Raggedstone1 board.- Other custom HW.PCI32TLITE_OC_HOWTO</div>
                    <a href='cores/system_controller/pci_target/index.html'>pci target</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_pci_target'>code</a>
                </td>
                <td>Aug 24, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller done,FPGA provenWishBone Compliant: NoLicense: LGPLOverviewThis package involves a PCIe Scatter-Gather DMA engine for Virtex5 and Virtex6.The design implements MAC, Physical (Xilinx Hard and Soft IP Cores) and Transaction Layer (Custom Core) of PCIe.It holds 3 BAR&euro;&trade;s, BAR[0], BAR[1] and BAR[2], as its memory space.  Registers are accessed via BAR[0], including the system registers, DMA channel registers and some other control and status registers.  Block RAM are assigned to BAR[1]. BAR[2] contains the FIFO data ports, both write and read. FIFO control and status registers reside in </div>
                    <a href='cores/system_controller/pcie_sg_dma_controller/index.html'>pcie sg dma controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_pcie_sg_dma_controller'>code</a>
                </td>
                <td>Mar 26, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller  info:WishBone Compliant: YesLicense: LGPLDescriptionThe PCIe_DS_DMA core provides PCI Express controller for Xilinx HARD core for Virtex5, Virtex6, Spartan6 FPGA.Main featuresPCI Express 1.1 x1,x4,x8 or 2.0 x4two address space: BAR0, BAR1access to registers can only be single 32-bit instructionslocal bus: 64 bit, 250 MHztwo independent bidirectional DMA channelDMA channel only works in the SCATTER-GATHER modeThe minimum unit of data for channel DMA - 4 kBDescriptors combined into the block descriptors. The maximum number of descriptors in the block - 63DMA channel uses 40 bit addressesResourc</div>
                    <a href='cores/system_controller/pcie_ds_dma/index.html'>pcie_ds_dma</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_pcie_ds_dma'>code</a>
                </td>
                <td>Apr 20, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller nfo:Design done,FPGA proven,Specification doneWishBone Compliant: YesLicense: LGPLDescriptionThis is a very simple PCI-target to Wishbone-master bridge.PCI-Target only, the bandwidth is quite low, fixed memory-image size (16MB), but it has a very low FPGA logic resource need.This is a single VHDL (old version was verilog) file, so easy to use.The original PCI module is from: Ben Jackson http:www.ben.com/minipci/verilog.phpRedesigned for wishbone : Istvan Nagy, Hardware Design Engineer. www.buenos.extra.huCode variants/versions:------------------------ Up till v3.3 (verilog) the code was tested</div>
                    <a href='cores/system_controller/pci_mini/index.html'>pci_mini</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_pci_mini'>code</a>
                </td>
                <td>Aug 17, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller Design done,Specification doneWishBone Compliant: NoLicense: BSDDescriptionLarge electronic systems often use multiple supply voltages that must come up and go down in a specified order. Also, it must be made sure that the system is not powered up only partly for a prolonged time. This power sequencer is composed of equal slices, one for each supply stage.</div>
                    <a href='cores/system_controller/power_supply_sequencer/index.html'>power supply sequencer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_power_supply_sequencer'>code</a>
                </td>
                <td>Apr 23, 2014</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller nt: NoLicense: LGPLDescription&euro;&oelig;pic&euro;? is a soft core, programmable interrupt controller which can be used as an interface between peripheral interrupt lines and processor IRQ line. One of the popular PIC available in market is Intel 8259. This core is not compatible with 8259. The core was designed based on my ideas of how a PIC operates and its requirements. The first version is a really basic core which can take 8 interrupts as input. The interrupt detecting methods currently supported are polling method and fixed priority method.A testbench code is provided with the core tes</div>
                    <a href='cores/system_controller/programmable_interrupt_controller/index.html'>programmable interrupt controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_programmable_interrupt_controller'>code</a>
                </td>
                <td>Oct 27, 2010</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller al info:Design done,FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionrs232_syscon is a synthesizeable soft core that allows debugging of peripherals connected to a Wishbone type of bus. Specifically, it lets the user write and read registers, and send out reset pulses, via an rs232 serial connection to a "dumb terminal." (Such as windows "hyperterm"!) It is completely scalable through parameter settings, to accomodate address and data buses of any arbitrary size. Furthermore, the rs232_syscon module can share the Wishbone bus with the master (presumably a processor of some kind). It i</div>
                    <a href='cores/system_controller/rs232_system_controller/index.html'>rs232 system controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_rs232_system_controller'>code</a>
                </td>
                <td>Jan 23, 2015</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller e Compliant: NoLicense:DescriptionThis proyect is designed to adapt either a host system, or a perypherical controller system to a scsi bus.Also the chip is a DMA controller for a host, in cluding a SRAM controller and a 32 to 8 bits converter for transmit data between a processor and the SCSI bus.It is formed by 7 submodules that have specific functions that will be explain deeply later in this document.It can operate in anyone of three posible states : disconected, connected as a target or connected as an Initiator.The following is a summary of the SCSI protocol between host(initiator) and a</div>
                    <a href='cores/system_controller/scsi_chip/index.html'>scsi_chip</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_scsi_chip'>code</a>
                </td>
                <td>Oct 8, 2008</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller : NoLicense:DescriptionThe Synchronous-DRAM controller core allows any synchronous bus masters, such as most Intel microcontroller and x86 processors, to effortlessly interface to a large capacity SDRAM as though it were an SRAM. The core supports PC100 timing specifications.By default the core is configured to work with 512K x 2 Bank x 32-bit SDRAMs such as Samsung KM432S2030CT and Fujitsu MB81F643242B. Easy modifications allows the core to work with different capacity SDRAMs. Most of the critical parameters are defines in a global include file allowing easy reconfigurability of the core.The </div>
                    <a href='cores/system_controller/synchronous-dram_controller/index.html'>synchronous-dram controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_synchronous-dram_controller'>code</a>
                </td>
                <td>Oct 15, 2001</td>
                <td>Unknow</td>
                <td>Alpha</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller nfo:Design doneWishBone Compliant: NoLicense:DescriptionA project aimed at providing a DSP/FPGA based development board.Testing has begun, so far Power supplies, DSP, FPGAs have been proven to be 100% functional. Testing of the SDRAM and FLASH memories has be started and will require time  for pattern read/write to be completed.If you are interested in this dev kit please contact me by my email address. I will be happy to call/email you back with more details. We have 3 more kits available, but will require assembling (typ. 2 weeks) before they can be shipped. We have not determined </div>
                    <a href='cores/system_controller/ti_dsp_and_xilinx_fpga_dev_board/index.html'>ti dsp and xilinx fpga dev board</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_ti_dsp_and_xilinx_fpga_dev_board'>code</a>
                </td>
                <td>Apr 16, 2010</td>
                <td>Other</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>system controller ne,FPGA provenWishBone Compliant: YesLicense: LGPLOverviewLCD character display controller with Wishbone and memory mapped interfaces.It is compatible with the following parts: Sitronix ST7066U, Samsung S6A0069X or KS0066U, Hitachi HD44780 and SMOS SED1278.It's commonly used to drive several character displays integrated in popular Xilinx development boards such as Spartan 3E Starter Kit from Digilent.</div>
                    <a href='cores/system_controller/wb_lcd_character_display_controller/index.html'>wb lcd character display controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/system_controller_wb_lcd_character_display_controller'>code</a>
                </td>
                <td>Mar 14, 2009</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>TESTING/VERIFICATION</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification PGA provenWishBone Compliant: NoLicense: LGPLTODOTo support Altera Qsys AXI4 Monitor IP integration.Tk GUIDescriptionA CPU-to-FPGA bus transaction monitor, captures the CPU write/read address/data to/from memory-mapped registers that resides in the FPGA, and transmits the captured information to PC through JTAG download cable attached to the FPGA.The detailed information about this low-level firmware debugger is published by the author on EDN.com as a Design Ideas article: Debug a microcontroller-to-FPGA interface from the FPGA side.The original source code accompanying this article is set as </div>
                    <a href='cores/testing-verification/bus_transaction_monitor_with_jtag/index.html'>bus transaction monitor with jtag</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_bus_transaction_monitor_with_jtag'>code</a>
                </td>
                <td>Feb 8, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification ne Compliant: NoLicense: LGPL</div>
                    <a href='cores/testing-verification/constrained_random_test_generator/index.html'>constrained random test generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_constrained_random_test_generator'>code</a>
                </td>
                <td>Aug 14, 2012</td>
                <td>C/C++</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification ne Compliant: NoLicense: LGPLDescriptionDS1621 verilog model with testing tasks. Testing elements assume the existence of the low level write/read (need to be written by the user) and include the macro tasks based on that write/read tasks. A test with macros is included. Only the Slope and the Counter registers are not supported.</div>
                    <a href='cores/testing-verification/ds1621_model/index.html'>ds1621 model</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_ds1621_model'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification Bone Compliant: NoLicense: LGPLDescriptionEziDebug is an easy-to-use versatile logic simulation tool for verification and debugging of digital circuits. It supports inserting scan chains in projects. Furthermore&OElig;more functions and characteristics will be opened. This manual is intended for users with no previous experience with EziDebug . It introduces you with the basic flow how to set up EziDebug. The example used in this tutorial is a small design written in Verilog and only the most basic commands will be covered in this manual. This manual was made by using Version 1.0 of EziDebug o</div>
                    <a href='cores/testing-verification/ezidebug/index.html'>ezidebug</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_ezidebug'>code</a>
                </td>
                <td>Jul 29, 2013</td>
                <td>C/C++</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification WishBone Compliant: NoLicense: LGPLDescriptionFor make stimulus of testbench some times need work with files from VHDL. I think that will be very good if some different stimulus will be in one place.</div>
                    <a href='cores/testing-verification/from_and_to_files/index.html'>from and to files</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_from_and_to_files'>code</a>
                </td>
                <td>Jan 14, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification ishBone Compliant: NoLicense: LGPLDescriptionGeneric AHB master stub. Built out of an AXI master and an AXI2AHB bridge. Supports 32/64 data bits, AHB bursts and random wait-states. The design is built according to input parameters: address bits, data bits, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/testing-verification/generic_ahb_master_stub/index.html'>generic ahb master stub</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_generic_ahb_master_stub'>code</a>
                </td>
                <td>Apr 27, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification shBone Compliant: NoLicense: LGPLDescriptionGeneric AHB slave stub. Supports 32/64 data bits, AHB bursts and random wait-states. The design is built according to input parameters: address bits, data bits, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/testing-verification/generic_ahb_slave_stub/index.html'>generic ahb slave stub</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_generic_ahb_slave_stub'>code</a>
                </td>
                <td>Apr 27, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification hBone Compliant: NoLicense: LGPLDescriptionGeneric APB master stub. Based on an AXI master stub and an AXI2APB bridge. Supports both APB and APB3 protocols (APB3 is with pready and pslverr signals). The design is built according to input parameters: address bits, protocol type, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/testing-verification/generic_apb_master_stub/index.html'>generic apb master stub</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_generic_apb_master_stub'>code</a>
                </td>
                <td>Aug 3, 2014</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification shBone Compliant: NoLicense: LGPLDescriptionGeneric APB slave stub. Support both APB and APB3 protocols (APB3 is with pready and pslverr). Supports slave error, random and fixed wait-states. The design is built according to input parameters: address bits, protocol type, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/testing-verification/generic_apb_slave_stub/index.html'>generic apb slave stub</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_generic_apb_slave_stub'>code</a>
                </td>
                <td>Apr 22, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification ishBone Compliant: NoLicense: LGPLDescriptionGeneric AXI master stub. Supports multiple internal masters (multiple AXI IDs), 32/64 data bits, AXI bursts and random wait-states. The design is built according to input parameters: ID number, data bits, AXI command depth, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/testing-verification/generic_axi_master_stub/index.html'>generic axi master stub</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_generic_axi_master_stub'>code</a>
                </td>
                <td>Oct 21, 2013</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification shBone Compliant: NoLicense: LGPLDescriptionGeneric AXI slave stub. Supports 32/64 data bits, AXI bursts and random wait-states. The design is built according to input parameters: address bits, data bits, AXI command depth, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded fromhttp://www.provartec.com/edatools</div>
                    <a href='cores/testing-verification/generic_axi_slave_stub/index.html'>generic axi slave stub</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_generic_axi_slave_stub'>code</a>
                </td>
                <td>Apr 19, 2011</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification neWishBone Compliant: NoLicense: LGPLHASM DescriptionHASM is a simple instruction simulator for use in the verification of FPGA/CPLD designs that must attach to a processor bus. HASM is meant to attach to a bus model that mimics the device attached to the FPGA or CPLD under test. HASM can be used as though it were a processor within the simulation environment without the tremendous increase in simulation times due to the overhead involved in simulating a real processor.The HASM instruction simulator is comprised of two components: a Windows-based IDE and a VHDL module capable of reading the ve</div>
                    <a href='cores/testing-verification/hasm_testbench_vector_generator/index.html'>hasm testbench vector generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_hasm_testbench_vector_generator'>code</a>
                </td>
                <td>Oct 19, 2012</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification e Compliant: NoLicense: BSDDescriptionThe project is intended for checking FPGA-based device for high consumption power.Number of parameter gives possibility to change number of used LC/DFF, DSP, RAM and I/O.It can operate at 200 MHz in Cyclone 5E FPGA.1 LC core is about 1500 LUT4/FF (with default parameters)1 DSP core is 7 DSP 18*18.Each LC core also demands 4*N RAM blocks (32 bits width).To maximize power consumption:1) Find parameters for maximum FPGA resource usage2) Fed maximum frequency clock to CLK input (directly or via PLL instantiated in top level)3) Fed random data to inputs (lower </div>
                    <a href='cores/testing-verification/high_load_configurable_test_project/index.html'>high load configurable test project</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_high_load_configurable_test_project'>code</a>
                </td>
                <td>Feb 19, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification shBone Compliant: NoLicense: LGPLDescriptioni2clcd is a minimalist i2clcd IP core that provides the basic framework for the implementation of custom i2clcd devices. The core provides a means to write up to 256 8-bit registers. These registers can be connected to the users custom logic, thus implementing a simple control and status interface. A full Icarus Verilog test bench is available. Test it for yourself, using the free Icarus Verilog simulator and the free GTKWave wave form viewer.Download and install Icarus Verilog. - Download and install GTKWave. - Download the project files. - For exec</div>
                    <a href='cores/testing-verification/i2clcd/index.html'>i2clcd</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_i2clcd'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification FPGA provenWishBone Compliant: NoLicense: BSDCurrent stable version/logicprobe/tags/LogicProbe-1.1DescriptionLogicProbe is a very simple logic analyzer which can be run onan FPGA in parallel with the "device under test". The analyzerhas a width of 128 data channels, and is 512 samples deep. Ithas a trigger (i.e., it starts catching the channels when thissignal got active once), and a sample enable (i.e., it does onlysample the channels when this line is 1). It uses the block RAMon the FPGA to store the samples in real-time. When the samplebuffer is full, it begins to transmit the samples throu</div>
                    <a href='cores/testing-verification/logicprobe/index.html'>logicprobe</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_logicprobe'>code</a>
                </td>
                <td>Dec 26, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification :WishBone Compliant: NoLicense: LGPLDescriptionThe Open JTAG project has as objetive to give to the public domain a complete hardware and software JTAG project. Based on a simple hardware board, composed basically by a FT245 USB front end and an Altera EPM570 MAX II CPLD, this board is capable to output TCK signal at 24 MHZ using macro-instructions sent from the computer end.It is not as others JTAG projects based on the PC parallel port: Open JTAG project uses the USB channel (still not at high speed) to communicate with the internal CPLD, sending macro-instruction as fastest as possible.You </div>
                    <a href='cores/testing-verification/open_jtag_project/index.html'>open jtag project</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_open_jtag_project'>code</a>
                </td>
                <td>Oct 22, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification  done,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionPlTbUtils makes it easy to create automatic, self-checking simulation testbenches, and to locate bugs during a simulation.It is a collection of functions, procedures and testbench components that simplifies creation of stimuli and checking results of a device under test.Features:Simulation status printed in transcript windows as well as in waveform window (error count, checks count, number and name of current test, etc).Check procedures which output meaningful information when a check fails.Clear SUCCESS/FAIL message at en</div>
                    <a href='cores/testing-verification/pltbutils/index.html'>pltbutils</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_pltbutils'>code</a>
                </td>
                <td>Feb 2, 2015</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification Design done,FPGA provenWishBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/testing-verification/prbs_signal_generator_and_checker/index.html'>prbs signal generator and checker</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_prbs_signal_generator_and_checker'>code</a>
                </td>
                <td>Dec 3, 2011</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification rovenWishBone Compliant: YesLicense: LGPL</div>
                    <a href='cores/testing-verification/socgen/index.html'>socgen</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_socgen'>code</a>
                </td>
                <td>Dec 30, 2012</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification info:FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionConverts Raspberry Pi into a JTAG programmer (STAPL protocol). Supports two JTAG chains through 26-pin RPi GPIO P1 connector. The TCK rate is ~1MHz. Works reliably for distance up to 1m, with LVDS level converter tested successfully for distance up to 15m.Ported from Actel STAPL Player v1.1, which is based on JAM STAPL Player v2.2.</div>
                    <a href='cores/testing-verification/staplplayer/index.html'>staplplayer</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_staplplayer'>code</a>
                </td>
                <td>Apr 4, 2015</td>
                <td>C/C++</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification one Compliant: NoLicense: OthersDescriptionThe SystemVerilog Directed Test Bench.This project contains an exact duplication of the VHDL Test Bench Package parser and usage model.  This enables users to create a simple test environment for verification efforts using SV.  This also enables scripts that were used on the VHDL system to be reused in a SV environment.  (providing the same functionality is coded in the SV environment.)Current state is Beta,  please report any problems to the bug tracking system so I can address issues.</div>
                    <a href='cores/testing-verification/systemverilog_directed_test_bench/index.html'>systemverilog directed test bench</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_systemverilog_directed_test_bench'>code</a>
                </td>
                <td>Aug 26, 2014</td>
                <td>Other</td>
                <td>Beta</td>
                <td>Others</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification roven,Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: BSDOverviewThe VHDL test bench is a collection of VHDL procedures and functions which allow the user to create their own scripting instructions for test stimulus.  The stimulus script or test case contains the instructions in a regular ASCII text file. The function of the instructions is coded in VHDL as part of the test bench.  The test bench VHDL package contains procedures to create instructions, read, parse and execute the test script (stimulus file, test case, script).-------------------------------------------</div>
                    <a href='cores/testing-verification/the_vhdl_test_bench/index.html'>the vhdl test bench</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_the_vhdl_test_bench'>code</a>
                </td>
                <td>Sep 4, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>BSD</td>
            </tr>
            <tr>
                <th>
                    <div hidden>testing/verification one Compliant: NoLicense: LGPLDescriptionThis is a video pattern generator which can be used for testing video displays. It currently supports four patterns; horizontal lines, vertical lines, moving horizontal lines, and moving vertical lines. It sends out 1 pixel every clock cycle and forms the pattern on the fly using counters. This module has been used sucessfully to test a Camera Link serializer, SDXC Card video streamer and video rotator.</div>
                    <a href='cores/testing-verification/video_pattern_generator/index.html'>video pattern generator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_video_pattern_generator'>code</a>
                </td>
                <td>Jun 12, 2013</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <td>
                    <b>VIDEO CONTROLLER</b>
                </td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller  Compliant: NoLicense: GPLDescriptionA hardware based system to decode JPEG baseline compressed image data. The different stages of the decoding process are implemented in a pipelined design described in VHDL. Running on a Virtex-II Pro FPGA at 100 MHz operation frequency. The pipelined structure allows for the processing of multiple image blocks simultanously. Thus, the decoder is prepared to decode MotionJPEG movies. Functionality of the system is demonstrated with a proof-of-concept hardware MotionJPEG video player application.Features- jpeg baseline decoding- mjpeg- display decoded data on</div>
                    <a href='cores/video_controller/mjpeg_decoder/index.html'>mjpeg decoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_mjpeg_decoder'>code</a>
                </td>
                <td>May 30, 2010</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller Design done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project considers a hardware implementation of the CCITT group 4(also known as fax4 or tiff) compression algorithm written in vhdl. The design as it is available compresses camera data into tiff format and transmits over RS232 to a graphical client application developed in C++,Qt that stores the received tiff stream into a file and displays the image. The design is developed and tested on the Digilent Nexys2-1200(spartan-3E) and Atlys(spartan-6) board in combination with the Aptina MT9D131 Image Sensor Headboard.Future e</div>
                    <a href='cores/video_controller/ccitt-g4tiff_compression/index.html'>ccitt-g4tiff compression</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_ccitt-g4tiff_compression'>code</a>
                </td>
                <td>Jan 20, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller  provenWishBone Compliant: NoLicense: LGPL</div>
                    <a href='cores/video_controller/color_converter/index.html'>color converter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_color_converter'>code</a>
                </td>
                <td>Feb 23, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller Design doneWishBone Compliant: NoLicense: LGPLDescriptionPlease write a description of the project here. It is used as a MetaTag (search engines looks at this).</div>
                    <a href='cores/video_controller/demosaic_bilinear/index.html'>demosaic bilinear</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_demosaic_bilinear'>code</a>
                </td>
                <td>Nov 20, 2012</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller ,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionThis core is part of theMilkymist System-on-Chip, the most advanced open source SoC for interactive multimedia applications.Minimal VGA framebuffer coreRGB565 16bppDirectly drives a 3x8-bit DAC and sync signals.Fully configurable timings and resolutionMultiple buffering support with buffer switch during the blanking interval to prevent tearing artifacts.Milkymist CSR and FML bus interfaces.Two asynchronous clock domains - VGA and system.Bit-banged DDC interface.More informationCore documentationCSR bus specificationsFM</div>
                    <a href='cores/video_controller/fastmemorylink_vga_framebuffer_controller/index.html'>fastmemorylink vga framebuffer controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_fastmemorylink_vga_framebuffer_controller'>code</a>
                </td>
                <td>Aug 7, 2010</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller liant: YesLicense:DescriptionThis core is used to provide a wishbone compliant interface to a graphical LCD.  Currently it supports the Crystalfontz  CFAG12864 family which is based on the KS0108B controller.Other graphical LCDs may be supported at a later date.Features- Wishbone compliant- Interfaces with KS0108B graphical LCD controllerStatus- Sythesized and tested</div>
                    <a href='cores/video_controller/graphical_lcd_interfaces/index.html'>graphical lcd interfaces</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_graphical_lcd_interfaces'>code</a>
                </td>
                <td>Aug 27, 2010</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller sign done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis project is a group of hardware units that perform graphics algorithms.For testing purposes, beside the Units that perform these algorithms, there is a Frame Buffer that holds the image drawn and a Video Controller that outputs the image to a screen. In addition to the user interface which consists of switches and push buttons that selects the color, position, function performed, .. etc.Current StateTill now we have the Bresenham Line Drawing Algorithm.Due to the Limitations of the FPGA that I am working on, the Frame Buffe</div>
                    <a href='cores/video_controller/graphics_accelerator/index.html'>graphics accelerator</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_graphics_accelerator'>code</a>
                </td>
                <td>May 20, 2011</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller ishBone Compliant: NoLicense: GPLFeatures- Baseline JPEG encoder- Baseline JPEG decoder (Not ready yet)IntroductionThis is an open source JPEG codec, including both encoder and decoder (decoder is not ready yet), for embedded systems. It can be fully synthesized and implemented on FPGA. There is also a four-processor design based on ithttp://opencores.org/project,mpdma,mpdma20061023c.tar.bz2Different to a fully hardware implementation, this JPEG codec is designed based on Xilinx Microblaze processor with customized hardware accelerators. It is expected to achieve high flexibility, low complexi</div>
                    <a href='cores/video_controller/jpeg_codec_library_based_on_microblaze/index.html'>jpeg codec library based on microblaze</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_jpeg_codec_library_based_on_microblaze'>code</a>
                </td>
                <td>Feb 16, 2011</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller PGA proven,Specification doneWishBone Compliant: NoLicense: LGPLNEWS21 AUG 2011New revision 70. contains new BUF_FIFO contributed Ahmet Tekyildiz which needs circa 9.5 line buffer but achieves performance very close to old design with ~16 lines (8 extra lines). So it heavily reduces on-chip RAM utilization without performance sacrifice.Also this version contains nearest integer rounding in DCT-2D instead of truncation when bit growth/precision is reduced. Truncation caused 8x8 block artifacts easily visible in very high quality modes (&gt;95% quantization tables). Rounding alleviates this prob</div>
                    <a href='cores/video_controller/jpeg_encoder/index.html'>jpeg encoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_jpeg_encoder'>code</a>
                </td>
                <td>Sep 25, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller e Compliant: NoLicense: LGPLDescriptionThis core takes as an input the red, green, and blue pixel values, like from a tiff image file, and creates the JPEG bitstream necessary to build a jpeg image.  The core was written in generic, regular Verilog code that can be targeted to any FPGA.  The core does not rely on any proprietary IP cores, instead all of the functions required to implement the JPEG encoder are written in Verilog and the code is entirely self-contained.  This core has been simulated on many raw images with different quantization and Huffman tables.</div>
                    <a href='cores/video_controller/jpeg_encoder_verilog/index.html'>jpeg encoder verilog</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_jpeg_encoder_verilog'>code</a>
                </td>
                <td>Mar 17, 2012</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller A proven,Specification doneWishBone Compliant: NoLicense:DescriptionThis project features a complete JPEG Hardware Compressor (standard Baseline DCT, JFIF header) with 2:1:1 subsampling, able to compress at a rate of up to 24 images per second at the maximum resolution 352x288 (on XC2V1000-4 @ 40 MHz).IMAGE RESOLUTION IS LIMITED TO 352x288. It takes an RGB input (row-wise) and outputs to a memory the compressed JPEG image with headers.A testbench has been made that takes a bitmap image from your computer and writes a compressed JPEG file by simulating the code.In order to be able </div>
                    <a href='cores/video_controller/jpeg_hardware_compressor/index.html'>jpeg hardware compressor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_jpeg_hardware_compressor'>code</a>
                </td>
                <td>May 9, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller License:DescriptionLCD Driver that we want to designed is a CMOS LCD driver capable of driving a multiplexed display of up to 128 segments ( 16 columns by 8 backplanes ). The number of backplanes being driven is programmable from one to eight. Data to be displayed is sent to the chip serially and stored in an internal RAM. An external resistor and capasitor control the frequency of the driving signals to the LCD. The displayed data may also be read serially from the on-chip RAM.Specifications- Operates on 22-bits (five bits first is address, the next bit is read and write flags, and 16 bits da</div>
                    <a href='cores/video_controller/lcd_driver/index.html'>lcd driver</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_lcd_driver'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller Bone Compliant: NoLicense: LGPLDescriptionSimple memory mapped, character type dot matrix LCD controller for interfacing the Samsung's KS0073.The controller supports the 40SEG extension driver providing a 4-line x 20 character display. It uses a memory mapped 4x20x8 bit matrix, transformed in real-time to the display.It completely takes the responsibility for sending the appropriate sequences of commands to the KS0073. The higher layer needs only to take care of the content of the matrix. This makes its implementation as a microcontroller peripheral unit very comfortable.http://www-user.tu-che</div>
                    <a href='cores/video_controller/memory_mapped_lcd_controller_ks0073/index.html'>memory mapped lcd controller ks0073</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_memory_mapped_lcd_controller_ks0073'>code</a>
                </td>
                <td>Sep 12, 2010</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller liant: NoLicense:OverviewThe MiniGA is a small graphics adapter for microcontrollers. It outputs a video signal for TVs, VCRs and TFTs with video input. MiniGA features a SPI interface which makes interfacing to most microcontrollers easy. A cycle-shared-RAM interface coordinates read and write accesses to the RAM so the user needn't take care about data collisions which simplifies the usage. Moreover MiniGA generates all needed timings and outputs a digital video which is converted to analog by a 10Bit DAC externally.Features-  PAL Encoder Core written 100% in VHDL- No Xilinx/Altera specific </div>
                    <a href='cores/video_controller/miniga-high_quality_pal_encoder/index.html'>miniga-high quality pal encoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_miniga-high_quality_pal_encoder'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller esign done,FPGA provenWishBone Compliant: NoLicense: LGPLDescriptionThis VHDL macro is a Text Mode Monochrome Video Display Adapter for VGA monitors. It can be used as a peripheral for a soft-processor, external microcontroller or other non-programmable hardware. It's not much better than the original IBM MDA card appeared in 1981 ;-)Features- resolution is 80x40 characters, dot resolution is 640x480 pixels at 60Hz so the core needs a clock signal of 25MHz. I prefer 80x40 instead the classical 80x25, in my opinion, the latter is an annoyance.- monocrome, it hasn't "attribute" memory to store t</div>
                    <a href='cores/video_controller/monochrome_text-mode_vga_video_display_adapter/index.html'>monochrome text-mode vga video display adapter</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_monochrome_text-mode_vga_video_display_adapter'>code</a>
                </td>
                <td>Jul 11, 2014</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller al info:WishBone Compliant: NoLicense: GPLDescriptionHigh-definition programmable and configurable motion estimation processor for H.264, VC-1 and AVS video codecs.SummaryThe LiquidMotion LMx1 processor is a reconfigurable ASIP (Application Specific Instruction Set Processor) designed to execute user-defined block-matching motion estimation algorithms optimized for hybrid video codecs such as MPEG-2, MPEG-4, H.264 AVC and Microsoft VC-1.  The core offers scalable performance dependent on the features of the chosen algorithm and the number and type of execution units implemented. The ability to</div>
                    <a href='cores/video_controller/motion_estimation_processor/index.html'>motion estimation processor</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_motion_estimation_processor'>code</a>
                </td>
                <td>Jan 6, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller nWishBone Compliant: NoLicense:DescriptionThe design provides basic video function.Features- Configurable resolution up to 1600x1400- Configurable pixel width 16,32 bit per pixel- Configurable Burst Size and NPI width- Stride support- Direct memory access through Xilinx NPI channel- Support Spartan3x family, Virtex4, Virtex5- Demo design and bitstream available for EUS FS, ML403, ML405 and ML505Status- Resolutions: 640x480x32/16; 800x600x32/16; 1024x768x32/16; 1600x1200x16- Tested platforms Spartan3E, Virtex4, Virtex5- Design is available in VHDL - XPS coreTo do- Docs- Add virtual DMA engine- </div>
                    <a href='cores/video_controller/npi_graphics_controller/index.html'>npi graphics controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_npi_graphics_controller'>code</a>
                </td>
                <td>Jul 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller onal info:FPGA provenWishBone Compliant: NoLicense: GPLDescriptionThis is an OPB-compatible VGA character display for the Spartan 3E development board, which does not contain DACs.The core is very small, requiring only 3 BRAMs and 533 slices.All access is through write character commands, similar to an LCD display. 3-bit color is supported, as well as inverted characters.Current resolution is 640x480, 75x55 charactersFeatures- Ease of use- Includes write string function- Individual characters can also be written- Small footprintStatus- status1- status2</div>
                    <a href='cores/video_controller/opb-compatible_vga_character_display_no_dac/index.html'>opb-compatible vga character display no dac</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_opb-compatible_vga_character_display_no_dac'>code</a>
                </td>
                <td>Oct 17, 2007</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller doneWishBone Compliant: NoLicense: LGPLConnecting to the world outsideThis part was completely redesigned due to variant output inpedances of different CPLD/FPGA and to reduce the moving pattern from older versions.The two transistors are used for impedance transformation so the output inpedance has not more much effectto the result. In the upper part the luminance signal is generated and in the lower part the chrominancesignal. The two 1,2KOhm resistors on  fbh and fbl pin sets the chrominance output toa defined level. The chrominance signal is mixed with the luminace signal by an simple capa</div>
                    <a href='cores/video_controller/pal-ntsc_encoder/index.html'>pal/ntsc encoder</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_pal-ntsc_encoder'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller tion doneWishBone Compliant: YesLicense: GPLDescriptionThe ROSETTA Configurable Dot Matrix Display Controller core provides a modular expandable interface for any dimension displays build from LEDs dot matrix structures. This core can be configured for synthesis and P&amp;R with any number of DM LEDs slices. These slices can be arranged in any number to form linear or plane screens.In designs with a big number of slices, the number of pins required for the implementation device selected could collapse. In order to overcome this inconvenience, the output bus has a multiplexed structure, and the</div>
                    <a href='cores/video_controller/rosetta_configurable_dot_matrix_display_controller/index.html'>rosetta configurable dot matrix display controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_rosetta_configurable_dot_matrix_display_controller'>code</a>
                </td>
                <td>Jun 12, 2006</td>
                <td>Other</td>
                <td>Planning</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller o:FPGA provenWishBone Compliant: YesLicense: LGPLDescriptionThis core is a low to medium resolution bitmap display controller. It was engineered for use on theNexsys2 board, a Spartan3e FPGA board, but is readily adaptable to other environments. The core hasbeen upgraded for use on the Atlys FPGA board. The latest incarnation of the core is being developed on a Nexys4 board.Features- small size- supports high, mid and low resolution bitmap display- programmable display format (divide by 1,2, or 4).- programmable color depth (8,16, or 32 bpp).- 32 byte burst fetching- memory bandwidth considera</div>
                    <a href='cores/video_controller/rtfbitmapcontroller/index.html'>rtfbitmapcontroller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_rtfbitmapcontroller'>code</a>
                </td>
                <td>May 3, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller nfo:WishBone Compliant: NoLicense: LGPLDescriptionThis core provide hardware cursor / sprite capabilities. It supports alpha blending in the 32k color mode. The cursor characteristics are completely programmable. The core has been updated to reflect larger amounts of memory and resources available in newer devices.Features- parameterized number of sprites/cursors 1,2,4,6,8,14, or 32- 4kB sprite image cache buffers- each image cache is capable of holding multiple sprite images- cache may be accessed like a memory by the processor- an embedded DMA controller may also be used for sprite reload- p</div>
                    <a href='cores/video_controller/rtfspritecontroller-hardware_cursors/index.html'>rtfspritecontroller/hardware cursors</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_rtfspritecontroller-hardware_cursors'>code</a>
                </td>
                <td>May 15, 2015</td>
                <td>Verilog</td>
                <td>Alpha</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller PGA provenWishBone Compliant: YesLicense: LGPLDescriptionThe latest incarnation of the text controller has a default resolution of 56x31 expecting a 1366x768 screen resolution. The size and number of characters displayed is easily programmable. The controller now uses externally supplied horizontal and vertical sync signals for a reference point. The controller detects the positive edge of the signals. The display memory is 32 bits wide of which 9 bits are used for each of foreground, background colors, and the character code. Character codes and attributes are stored together in the same memo</div>
                    <a href='cores/video_controller/rtftextcontroller/index.html'>rtftextcontroller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_rtftextcontroller'>code</a>
                </td>
                <td>Jun 27, 2014</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller one,FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionDriver for Sharp LQ057Q3DC02 320x240 QVGA LCD.  Driver accurate to datasheet specifications.  Will also work for LQ057Q3DC12 (Pb-free version).Features- Fully parameterizable and easily adapted to larger LCD screen by simply changing counter register sizes and generic timing parameters.- All-digital interconnect.  No digital to analog converter required.  Simply attach the output ports of the top-level entity to the data connector on the LCD.- Includes specific files for the Xilinx Virtex-II Pro development board av</div>
                    <a href='cores/video_controller/sharp_lq057q3dc02_lcd_controller/index.html'>sharp lq057q3dc02 lcd controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_sharp_lq057q3dc02_lcd_controller'>code</a>
                </td>
                <td>Apr 12, 2015</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller FPGA provenWishBone Compliant: NoLicense: GPLProgress- Display one repeat line (800 pixels) stored in ROM synthesized in FPGA.- Self-display word block (designed).- (Have problem on hardware integration) Preparing display a frame stored in SSRAM which is on Logic Module.- Parameter:- VBP/VFP (Vertical-Sync. back/front porch)- HBP/HFP (Horizontal-Sync. back/front porch)- PPL/LPP (Pixel Per Line/Line Per Panel)- I design the width of synchronization to be auto-calculated by the way of how it display.\:- Improve:- Efficiency of data transformation.- Support more kinds of display.- ..to be continu</div>
                    <a href='cores/video_controller/tft_lcd_controller/index.html'>tft lcd controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_tft_lcd_controller'>code</a>
                </td>
                <td>Dec 20, 2009</td>
                <td>Verilog</td>
                <td>Planning</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller FPGA proven,Specification doneWishBone Compliant: NoLicense: GPLDescriptionThis is an implementation of the Sinclair ULA chip, found in ZX Spectrum microcomputers. The project offers various implementations: both FPGA friendly (with separate input and output data buses), and CPLD ready, to be used as a replacement for the many chips that comprise the ULA found in some clones.This project is mostly based upon the work of Chris Smith. Chris designed a ZX Spectrum clon, the "Harlequin". A PCB has been developed by Don "Superfo", which uses discrete logic to implement the ULA, as Chris did. The CP</div>
                    <a href='cores/video_controller/ula_chip_for_zx_spectrum/index.html'>ula chip for zx spectrum</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_ula_chip_for_zx_spectrum'>code</a>
                </td>
                <td>Jan 6, 2013</td>
                <td>Verilog</td>
                <td>Beta</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller en,Design done,FPGA provenWishBone Compliant: YesLicense: GPLDescriptionThe OpenCores VGA/LCD Controller core is a WISHBONE revB.3 compliant embedded VGA core capable of driving CRT and LCD displays. It supports user programmable resolutions and video timings, which are limited only by the available WISHBONE bandwidth. Making it compatible with almost all available LCD and CRT displaysThe core supports a number of color modes, including 32bpp, 24bpp, 16bpp, 8bpp gray-scale, and 8bpp-pseudo color. The video memory is located outside the primary core, thus providing the most flexible memory solu</div>
                    <a href='cores/video_controller/vga-lcd_controller/index.html'>vga/lcd controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_vga-lcd_controller'>code</a>
                </td>
                <td>Sep 21, 2013</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>GPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller ompliant: NoLicense:DescriptionThe 'Video Compression Systems Project' was started with the idea to provide readily available blocks for compression systems. Which, combined toghether, form a complete compression standard.Examples of popular standards are:- MPEG (MPEG-1, MPEG-2, MPEG-4) and H.264- H.310, H.320 etc. (video conferencing)- JPEG &amp; MJPEG- etc.All aspects of a standard are covered. The links on the top of this page provide access to the blocks needed to build a complete system.Status- Finished cores:- - 8x8 fully pipelined parallel DCT. Provides a DCT result every clock cycle.- </div>
                    <a href='cores/video_controller/video_compression_systems/index.html'>video compression systems</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_video_compression_systems'>code</a>
                </td>
                <td>Aug 27, 2008</td>
                <td>Unknow</td>
                <td>Stable</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller gn done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe core supplies post-processing for a video signal.It reduces the color width while dithering the image to keep the impression of more colors than really exist.This reduces banding effects and enhances the quality for the viewer.The used method is "Sierra Lite".The core is configurable (at compile/synthesis time) in:- resolution- input color width- output color widthIt uses very few ressources.Common Full HD Dithering (1920*1080 @ 60hz @ 6 bit from 8 bit source)used with many LCD Displays possible on cyclone </div>
                    <a href='cores/video_controller/video_dithering/index.html'>video dithering</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_video_dithering'>code</a>
                </td>
                <td>Jun 29, 2013</td>
                <td>VHDL</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller hBone Compliant: NoLicense:DescriptionThis kit is meant for people which want to start developing on fpgas but don't want to spent too much money on tooling and jtag debuggers.this kit will contain a small fpga (altera Cyclone II) and an AVR (atmega64) microprocessor with dataflash for programming the fpga through the serial or USB connection.as peripherals for the fpga there are a video encoder and decoder on board, to connect the kit between a DVD player and a TV through composite I/O.simple video filters can be tested on the kit, and as the AVR can use the fpga as external memory, it's also</div>
                    <a href='cores/video_controller/video_starter_kit/index.html'>video starter kit</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_video_starter_kit'>code</a>
                </td>
                <td>Mar 11, 2015</td>
                <td>Other</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller fo:Design done,FPGA proven,Specification doneWishBone Compliant: NoLicense: LGPLDescriptionThe Video Stream Scaler scales streaming video up or down in resolution. Bilinear and nearest neighbor resizemodes are supported.This core provides run-time adjustment of input and output resolution, scaling factors, and scaletype. Compile time adjustment of maximum resolutions and data width.Resource usage and speedFPGA: Altera Cyclone III 3C120Configuration: 10 bits per pixel, 1 color channel, RFIFO size of 3Logic Cells: 571Registers: 237M9ks: 99x9 multipliers: 318x18 multipliers: 8Greater than 108MHz </div>
                    <a href='cores/video_controller/video_stream_scaler/index.html'>video stream scaler</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_video_stream_scaler'>code</a>
                </td>
                <td>Aug 7, 2012</td>
                <td>Verilog</td>
                <td>Stable</td>
                <td>LGPL</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller  YesLicense:DescriptionWishbone Monitor Controller is a set of freely available VHDL cores. It contains a central building block containing the basic functionality. It can then be sorrounded by various helper functions to add functionality. The central core comprises of a sync generator, a pixel data generator, a memory interface and a CPU interface. It is specificly designed for slow 8-bit systems (although CPU interface size can be set) with no high needs about a display. It is also designed to be simple and small (cheap). The target is the whole design to be well fit in an Altera ACEX 1k30 </div>
                    <a href='cores/video_controller/wishbone_monitor_controller/index.html'>wishbone monitor controller</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_wishbone_monitor_controller'>code</a>
                </td>
                <td>Oct 15, 2001</td>
                <td>Unknow</td>
                <td>Beta</td>
                <td>Unknown</td>
            </tr>
            <tr>
                <th>
                    <div hidden>video controller Bone Compliant: NoLicense: BSDDescriptionThis core is a simple and small VGA controller.It drives vga monitors with an 800x600 resolutionand 72Hz vertical refresh rate (50MHz pixel clock)It displays chars on the screen (each char is 8x16 pixels)It has a customizable charset (you can use a simple text editor in order to "visually" customize it)It can display a color "waveform"It can display a color grid and "cross cursor"Click the image in order to see a full size screenshot:YAVGA ported toPapilioboard byGadget FactoryVGA Connector Example"&gt;</div>
                    <a href='cores/video_controller/yet_another_vga/index.html'>yet another vga</a>
                </th>
                <td>
                    <a href='https://github.com/fabriziotappero/ip-cores/tree/video_controller_yet_another_vga'>code</a>
                </td>
                <td>Apr 14, 2012</td>
                <td>VHDL</td>
                <td>Alpha</td>
                <td>BSD</td>
            </tr>
        </tbody>
    </table>
    <p id='foot'>Updated on June XXXX</p>
</div>
          </div>
    </body>
    <script src="jquery.min.js"></script>
    <script src="quick_search.js"></script>
    <script src="fittext.js"></script>
    <script src="generic.js"></script>
    <!-- GOOGLE ANALYTICS! -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-56701553-1', 'auto');
      ga('send', 'pageview');
    </script>
</html>
